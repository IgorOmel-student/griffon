<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MappingBindings.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">griffon-javafx</a> &gt; <a href="index.source.html" class="el_package">griffon.javafx.beans.binding</a> &gt; <span class="el_source">MappingBindings.java</span></div><h1>MappingBindings.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2008-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package griffon.javafx.beans.binding;

import javafx.beans.binding.BooleanBinding;
import javafx.beans.binding.DoubleBinding;
import javafx.beans.binding.FloatBinding;
import javafx.beans.binding.IntegerBinding;
import javafx.beans.binding.LongBinding;
import javafx.beans.binding.ObjectBinding;
import javafx.beans.binding.StringBinding;
import javafx.beans.value.ObservableBooleanValue;
import javafx.beans.value.ObservableDoubleValue;
import javafx.beans.value.ObservableFloatValue;
import javafx.beans.value.ObservableIntegerValue;
import javafx.beans.value.ObservableLongValue;
import javafx.beans.value.ObservableObjectValue;
import javafx.beans.value.ObservableStringValue;
import javafx.beans.value.ObservableValue;
import javafx.collections.ObservableList;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Supplier;

import static java.util.Objects.requireNonNull;
import static javafx.beans.binding.Bindings.createBooleanBinding;
import static javafx.beans.binding.Bindings.createDoubleBinding;
import static javafx.beans.binding.Bindings.createFloatBinding;
import static javafx.beans.binding.Bindings.createIntegerBinding;
import static javafx.beans.binding.Bindings.createLongBinding;
import static javafx.beans.binding.Bindings.createObjectBinding;
import static javafx.beans.binding.Bindings.createStringBinding;

/**
 * @author Andres Almiray
 * @since 2.10.0
 */
public final class MappingBindings {
    private static final String ERROR_MAPPER_NULL = &quot;Argument 'mapper' must not be null&quot;;
    private static final String ERROR_SUPPLIER_NULL = &quot;Argument 'supplier' must not be null&quot;;
    private static final String ERROR_OBSERVABLE_NULL = &quot;Argument 'observable' must not be null&quot;;
    private static final String ERROR_OBSERVABLE1_NULL = &quot;Argument 'observable1' must not be null&quot;;
    private static final String ERROR_OBSERVABLE2_NULL = &quot;Argument 'observable2' must not be null&quot;;
    private static final String ERROR_DEFAULT_VALUE_NULL = &quot;Argument 'defaultValue' must not be null&quot;;

<span class="nc" id="L62">    private MappingBindings() {</span>
        // prevent instantiation
<span class="nc" id="L64">    }</span>

    /**
     * Converts an observable into an object binding.
     *
     * @param observable the observable to be converted.
     * @param mapper     a non-interfering, stateless function to apply to the observable value.
     *
     * @return an object binding.
     *
     * @since 2.11.0
     */
    @Nonnull
    public static &lt;T, R&gt; ObjectBinding&lt;R&gt; mapAsObject(@Nonnull final ObservableValue&lt;T&gt; observable, @Nonnull final Function&lt;T, R&gt; mapper) {
<span class="nc" id="L78">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L79">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L80">        return createObjectBinding(() -&gt; mapper.apply(observable.getValue()), observable);</span>
    }

    /**
     * Converts an observable into an object binding.
     *
     * @param observable the observable to be converted.
     * @param mapper     a non-interfering, stateless function to apply to the observable value.
     *
     * @return an object binding.
     *
     * @since 2.11.0
     */
    @Nonnull
    public static &lt;T, R&gt; ObjectBinding&lt;R&gt; mapAsObject(@Nonnull final ObservableValue&lt;T&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;T, R&gt;&gt; mapper) {
<span class="nc" id="L95">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L96">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L97">        return createObjectBinding(() -&gt; {</span>
<span class="nc" id="L98">            Function&lt;? super T, R&gt; mapperValue = mapper.getValue();</span>
<span class="nc" id="L99">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L100">            return mapperValue.apply(observable.getValue());</span>
        }, observable);
    }

    /**
     * Converts an observable into a boolean binding.
     *
     * @param observable the observable to be converted.
     * @param mapper     a non-interfering, stateless function to apply to the observable value.
     *
     * @return a boolean binding.
     *
     * @since 2.11.0
     */
    @Nonnull
    public static &lt;T&gt; BooleanBinding mapAsBoolean(@Nonnull final ObservableValue&lt;T&gt; observable, @Nonnull final Function&lt;T, Boolean&gt; mapper) {
<span class="nc" id="L116">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L117">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L118">        return createBooleanBinding(() -&gt; mapper.apply(observable.getValue()), observable);</span>
    }

    /**
     * Converts an observable into a boolean binding.
     *
     * @param observable the observable to be converted.
     * @param mapper     a non-interfering, stateless function to apply to the observable value.
     *
     * @return a boolean binding.
     *
     * @since 2.11.0
     */
    @Nonnull
    public static &lt;T&gt; BooleanBinding mapAsBoolean(@Nonnull final ObservableValue&lt;T&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;T, Boolean&gt;&gt; mapper) {
<span class="nc" id="L133">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L134">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L135">        return createBooleanBinding(() -&gt; {</span>
<span class="nc" id="L136">            Function&lt;? super T, Boolean&gt; mapperValue = mapper.getValue();</span>
<span class="nc" id="L137">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L138">            return mapperValue.apply(observable.getValue());</span>
        }, observable);
    }

    /**
     * Converts an observable into an integer binding.
     *
     * @param observable the observable to be converted.
     * @param mapper     a non-interfering, stateless function to apply to the observable value.
     *
     * @return an integer binding.
     *
     * @since 2.11.0
     */
    @Nonnull
    public static &lt;T&gt; IntegerBinding mapAsInteger(@Nonnull final ObservableValue&lt;T&gt; observable, @Nonnull final Function&lt;T, Integer&gt; mapper) {
<span class="nc" id="L154">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L155">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L156">        return createIntegerBinding(() -&gt; mapper.apply(observable.getValue()), observable);</span>
    }

    /**
     * Converts an observable into an integer binding.
     *
     * @param observable the observable to be converted.
     * @param mapper     a non-interfering, stateless function to apply to the observable value.
     *
     * @return an integer binding.
     *
     * @since 2.11.0
     */
    @Nonnull
    public static &lt;T&gt; IntegerBinding mapAsInteger(@Nonnull final ObservableValue&lt;T&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;T, Integer&gt;&gt; mapper) {
<span class="nc" id="L171">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L172">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L173">        return createIntegerBinding(() -&gt; {</span>
<span class="nc" id="L174">            Function&lt;? super T, Integer&gt; mapperValue = mapper.getValue();</span>
<span class="nc" id="L175">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L176">            return mapperValue.apply(observable.getValue());</span>
        }, observable);
    }

    /**
     * Converts an observable into a long binding.
     *
     * @param observable the observable to be converted.
     * @param mapper     a non-interfering, stateless function to apply to the observable value.
     *
     * @return a long binding.
     *
     * @since 2.11.0
     */
    @Nonnull
    public static &lt;T&gt; LongBinding mapAsLong(@Nonnull final ObservableValue&lt;T&gt; observable, @Nonnull final Function&lt;T, Long&gt; mapper) {
<span class="nc" id="L192">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L193">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L194">        return createLongBinding(() -&gt; mapper.apply(observable.getValue()), observable);</span>
    }

    /**
     * Converts an observable into a long binding.
     *
     * @param observable the observable to be converted.
     * @param mapper     a non-interfering, stateless function to apply to the observable value.
     *
     * @return a long binding.
     *
     * @since 2.11.0
     */
    @Nonnull
    public static &lt;T&gt; LongBinding mapAsLong(@Nonnull final ObservableValue&lt;T&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;T, Long&gt;&gt; mapper) {
<span class="nc" id="L209">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L210">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L211">        return createLongBinding(() -&gt; {</span>
<span class="nc" id="L212">            Function&lt;? super T, Long&gt; mapperValue = mapper.getValue();</span>
<span class="nc" id="L213">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L214">            return mapperValue.apply(observable.getValue());</span>
        }, observable);
    }

    /**
     * Converts an observable into a float binding.
     *
     * @param observable the observable to be converted.
     * @param mapper     a non-interfering, stateless function to apply to the observable value.
     *
     * @return a float binding.
     *
     * @since 2.11.0
     */
    @Nonnull
    public static &lt;T&gt; FloatBinding mapAsFloat(@Nonnull final ObservableValue&lt;T&gt; observable, @Nonnull final Function&lt;T, Float&gt; mapper) {
<span class="nc" id="L230">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L231">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L232">        return createFloatBinding(() -&gt; mapper.apply(observable.getValue()), observable);</span>
    }

    /**
     * Converts an observable into a float binding.
     *
     * @param observable the observable to be converted.
     * @param mapper     a non-interfering, stateless function to apply to the observable value.
     *
     * @return a float binding.
     *
     * @since 2.11.0
     */
    @Nonnull
    public static &lt;T&gt; FloatBinding mapAsFloat(@Nonnull final ObservableValue&lt;T&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;T, Float&gt;&gt; mapper) {
<span class="nc" id="L247">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L248">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L249">        return createFloatBinding(() -&gt; {</span>
<span class="nc" id="L250">            Function&lt;? super T, Float&gt; mapperValue = mapper.getValue();</span>
<span class="nc" id="L251">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L252">            return mapperValue.apply(observable.getValue());</span>
        }, observable);
    }

    /**
     * Converts an observable into a double binding.
     *
     * @param observable the observable to be converted.
     * @param mapper     a non-interfering, stateless function to apply to the observable value.
     *
     * @return a double binding.
     *
     * @since 2.11.0
     */
    @Nonnull
    public static &lt;T&gt; DoubleBinding mapAsDouble(@Nonnull final ObservableValue&lt;T&gt; observable, @Nonnull final Function&lt;T, Double&gt; mapper) {
<span class="nc" id="L268">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L269">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L270">        return createDoubleBinding(() -&gt; mapper.apply(observable.getValue()), observable);</span>
    }

    /**
     * Converts an observable into a double binding.
     *
     * @param observable the observable to be converted.
     * @param mapper     a non-interfering, stateless function to apply to the observable value.
     *
     * @return a double binding.
     *
     * @since 2.11.0
     */
    @Nonnull
    public static &lt;T&gt; DoubleBinding mapAsDouble(@Nonnull final ObservableValue&lt;T&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;T, Double&gt;&gt; mapper) {
<span class="nc" id="L285">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L286">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L287">        return createDoubleBinding(() -&gt; {</span>
<span class="nc" id="L288">            Function&lt;? super T, Double&gt; mapperValue = mapper.getValue();</span>
<span class="nc" id="L289">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L290">            return mapperValue.apply(observable.getValue());</span>
        }, observable);
    }

    /**
     * Converts an observable into a string binding.
     *
     * @param observable the observable to be converted.
     * @param mapper     a non-interfering, stateless function to apply to the observable value.
     *
     * @return a string binding.
     *
     * @since 2.11.0
     */
    @Nonnull
    public static &lt;T&gt; StringBinding mapAsString(@Nonnull final ObservableValue&lt;T&gt; observable, @Nonnull final Function&lt;T, String&gt; mapper) {
<span class="nc" id="L306">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L307">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L308">        return createStringBinding(() -&gt; mapper.apply(observable.getValue()), observable);</span>
    }

    /**
     * Converts an observable into a string binding.
     *
     * @param observable the observable to be converted.
     * @param mapper     a non-interfering, stateless function to apply to the observable value.
     *
     * @return a string binding.
     *
     * @since 2.11.0
     */
    @Nonnull
    public static &lt;T&gt; StringBinding mapAsString(@Nonnull final ObservableValue&lt;T&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;T, String&gt;&gt; mapper) {
<span class="nc" id="L323">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L324">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L325">        return createStringBinding(() -&gt; {</span>
<span class="nc" id="L326">            Function&lt;? super T, String&gt; mapperValue = mapper.getValue();</span>
<span class="nc" id="L327">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L328">            return mapperValue.apply(observable.getValue());</span>
        }, observable);
    }

    /**
     * Converts a string object observable value into an object binding.
     *
     * @param observable the observable to be converted.
     *
     * @return an object binding.
     */
    @Nonnull
    public static ObjectBinding&lt;String&gt; mapToObject(@Nonnull final ObservableStringValue observable) {
<span class="fc" id="L341">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="fc" id="L342">        return createObjectBinding(observable::get, observable);</span>
    }

    /**
     * Converts a boolean object observable value into an object binding.
     *
     * @param observable the observable to be converted.
     *
     * @return an object binding.
     */
    @Nonnull
    public static ObjectBinding&lt;Boolean&gt; mapToObject(@Nonnull final ObservableBooleanValue observable) {
<span class="fc" id="L354">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="fc" id="L355">        return createObjectBinding(observable::get, observable);</span>
    }

    /**
     * Converts a integer object observable value into an object binding.
     *
     * @param observable the observable to be converted.
     *
     * @return an object binding.
     */
    @Nonnull
    public static ObjectBinding&lt;Integer&gt; mapToObject(@Nonnull final ObservableIntegerValue observable) {
<span class="fc" id="L367">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="fc" id="L368">        return createObjectBinding(observable::get, observable);</span>
    }

    /**
     * Converts a long object observable value into an object binding.
     *
     * @param observable the observable to be converted.
     *
     * @return an object binding.
     */
    @Nonnull
    public static ObjectBinding&lt;Long&gt; mapToObject(@Nonnull final ObservableLongValue observable) {
<span class="fc" id="L380">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="fc" id="L381">        return createObjectBinding(observable::get, observable);</span>
    }

    /**
     * Converts a float object observable value into an object binding.
     *
     * @param observable the observable to be converted.
     *
     * @return an object binding.
     */
    @Nonnull
    public static ObjectBinding&lt;Float&gt; mapToObject(@Nonnull final ObservableFloatValue observable) {
<span class="fc" id="L393">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="fc" id="L394">        return createObjectBinding(observable::get, observable);</span>
    }

    /**
     * Converts a double object observable value into an object binding.
     *
     * @param observable the observable to be converted.
     *
     * @return an object binding.
     */
    @Nonnull
    public static ObjectBinding&lt;Double&gt; mapToObject(@Nonnull final ObservableDoubleValue observable) {
<span class="fc" id="L406">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="fc" id="L407">        return createObjectBinding(observable::get, observable);</span>
    }

    /**
     * Converts a boolean object observable value into a boolean binding.
     *
     * @param observable the observable to be converted.
     *
     * @return a boolean binding.
     */
    @Nonnull
    public static BooleanBinding mapToBoolean(@Nonnull final ObservableObjectValue&lt;Boolean&gt; observable) {
<span class="fc" id="L419">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="fc" id="L420">        return createBooleanBinding(observable::get, observable);</span>
    }

    /**
     * Converts a integer object observable value into a integer binding.
     *
     * @param observable the observable to be converted.
     *
     * @return a integer binding.
     */
    @Nonnull
    public static IntegerBinding mapToInteger(@Nonnull final ObservableObjectValue&lt;Integer&gt; observable) {
<span class="fc" id="L432">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="fc" id="L433">        return createIntegerBinding(observable::get, observable);</span>
    }

    /**
     * Converts a long object observable value into a long binding.
     *
     * @param observable the observable to be converted.
     *
     * @return a long binding.
     */
    @Nonnull
    public static LongBinding mapToLong(@Nonnull final ObservableObjectValue&lt;Long&gt; observable) {
<span class="fc" id="L445">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="fc" id="L446">        return createLongBinding(observable::get, observable);</span>
    }

    /**
     * Converts a float object observable value into a float binding.
     *
     * @param observable the observable to be converted.
     *
     * @return a float binding.
     */
    @Nonnull
    public static FloatBinding mapToFloat(@Nonnull final ObservableObjectValue&lt;Float&gt; observable) {
<span class="fc" id="L458">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="fc" id="L459">        return createFloatBinding(observable::get, observable);</span>
    }

    /**
     * Converts a double object observable value into a double binding.
     *
     * @param observable the observable to be converted.
     *
     * @return a double binding.
     */
    @Nonnull
    public static DoubleBinding mapToDouble(@Nonnull final ObservableObjectValue&lt;Double&gt; observable) {
<span class="fc" id="L471">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="fc" id="L472">        return createDoubleBinding(observable::get, observable);</span>
    }

    /**
     * Converts a literal object observable value into a string binding.
     *
     * @param observable the observable to be converted.
     *
     * @return a string binding.
     */
    @Nonnull
    public static StringBinding mapToString(@Nonnull final ObservableObjectValue&lt;String&gt; observable) {
<span class="fc" id="L484">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="fc" id="L485">        return createStringBinding(observable::get, observable);</span>
    }

    /**
     * Creates an observable list where all elements of the source list are mapped by the supplied function.
     *
     * @param source the source list.
     * @param mapper a non-interfering, stateless function to apply to the reduced value.
     *
     * @return an observable list.
     */
    @Nonnull
    public static &lt;S, T&gt; ObservableList&lt;T&gt; mapList(@Nonnull final ObservableList&lt;? super S&gt; source, @Nonnull final Function&lt;S, T&gt; mapper) {
<span class="nc" id="L498">        return new griffon.javafx.support.MappingObservableList&lt;&gt;((ObservableList&lt;? extends S&gt;) source, mapper);</span>
    }

    /**
     * Creates an observable list where all elements of the source list are mapped by the supplied function.
     *
     * @param source the source list.
     * @param mapper a non-interfering, stateless function to apply to the reduced value.
     *
     * @return an observable list.
     */
    @Nonnull
    public static &lt;S, T&gt; ObservableList&lt;T&gt; mapList(@Nonnull final ObservableList&lt;S&gt; source, @Nonnull final ObservableValue&lt;Function&lt;S, T&gt;&gt; mapper) {
<span class="nc" id="L511">        return new griffon.javafx.support.MappingObservableList&lt;&gt;(source, mapper);</span>
    }

    /**
     * Creates an object binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     *
     * @return an object binding.
     */
    @Nonnull
    public static &lt;T, R&gt; ObjectBinding&lt;R&gt; mapObject(@Nonnull final ObservableValue&lt;T&gt; observable, @Nonnull final Function&lt;? super T, ? extends R&gt; mapper) {
<span class="fc" id="L524">        return mapObject(observable, mapper, (R) null);</span>
    }

    /**
     * Creates an object binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable   the source observable.
     * @param mapper       a non-interfering, stateless function to apply to the reduced value.
     * @param defaultValue the value to be returned if there is no value present, may be null.
     *
     * @return an object binding.
     */
    @Nonnull
    public static &lt;T, R&gt; ObjectBinding&lt;R&gt; mapObject(@Nonnull final ObservableValue&lt;T&gt; observable, @Nonnull final Function&lt;? super T, ? extends R&gt; mapper, @Nullable final R defaultValue) {
<span class="fc" id="L538">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="fc" id="L539">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L540">        return createObjectBinding(() -&gt; {</span>
<span class="fc" id="L541">            T sourceValue = observable.getValue();</span>
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">            return sourceValue == null ? defaultValue : mapper.apply(sourceValue);</span>
        }, observable);
    }

    /**
     * Creates an object binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     * @param supplier   a {@code Supplier} whose result is returned if no value is present.
     *
     * @return an object binding.
     */
    @Nonnull
    public static &lt;T, R&gt; ObjectBinding&lt;R&gt; mapObject(@Nonnull final ObservableValue&lt;T&gt; observable, @Nonnull final Function&lt;? super T, ? extends R&gt; mapper, @Nonnull final Supplier&lt;R&gt; supplier) {
<span class="nc" id="L557">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L558">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L559">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="nc" id="L560">        return createObjectBinding(() -&gt; {</span>
<span class="nc" id="L561">            T sourceValue = observable.getValue();</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">            return sourceValue == null ? supplier.get() : mapper.apply(sourceValue);</span>
        }, observable);
    }

    /**
     * Creates an object binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     *
     * @return an object binding.
     */
    @Nonnull
    public static &lt;T, R&gt; ObjectBinding&lt;R&gt; mapObject(@Nonnull final ObservableValue&lt;T&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;? super T, ? extends R&gt;&gt; mapper) {
<span class="fc" id="L576">        return mapObject(observable, mapper, (R) null);</span>
    }

    /**
     * Creates an object binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable   the source observable.
     * @param mapper       a non-interfering, stateless function to apply to the reduced value.
     * @param defaultValue the value to be returned if there is no value present, may be null.
     *
     * @return an object binding.
     */
    @Nonnull
    public static &lt;T, R&gt; ObjectBinding&lt;R&gt; mapObject(@Nonnull final ObservableValue&lt;T&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;? super T, ? extends R&gt;&gt; mapper, @Nullable final R defaultValue) {
<span class="fc" id="L590">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="fc" id="L591">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L592">        return createObjectBinding(() -&gt; {</span>
<span class="fc" id="L593">            T sourceValue = observable.getValue();</span>
<span class="fc" id="L594">            Function&lt;? super T, ? extends R&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L595">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="pc bpc" id="L596" title="1 of 2 branches missed.">            return sourceValue == null ? defaultValue : mapperValue.apply(sourceValue);</span>
        }, observable, mapper);
    }

    /**
     * Creates an object binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     * @param supplier   a {@code Supplier} whose result is returned if no value is present.
     *
     * @return an object binding.
     */
    @Nonnull
    public static &lt;T, R&gt; ObjectBinding&lt;R&gt; mapObject(@Nonnull final ObservableValue&lt;T&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;? super T, ? extends R&gt;&gt; mapper, @Nonnull final Supplier&lt;R&gt; supplier) {
<span class="nc" id="L611">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L612">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L613">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="nc" id="L614">        return createObjectBinding(() -&gt; {</span>
<span class="nc" id="L615">            T sourceValue = observable.getValue();</span>
<span class="nc" id="L616">            Function&lt;? super T, ? extends R&gt; mapperValue = mapper.getValue();</span>
<span class="nc" id="L617">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">            return sourceValue == null ? supplier.get() : mapperValue.apply(sourceValue);</span>
        }, observable, mapper);
    }

    /**
     * Creates a boolean binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     *
     * @return a boolean binding.
     */
    @Nonnull
    public static BooleanBinding mapBoolean(@Nonnull final ObservableValue&lt;Boolean&gt; observable, @Nonnull final Function&lt;Boolean, Boolean&gt; mapper) {
<span class="fc" id="L632">        return mapBoolean(observable, mapper, false);</span>
    }

    /**
     * Creates a boolean binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable   the source observable.
     * @param mapper       a non-interfering, stateless function to apply to the reduced value.
     * @param defaultValue the value to be returned if there is no value present, may be null.
     *
     * @return a boolean binding.
     */
    @Nonnull
    public static BooleanBinding mapBoolean(@Nonnull final ObservableValue&lt;Boolean&gt; observable, @Nonnull final Function&lt;Boolean, Boolean&gt; mapper, @Nonnull final Boolean defaultValue) {
<span class="fc" id="L646">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="fc" id="L647">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L648">        return createBooleanBinding(() -&gt; {</span>
<span class="fc" id="L649">            Boolean sourceValue = observable.getValue();</span>
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">            return sourceValue == null ? defaultValue : mapper.apply(sourceValue);</span>
        }, observable);
    }

    /**
     * Creates a boolean binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     * @param supplier   a {@code Supplier} whose result is returned if no value is present.
     *
     * @return a boolean binding.
     */
    @Nonnull
    public static BooleanBinding mapBoolean(@Nonnull final ObservableValue&lt;Boolean&gt; observable, @Nonnull final Function&lt;Boolean, Boolean&gt; mapper, @Nonnull final Supplier&lt;Boolean&gt; supplier) {
<span class="nc" id="L665">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L666">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L667">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="nc" id="L668">        return createBooleanBinding(() -&gt; {</span>
<span class="nc" id="L669">            Boolean sourceValue = observable.getValue();</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">            return sourceValue == null ? supplier.get() : mapper.apply(sourceValue);</span>
        }, observable);
    }

    /**
     * Creates a boolean binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     *
     * @return a boolean binding.
     */
    @Nonnull
    public static BooleanBinding mapBoolean(@Nonnull final ObservableValue&lt;Boolean&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;Boolean, Boolean&gt;&gt; mapper) {
<span class="fc" id="L684">        return mapBoolean(observable, mapper, false);</span>
    }

    /**
     * Creates a boolean binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable   the source observable.
     * @param mapper       a non-interfering, stateless function to apply to the reduced value.
     * @param defaultValue the value to be returned if there is no value present, may be null.
     *
     * @return a boolean binding.
     */
    @Nonnull
    public static BooleanBinding mapBoolean(@Nonnull final ObservableValue&lt;Boolean&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;Boolean, Boolean&gt;&gt; mapper, @Nonnull final Boolean defaultValue) {
<span class="fc" id="L698">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="fc" id="L699">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L700">        return createBooleanBinding(() -&gt; {</span>
<span class="fc" id="L701">            Boolean sourceValue = observable.getValue();</span>
<span class="fc" id="L702">            Function&lt;Boolean, Boolean&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L703">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="pc bpc" id="L704" title="1 of 2 branches missed.">            return sourceValue == null ? defaultValue : mapperValue.apply(sourceValue);</span>
        }, observable, mapper);
    }

    /**
     * Creates a boolean binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     * @param supplier   a {@code Supplier} whose result is returned if no value is present.
     *
     * @return a boolean binding.
     */
    @Nonnull
    public static BooleanBinding mapBoolean(@Nonnull final ObservableValue&lt;Boolean&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;Boolean, Boolean&gt;&gt; mapper, @Nonnull final Supplier&lt;Boolean&gt; supplier) {
<span class="nc" id="L719">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L720">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L721">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="nc" id="L722">        return createBooleanBinding(() -&gt; {</span>
<span class="nc" id="L723">            Boolean sourceValue = observable.getValue();</span>
<span class="nc" id="L724">            Function&lt;Boolean, Boolean&gt; mapperValue = mapper.getValue();</span>
<span class="nc" id="L725">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">            return sourceValue == null ? supplier.get() : mapperValue.apply(sourceValue);</span>
        }, observable, mapper);
    }

    /**
     * Creates an integer binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     *
     * @return an integer binding.
     */
    @Nonnull
    public static IntegerBinding mapInteger(@Nonnull final ObservableValue&lt;Integer&gt; observable, @Nonnull final Function&lt;Integer, Integer&gt; mapper) {
<span class="fc" id="L740">        return mapInteger(observable, mapper, 0);</span>
    }

    /**
     * Creates an integer binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable   the source observable.
     * @param mapper       a non-interfering, stateless function to apply to the reduced value.
     * @param defaultValue the value to be returned if there is no value present, may be null.
     *
     * @return an integer binding.
     */
    @Nonnull
    public static IntegerBinding mapInteger(@Nonnull final ObservableValue&lt;Integer&gt; observable, @Nonnull final Function&lt;Integer, Integer&gt; mapper, @Nonnull final Integer defaultValue) {
<span class="fc" id="L754">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="fc" id="L755">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L756">        return createIntegerBinding(() -&gt; {</span>
<span class="fc" id="L757">            Integer sourceValue = observable.getValue();</span>
<span class="pc bpc" id="L758" title="1 of 2 branches missed.">            return sourceValue == null ? defaultValue : mapper.apply(sourceValue);</span>
        }, observable);
    }


    /**
     * Creates an integer binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     * @param supplier   a {@code Supplier} whose result is returned if no value is present.
     *
     * @return an integer binding.
     */
    @Nonnull
    public static IntegerBinding mapInteger(@Nonnull final ObservableValue&lt;Integer&gt; observable, @Nonnull final Function&lt;Integer, Integer&gt; mapper, @Nonnull final Supplier&lt;Integer&gt; supplier) {
<span class="nc" id="L774">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L775">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L776">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="nc" id="L777">        return createIntegerBinding(() -&gt; {</span>
<span class="nc" id="L778">            Integer sourceValue = observable.getValue();</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">            return sourceValue == null ? supplier.get() : mapper.apply(sourceValue);</span>
        }, observable);
    }

    /**
     * Creates an integer binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     *
     * @return an integer binding.
     */
    @Nonnull
    public static IntegerBinding mapInteger(@Nonnull final ObservableValue&lt;Integer&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;Integer, Integer&gt;&gt; mapper) {
<span class="fc" id="L793">        return mapInteger(observable, mapper, 0);</span>
    }

    /**
     * Creates an integer binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable   the source observable.
     * @param mapper       a non-interfering, stateless function to apply to the reduced value.
     * @param defaultValue the value to be returned if there is no value present, may be null.
     *
     * @return an integer binding.
     */
    @Nonnull
    public static IntegerBinding mapInteger(@Nonnull final ObservableValue&lt;Integer&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;Integer, Integer&gt;&gt; mapper, @Nonnull final Integer defaultValue) {
<span class="fc" id="L807">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="fc" id="L808">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L809">        return createIntegerBinding(() -&gt; {</span>
<span class="fc" id="L810">            Integer sourceValue = observable.getValue();</span>
<span class="fc" id="L811">            Function&lt;Integer, Integer&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L812">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="pc bpc" id="L813" title="1 of 2 branches missed.">            return sourceValue == null ? defaultValue : mapperValue.apply(sourceValue);</span>
        }, observable, mapper);
    }

    /**
     * Creates an integer binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     * @param supplier   a {@code Supplier} whose result is returned if no value is present.
     *
     * @return an integer binding.
     */
    @Nonnull
    public static IntegerBinding mapInteger(@Nonnull final ObservableValue&lt;Integer&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;Integer, Integer&gt;&gt; mapper, @Nonnull final Supplier&lt;Integer&gt; supplier) {
<span class="nc" id="L828">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L829">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L830">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="nc" id="L831">        return createIntegerBinding(() -&gt; {</span>
<span class="nc" id="L832">            Integer sourceValue = observable.getValue();</span>
<span class="nc" id="L833">            Function&lt;Integer, Integer&gt; mapperValue = mapper.getValue();</span>
<span class="nc" id="L834">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">            return sourceValue == null ? supplier.get() : mapperValue.apply(sourceValue);</span>
        }, observable, mapper);
    }

    /**
     * Creates a long binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     *
     * @return a long binding.
     */
    @Nonnull
    public static LongBinding mapLong(@Nonnull final ObservableValue&lt;Long&gt; observable, @Nonnull final Function&lt;Long, Long&gt; mapper) {
<span class="fc" id="L849">        return mapLong(observable, mapper, 0L);</span>
    }

    /**
     * Creates a long binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable   the source observable.
     * @param mapper       a non-interfering, stateless function to apply to the reduced value.
     * @param defaultValue the value to be returned if there is no value present, may be null.
     *
     * @return a long binding.
     */
    @Nonnull
    public static LongBinding mapLong(@Nonnull final ObservableValue&lt;Long&gt; observable, @Nonnull final Function&lt;Long, Long&gt; mapper, @Nonnull final Long defaultValue) {
<span class="fc" id="L863">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="fc" id="L864">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L865">        return createLongBinding(() -&gt; {</span>
<span class="fc" id="L866">            Long sourceValue = observable.getValue();</span>
<span class="pc bpc" id="L867" title="1 of 2 branches missed.">            return sourceValue == null ? defaultValue : mapper.apply(sourceValue);</span>
        }, observable);
    }


    /**
     * Creates a long binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     * @param supplier   a {@code Supplier} whose result is returned if no value is present.
     *
     * @return a long binding.
     */
    @Nonnull
    public static LongBinding mapLong(@Nonnull final ObservableValue&lt;Long&gt; observable, @Nonnull final Function&lt;Long, Long&gt; mapper, @Nonnull final Supplier&lt;Long&gt; supplier) {
<span class="nc" id="L883">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L884">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L885">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="nc" id="L886">        return createLongBinding(() -&gt; {</span>
<span class="nc" id="L887">            Long sourceValue = observable.getValue();</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">            return sourceValue == null ? supplier.get() : mapper.apply(sourceValue);</span>
        }, observable);
    }

    /**
     * Creates a long binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     *
     * @return a long binding.
     */
    @Nonnull
    public static LongBinding mapLong(@Nonnull final ObservableValue&lt;Long&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;Long, Long&gt;&gt; mapper) {
<span class="fc" id="L902">        return mapLong(observable, mapper, 0L);</span>
    }

    /**
     * Creates a long binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable   the source observable.
     * @param mapper       a non-interfering, stateless function to apply to the reduced value.
     * @param defaultValue the value to be returned if there is no value present, may be null.
     *
     * @return a long binding.
     */
    @Nonnull
    public static LongBinding mapLong(@Nonnull final ObservableValue&lt;Long&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;Long, Long&gt;&gt; mapper, @Nonnull final Long defaultValue) {
<span class="fc" id="L916">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="fc" id="L917">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L918">        return createLongBinding(() -&gt; {</span>
<span class="fc" id="L919">            Long sourceValue = observable.getValue();</span>
<span class="fc" id="L920">            Function&lt;Long, Long&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L921">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="pc bpc" id="L922" title="1 of 2 branches missed.">            return sourceValue == null ? defaultValue : mapperValue.apply(sourceValue);</span>
        }, observable, mapper);
    }

    /**
     * Creates a long binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     * @param supplier   a {@code Supplier} whose result is returned if no value is present.
     *
     * @return a long binding.
     */
    @Nonnull
    public static LongBinding mapLong(@Nonnull final ObservableValue&lt;Long&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;Long, Long&gt;&gt; mapper, @Nonnull final Supplier&lt;Long&gt; supplier) {
<span class="nc" id="L937">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L938">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L939">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="nc" id="L940">        return createLongBinding(() -&gt; {</span>
<span class="nc" id="L941">            Long sourceValue = observable.getValue();</span>
<span class="nc" id="L942">            Function&lt;Long, Long&gt; mapperValue = mapper.getValue();</span>
<span class="nc" id="L943">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="nc bnc" id="L944" title="All 2 branches missed.">            return sourceValue == null ? supplier.get() : mapperValue.apply(sourceValue);</span>
        }, observable, mapper);
    }

    /**
     * Creates a float binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     *
     * @return a float binding.
     */
    @Nonnull
    public static FloatBinding mapFloat(@Nonnull final ObservableValue&lt;Float&gt; observable, @Nonnull final Function&lt;Float, Float&gt; mapper) {
<span class="fc" id="L958">        return mapFloat(observable, mapper, 0f);</span>
    }

    /**
     * Creates a float binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable   the source observable.
     * @param mapper       a non-interfering, stateless function to apply to the reduced value.
     * @param defaultValue the value to be returned if there is no value present, may be null.
     *
     * @return a float binding.
     */
    @Nonnull
    public static FloatBinding mapFloat(@Nonnull final ObservableValue&lt;Float&gt; observable, @Nonnull final Function&lt;Float, Float&gt; mapper, @Nonnull final Float defaultValue) {
<span class="fc" id="L972">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="fc" id="L973">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L974">        return createFloatBinding(() -&gt; {</span>
<span class="fc" id="L975">            Float sourceValue = observable.getValue();</span>
<span class="pc bpc" id="L976" title="1 of 2 branches missed.">            return sourceValue == null ? defaultValue : mapper.apply(sourceValue);</span>
        }, observable);
    }

    /**
     * Creates a float binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     * @param supplier   a {@code Supplier} whose result is returned if no value is present.
     *
     * @return a float binding.
     */
    @Nonnull
    public static FloatBinding mapFloat(@Nonnull final ObservableValue&lt;Float&gt; observable, @Nonnull final Function&lt;Float, Float&gt; mapper, @Nonnull final Supplier&lt;Float&gt; supplier) {
<span class="nc" id="L991">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L992">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L993">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="nc" id="L994">        return createFloatBinding(() -&gt; {</span>
<span class="nc" id="L995">            Float sourceValue = observable.getValue();</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">            return sourceValue == null ? supplier.get() : mapper.apply(sourceValue);</span>
        }, observable);
    }

    /**
     * Creates a float binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     *
     * @return a float binding.
     */
    @Nonnull
    public static FloatBinding mapFloat(@Nonnull final ObservableValue&lt;Float&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;Float, Float&gt;&gt; mapper) {
<span class="fc" id="L1010">        return mapFloat(observable, mapper, 0f);</span>
    }

    /**
     * Creates a float binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable   the source observable.
     * @param mapper       a non-interfering, stateless function to apply to the reduced value.
     * @param defaultValue the value to be returned if there is no value present, may be null.
     *
     * @return a float binding.
     */
    @Nonnull
    public static FloatBinding mapFloat(@Nonnull final ObservableValue&lt;Float&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;Float, Float&gt;&gt; mapper, @Nullable final Float defaultValue) {
<span class="fc" id="L1024">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="fc" id="L1025">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1026">        return createFloatBinding(() -&gt; {</span>
<span class="fc" id="L1027">            Float sourceValue = observable.getValue();</span>
<span class="fc" id="L1028">            Function&lt;Float, Float&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L1029">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="pc bpc" id="L1030" title="1 of 2 branches missed.">            return sourceValue == null ? defaultValue : mapperValue.apply(sourceValue);</span>
        }, observable, mapper);
    }

    /**
     * Creates a float binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     * @param supplier   a {@code Supplier} whose result is returned if no value is present.
     *
     * @return a float binding.
     */
    @Nonnull
    public static FloatBinding mapFloat(@Nonnull final ObservableValue&lt;Float&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;Float, Float&gt;&gt; mapper, @Nonnull final Supplier&lt;Float&gt; supplier) {
<span class="nc" id="L1045">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L1046">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L1047">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="nc" id="L1048">        return createFloatBinding(() -&gt; {</span>
<span class="nc" id="L1049">            Float sourceValue = observable.getValue();</span>
<span class="nc" id="L1050">            Function&lt;Float, Float&gt; mapperValue = mapper.getValue();</span>
<span class="nc" id="L1051">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="nc bnc" id="L1052" title="All 2 branches missed.">            return sourceValue == null ? supplier.get() : mapperValue.apply(sourceValue);</span>
        }, observable, mapper);
    }

    /**
     * Creates a double binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     *
     * @return a double binding.
     */
    @Nonnull
    public static DoubleBinding mapDouble(@Nonnull final ObservableValue&lt;Double&gt; observable, @Nonnull final Function&lt;Double, Double&gt; mapper) {
<span class="fc" id="L1066">        return mapDouble(observable, mapper, 0d);</span>
    }

    /**
     * Creates a double binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable   the source observable.
     * @param mapper       a non-interfering, stateless function to apply to the reduced value.
     * @param defaultValue the value to be returned if there is no value present, may be null.
     *
     * @return a double binding.
     */
    @Nonnull
    public static DoubleBinding mapDouble(@Nonnull final ObservableValue&lt;Double&gt; observable, @Nonnull final Function&lt;Double, Double&gt; mapper, @Nullable final Double defaultValue) {
<span class="fc" id="L1080">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="fc" id="L1081">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1082">        return createDoubleBinding(() -&gt; {</span>
<span class="fc" id="L1083">            Double sourceValue = observable.getValue();</span>
<span class="pc bpc" id="L1084" title="1 of 2 branches missed.">            return sourceValue == null ? defaultValue : mapper.apply(sourceValue);</span>
        }, observable);
    }

    /**
     * Creates a double binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     * @param supplier   a {@code Supplier} whose result is returned if no value is present.
     *
     * @return a double binding.
     */
    @Nonnull
    public static DoubleBinding mapDouble(@Nonnull final ObservableValue&lt;Double&gt; observable, @Nonnull final Function&lt;Double, Double&gt; mapper, @Nonnull final Supplier&lt;Double&gt; supplier) {
<span class="nc" id="L1099">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L1100">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L1101">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="nc" id="L1102">        return createDoubleBinding(() -&gt; {</span>
<span class="nc" id="L1103">            Double sourceValue = observable.getValue();</span>
<span class="nc bnc" id="L1104" title="All 2 branches missed.">            return sourceValue == null ? supplier.get() : mapper.apply(sourceValue);</span>
        }, observable);
    }

    /**
     * Creates a double binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     *
     * @return a double binding.
     */
    @Nonnull
    public static DoubleBinding mapDouble(@Nonnull final ObservableValue&lt;Double&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;Double, Double&gt;&gt; mapper) {
<span class="fc" id="L1118">        return mapDouble(observable, mapper, 0d);</span>
    }

    /**
     * Creates a double binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable   the source observable.
     * @param mapper       a non-interfering, stateless function to apply to the reduced value.
     * @param defaultValue the value to be returned if there is no value present, may be null.
     *
     * @return a double binding.
     */
    @Nonnull
    public static DoubleBinding mapDouble(@Nonnull final ObservableValue&lt;Double&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;Double, Double&gt;&gt; mapper, @Nonnull final Double defaultValue) {
<span class="fc" id="L1132">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="fc" id="L1133">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1134">        return createDoubleBinding(() -&gt; {</span>
<span class="fc" id="L1135">            Double sourceValue = observable.getValue();</span>
<span class="fc" id="L1136">            Function&lt;Double, Double&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L1137">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="pc bpc" id="L1138" title="1 of 2 branches missed.">            return sourceValue == null ? defaultValue : mapperValue.apply(sourceValue);</span>
        }, observable, mapper);
    }

    /**
     * Creates a double binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     * @param supplier   a {@code Supplier} whose result is returned if no value is present.
     *
     * @return a double binding.
     */
    @Nonnull
    public static DoubleBinding mapDouble(@Nonnull final ObservableValue&lt;Double&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;Double, Double&gt;&gt; mapper, @Nonnull final Supplier&lt;Double&gt; supplier) {
<span class="nc" id="L1153">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L1154">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L1155">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="nc" id="L1156">        return createDoubleBinding(() -&gt; {</span>
<span class="nc" id="L1157">            Double sourceValue = observable.getValue();</span>
<span class="nc" id="L1158">            Function&lt;Double, Double&gt; mapperValue = mapper.getValue();</span>
<span class="nc" id="L1159">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="nc bnc" id="L1160" title="All 2 branches missed.">            return sourceValue == null ? supplier.get() : mapperValue.apply(sourceValue);</span>
        }, observable, mapper);
    }

    /**
     * Creates a string binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     *
     * @return a string binding.
     */
    @Nonnull
    public static StringBinding mapString(@Nonnull final ObservableValue&lt;String&gt; observable, @Nonnull final Function&lt;String, String&gt; mapper) {
<span class="fc" id="L1174">        return mapString(observable, mapper, &quot;&quot;);</span>
    }

    /**
     * Creates a string binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable   the source observable.
     * @param mapper       a non-interfering, stateless function to apply to the reduced value.
     * @param defaultValue the value to be returned if there is no value present, may be null.
     *
     * @return a string binding.
     */
    @Nonnull
    public static StringBinding mapString(@Nonnull final ObservableValue&lt;String&gt; observable, @Nonnull final Function&lt;String, String&gt; mapper, @Nonnull final String defaultValue) {
<span class="fc" id="L1188">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="fc" id="L1189">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1190">        return createStringBinding(() -&gt; {</span>
<span class="fc" id="L1191">            String sourceValue = observable.getValue();</span>
<span class="pc bpc" id="L1192" title="1 of 2 branches missed.">            return sourceValue == null ? defaultValue : mapper.apply(sourceValue);</span>
        }, observable);
    }

    /**
     * Creates a string binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     * @param supplier   a {@code Supplier} whose result is returned if no value is present.
     *
     * @return a string binding.
     */
    @Nonnull
    public static StringBinding mapString(@Nonnull final ObservableValue&lt;String&gt; observable, @Nonnull final Function&lt;String, String&gt; mapper, @Nonnull final Supplier&lt;String&gt; supplier) {
<span class="nc" id="L1207">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L1208">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L1209">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="nc" id="L1210">        return createStringBinding(() -&gt; {</span>
<span class="nc" id="L1211">            String sourceValue = observable.getValue();</span>
<span class="nc bnc" id="L1212" title="All 2 branches missed.">            return sourceValue == null ? supplier.get() : mapper.apply(sourceValue);</span>
        }, observable);
    }

    /**
     * Creates a string binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     *
     * @return a string binding.
     */
    @Nonnull
    public static StringBinding mapString(@Nonnull final ObservableValue&lt;String&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;String, String&gt;&gt; mapper) {
<span class="fc" id="L1226">        return mapString(observable, mapper, &quot;&quot;);</span>
    }

    /**
     * Creates a string binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable   the source observable.
     * @param mapper       a non-interfering, stateless function to apply to the reduced value.
     * @param defaultValue the value to be returned if there is no value present, may be null.
     *
     * @return a string binding.
     */
    @Nonnull
    public static StringBinding mapString(@Nonnull final ObservableValue&lt;String&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;String, String&gt;&gt; mapper, @Nonnull final String defaultValue) {
<span class="fc" id="L1240">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="fc" id="L1241">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1242">        return createStringBinding(() -&gt; {</span>
<span class="fc" id="L1243">            String sourceValue = observable.getValue();</span>
<span class="fc" id="L1244">            Function&lt;String, String&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L1245">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="pc bpc" id="L1246" title="1 of 2 branches missed.">            return sourceValue == null ? defaultValue : mapperValue.apply(sourceValue);</span>
        }, observable, mapper);
    }

    /**
     * Creates a string binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param mapper     a non-interfering, stateless function to apply to the reduced value.
     * @param supplier   a {@code Supplier} whose result is returned if no value is present.
     *
     * @return a string binding.
     */
    @Nonnull
    public static StringBinding mapString(@Nonnull final ObservableValue&lt;String&gt; observable, @Nonnull final ObservableValue&lt;Function&lt;String, String&gt;&gt; mapper, @Nonnull final Supplier&lt;String&gt; supplier) {
<span class="nc" id="L1261">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L1262">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="nc" id="L1263">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="nc" id="L1264">        return createStringBinding(() -&gt; {</span>
<span class="nc" id="L1265">            String sourceValue = observable.getValue();</span>
<span class="nc" id="L1266">            Function&lt;String, String&gt; mapperValue = mapper.getValue();</span>
<span class="nc" id="L1267">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="nc bnc" id="L1268" title="All 2 branches missed.">            return sourceValue == null ? supplier.get() : mapperValue.apply(sourceValue);</span>
        }, observable, mapper);
    }

    /**
     * Returns a boolean binding whose value is the combination of two observable values.
     *
     * @param observable1  the first observable value.
     * @param observable2  the second observable value.
     * @param defaultValue the value to be returned if there are no values present.
     * @param mapper       a non-interfering, stateless function to apply to the supplied values.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static BooleanBinding mapBooleans(@Nonnull final ObservableValue&lt;Boolean&gt; observable1, @Nonnull final ObservableValue&lt;Boolean&gt; observable2, @Nonnull final Boolean defaultValue, @Nonnull final BiFunction&lt;Boolean, Boolean, Boolean&gt; mapper) {
<span class="fc" id="L1284">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1285">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1286">        requireNonNull(defaultValue, ERROR_DEFAULT_VALUE_NULL);</span>
<span class="fc" id="L1287">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1288">        return createBooleanBinding(() -&gt; {</span>
<span class="fc" id="L1289">            Boolean value1 = observable1.getValue();</span>
<span class="fc" id="L1290">            Boolean value2 = observable2.getValue();</span>
<span class="pc bpc" id="L1291" title="2 of 4 branches missed.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L1292">                return mapper.apply(value1, value2);</span>
            }
<span class="nc" id="L1294">            return defaultValue;</span>
        }, observable1, observable2);
    }

    /**
     * Returns a boolean binding whose value is the combination of two observable values.
     *
     * @param observable1 the first observable value.
     * @param observable2 the second observable value.
     * @param supplier    a {@code Supplier} whose result is returned if no values are present.
     * @param mapper      a non-interfering, stateless function to apply to the supplied values.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static BooleanBinding mapBooleans(@Nonnull final ObservableValue&lt;Boolean&gt; observable1, @Nonnull final ObservableValue&lt;Boolean&gt; observable2, @Nonnull final Supplier&lt;Boolean&gt; supplier, @Nonnull final BiFunction&lt;Boolean, Boolean, Boolean&gt; mapper) {
<span class="fc" id="L1310">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1311">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1312">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1313">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1314">        return createBooleanBinding(() -&gt; {</span>
<span class="fc" id="L1315">            Boolean value1 = observable1.getValue();</span>
<span class="fc" id="L1316">            Boolean value2 = observable2.getValue();</span>
<span class="pc bpc" id="L1317" title="2 of 4 branches missed.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L1318">                return mapper.apply(value1, value2);</span>
            }
<span class="nc" id="L1320">            return requireNonNull(supplier.get(), ERROR_DEFAULT_VALUE_NULL);</span>
        }, observable1, observable2);
    }

    /**
     * Returns a boolean binding whose value is the combination of two observable values.
     *
     * @param observable1  the first observable value.
     * @param observable2  the second observable value.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the supplied values.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static BooleanBinding mapBooleans(@Nonnull final ObservableValue&lt;Boolean&gt; observable1, @Nonnull final ObservableValue&lt;Boolean&gt; observable2, @Nonnull final Boolean defaultValue, @Nonnull final ObservableValue&lt;BiFunction&lt;Boolean, Boolean, Boolean&gt;&gt; mapper) {
<span class="fc" id="L1336">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1337">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1338">        requireNonNull(defaultValue, ERROR_DEFAULT_VALUE_NULL);</span>
<span class="fc" id="L1339">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1340">        return createBooleanBinding(() -&gt; {</span>
<span class="fc" id="L1341">            Boolean value1 = observable1.getValue();</span>
<span class="fc" id="L1342">            Boolean value2 = observable2.getValue();</span>
<span class="pc bpc" id="L1343" title="2 of 4 branches missed.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L1344">                BiFunction&lt;Boolean, Boolean, Boolean&gt; function = mapper.getValue();</span>
<span class="fc" id="L1345">                return requireNonNull(function, ERROR_MAPPER_NULL).apply(value1, value2);</span>
            }
<span class="nc" id="L1347">            return defaultValue;</span>
        }, observable1, observable2, mapper);
    }

    /**
     * Returns a boolean binding whose value is the combination of two observable values.
     *
     * @param observable1 the first observable value.
     * @param observable2 the second observable value.
     * @param supplier    a {@code Supplier} whose result is returned if no value is present.
     * @param mapper      a non-interfering, stateless function to apply to the supplied values.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static BooleanBinding mapBooleans(@Nonnull final ObservableValue&lt;Boolean&gt; observable1, @Nonnull final ObservableValue&lt;Boolean&gt; observable2, @Nonnull final Supplier&lt;Boolean&gt; supplier, @Nonnull final ObservableValue&lt;BiFunction&lt;Boolean, Boolean, Boolean&gt;&gt; mapper) {
<span class="fc" id="L1363">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1364">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1365">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1366">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1367">        return createBooleanBinding(() -&gt; {</span>
<span class="fc" id="L1368">            Boolean value1 = observable1.getValue();</span>
<span class="fc" id="L1369">            Boolean value2 = observable2.getValue();</span>
<span class="pc bpc" id="L1370" title="2 of 4 branches missed.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L1371">                BiFunction&lt;Boolean, Boolean, Boolean&gt; function = mapper.getValue();</span>
<span class="fc" id="L1372">                return requireNonNull(function, ERROR_MAPPER_NULL).apply(value1, value2);</span>
            }
<span class="nc" id="L1374">            return requireNonNull(supplier.get(), ERROR_DEFAULT_VALUE_NULL);</span>
        }, observable1, observable2, mapper);
    }

    /**
     * Returns an integer binding whose value is the combination of two observable values.
     *
     * @param observable1  the first observable value.
     * @param observable2  the second observable value.
     * @param defaultValue the value to be returned if there are no values present.
     * @param mapper       a non-interfering, stateless function to apply to the supplied values.
     *
     * @return an integer binding
     */
    @Nonnull
    public static IntegerBinding mapIntegers(@Nonnull final ObservableValue&lt;? extends Number&gt; observable1, @Nonnull final ObservableValue&lt;? extends Number&gt; observable2, @Nonnull final Integer defaultValue, @Nonnull final BiFunction&lt;? super Number, ? super Number, Integer&gt; mapper) {
<span class="fc" id="L1390">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1391">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1392">        requireNonNull(defaultValue, ERROR_DEFAULT_VALUE_NULL);</span>
<span class="fc" id="L1393">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1394">        return createIntegerBinding(() -&gt; {</span>
<span class="fc" id="L1395">            Number value1 = observable1.getValue();</span>
<span class="fc" id="L1396">            Number value2 = observable2.getValue();</span>
<span class="pc bpc" id="L1397" title="2 of 4 branches missed.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L1398">                return mapper.apply(value1, value2);</span>
            }
<span class="nc" id="L1400">            return defaultValue;</span>
        }, observable1, observable2);
    }

    /**
     * Returns an integer binding whose value is the combination of two observable values.
     *
     * @param observable1 the first observable value.
     * @param observable2 the second observable value.
     * @param supplier    a {@code Supplier} whose result is returned if no values are present.
     * @param mapper      a non-interfering, stateless function to apply to the supplied values.
     *
     * @return an integer binding
     */
    @Nonnull
    public static IntegerBinding mapIntegers(@Nonnull final ObservableValue&lt;? extends Number&gt; observable1, @Nonnull final ObservableValue&lt;? extends Number&gt; observable2, @Nonnull final Supplier&lt;Integer&gt; supplier, @Nonnull final BiFunction&lt;? super Number, ? super Number, Integer&gt; mapper) {
<span class="fc" id="L1416">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1417">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1418">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1419">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1420">        return createIntegerBinding(() -&gt; {</span>
<span class="fc" id="L1421">            Number value1 = observable1.getValue();</span>
<span class="fc" id="L1422">            Number value2 = observable2.getValue();</span>
<span class="pc bpc" id="L1423" title="2 of 4 branches missed.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L1424">                return mapper.apply(value1, value2);</span>
            }
<span class="nc" id="L1426">            return requireNonNull(supplier.get(), ERROR_DEFAULT_VALUE_NULL);</span>
        }, observable1, observable2);
    }

    /**
     * Returns an integer binding whose value is the combination of two observable values.
     *
     * @param observable1  the first observable value.
     * @param observable2  the second observable value.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the supplied values.
     *
     * @return an integer binding
     */
    @Nonnull
    public static IntegerBinding mapIntegers(@Nonnull final ObservableValue&lt;? extends Number&gt; observable1, @Nonnull final ObservableValue&lt;? extends Number&gt; observable2, @Nonnull final Integer defaultValue, @Nonnull final ObservableValue&lt;BiFunction&lt;? super Number, ? super Number, Integer&gt;&gt; mapper) {
<span class="fc" id="L1442">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1443">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1444">        requireNonNull(defaultValue, ERROR_DEFAULT_VALUE_NULL);</span>
<span class="fc" id="L1445">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1446">        return createIntegerBinding(() -&gt; {</span>
<span class="fc" id="L1447">            Number value1 = observable1.getValue();</span>
<span class="fc" id="L1448">            Number value2 = observable2.getValue();</span>
<span class="pc bpc" id="L1449" title="2 of 4 branches missed.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L1450">                BiFunction&lt;? super Number, ? super Number, Integer&gt; function = mapper.getValue();</span>
<span class="fc" id="L1451">                return requireNonNull(function, ERROR_MAPPER_NULL).apply(value1, value2);</span>
            }
<span class="nc" id="L1453">            return defaultValue;</span>
        }, observable1, observable2, mapper);
    }

    /**
     * Returns an integer binding whose value is the combination of two observable values.
     *
     * @param observable1 the first observable value.
     * @param observable2 the second observable value.
     * @param supplier    a {@code Supplier} whose result is returned if no value is present.
     * @param mapper      a non-interfering, stateless function to apply to the supplied values.
     *
     * @return an integer binding
     */
    @Nonnull
    public static IntegerBinding mapIntegers(@Nonnull final ObservableValue&lt;? extends Number&gt; observable1, @Nonnull final ObservableValue&lt;? extends Number&gt; observable2, @Nonnull final Supplier&lt;Integer&gt; supplier, @Nonnull final ObservableValue&lt;BiFunction&lt;? super Number, ? super Number, Integer&gt;&gt; mapper) {
<span class="fc" id="L1469">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1470">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1471">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1472">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1473">        return createIntegerBinding(() -&gt; {</span>
<span class="fc" id="L1474">            Number value1 = observable1.getValue();</span>
<span class="fc" id="L1475">            Number value2 = observable2.getValue();</span>
<span class="pc bpc" id="L1476" title="2 of 4 branches missed.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L1477">                BiFunction&lt;? super Number, ? super Number, Integer&gt; function = mapper.getValue();</span>
<span class="fc" id="L1478">                return requireNonNull(function, ERROR_MAPPER_NULL).apply(value1, value2);</span>
            }
<span class="nc" id="L1480">            return requireNonNull(supplier.get(), ERROR_DEFAULT_VALUE_NULL);</span>
        }, observable1, observable2, mapper);
    }

    /**
     * Returns a long binding whose value is the combination of two observable values.
     *
     * @param observable1  the first observable value.
     * @param observable2  the second observable value.
     * @param defaultValue the value to be returned if there are no values present.
     * @param mapper       a non-interfering, stateless function to apply to the supplied values.
     *
     * @return a long binding
     */
    @Nonnull
    public static LongBinding mapLongs(@Nonnull final ObservableValue&lt;? extends Number&gt; observable1, @Nonnull final ObservableValue&lt;? extends Number&gt; observable2, @Nonnull final Long defaultValue, @Nonnull final BiFunction&lt;? super Number, ? super Number, Long&gt; mapper) {
<span class="fc" id="L1496">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1497">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1498">        requireNonNull(defaultValue, ERROR_DEFAULT_VALUE_NULL);</span>
<span class="fc" id="L1499">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1500">        return createLongBinding(() -&gt; {</span>
<span class="fc" id="L1501">            Number value1 = observable1.getValue();</span>
<span class="fc" id="L1502">            Number value2 = observable2.getValue();</span>
<span class="pc bpc" id="L1503" title="2 of 4 branches missed.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L1504">                return mapper.apply(value1, value2);</span>
            }
<span class="nc" id="L1506">            return defaultValue;</span>
        }, observable1, observable2);
    }

    /**
     * Returns a long binding whose value is the combination of two observable values.
     *
     * @param observable1 the first observable value.
     * @param observable2 the second observable value.
     * @param supplier    a {@code Supplier} whose result is returned if no values are present.
     * @param mapper      a non-interfering, stateless function to apply to the supplied values.
     *
     * @return a long binding
     */
    @Nonnull
    public static LongBinding mapLongs(@Nonnull final ObservableValue&lt;? extends Number&gt; observable1, @Nonnull final ObservableValue&lt;? extends Number&gt; observable2, @Nonnull final Supplier&lt;Long&gt; supplier, @Nonnull final BiFunction&lt;? super Number, ? super Number, Long&gt; mapper) {
<span class="fc" id="L1522">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1523">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1524">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1525">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1526">        return createLongBinding(() -&gt; {</span>
<span class="fc" id="L1527">            Number value1 = observable1.getValue();</span>
<span class="fc" id="L1528">            Number value2 = observable2.getValue();</span>
<span class="pc bpc" id="L1529" title="2 of 4 branches missed.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L1530">                return mapper.apply(value1, value2);</span>
            }
<span class="nc" id="L1532">            return requireNonNull(supplier.get(), ERROR_DEFAULT_VALUE_NULL);</span>
        }, observable1, observable2);
    }

    /**
     * Returns a long binding whose value is the combination of two observable values.
     *
     * @param observable1  the first observable value.
     * @param observable2  the second observable value.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the supplied values.
     *
     * @return a long binding
     */
    @Nonnull
    public static LongBinding mapLongs(@Nonnull final ObservableValue&lt;? extends Number&gt; observable1, @Nonnull final ObservableValue&lt;? extends Number&gt; observable2, @Nonnull final Long defaultValue, @Nonnull final ObservableValue&lt;BiFunction&lt;? super Number, ? super Number, Long&gt;&gt; mapper) {
<span class="fc" id="L1548">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1549">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1550">        requireNonNull(defaultValue, ERROR_DEFAULT_VALUE_NULL);</span>
<span class="fc" id="L1551">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1552">        return createLongBinding(() -&gt; {</span>
<span class="fc" id="L1553">            Number value1 = observable1.getValue();</span>
<span class="fc" id="L1554">            Number value2 = observable2.getValue();</span>
<span class="pc bpc" id="L1555" title="2 of 4 branches missed.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L1556">                BiFunction&lt;? super Number, ? super Number, Long&gt; function = mapper.getValue();</span>
<span class="fc" id="L1557">                return requireNonNull(function, ERROR_MAPPER_NULL).apply(value1, value2);</span>
            }
<span class="nc" id="L1559">            return defaultValue;</span>
        }, observable1, observable2, mapper);
    }

    /**
     * Returns a long binding whose value is the combination of two observable values.
     *
     * @param observable1 the first observable value.
     * @param observable2 the second observable value.
     * @param supplier    a {@code Supplier} whose result is returned if no value is present.
     * @param mapper      a non-interfering, stateless function to apply to the supplied values.
     *
     * @return a long binding
     */
    @Nonnull
    public static LongBinding mapLongs(@Nonnull final ObservableValue&lt;? extends Number&gt; observable1, @Nonnull final ObservableValue&lt;? extends Number&gt; observable2, @Nonnull final Supplier&lt;Long&gt; supplier, @Nonnull final ObservableValue&lt;BiFunction&lt;? super Number, ? super Number, Long&gt;&gt; mapper) {
<span class="fc" id="L1575">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1576">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1577">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1578">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1579">        return createLongBinding(() -&gt; {</span>
<span class="fc" id="L1580">            Number value1 = observable1.getValue();</span>
<span class="fc" id="L1581">            Number value2 = observable2.getValue();</span>
<span class="pc bpc" id="L1582" title="2 of 4 branches missed.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L1583">                BiFunction&lt;? super Number, ? super Number, Long&gt; function = mapper.getValue();</span>
<span class="fc" id="L1584">                return requireNonNull(function, ERROR_MAPPER_NULL).apply(value1, value2);</span>
            }
<span class="nc" id="L1586">            return requireNonNull(supplier.get(), ERROR_DEFAULT_VALUE_NULL);</span>
        }, observable1, observable2, mapper);
    }

    /**
     * Returns a float binding whose value is the combination of two observable values.
     *
     * @param observable1  the first observable value.
     * @param observable2  the second observable value.
     * @param defaultValue the value to be returned if there are no values present.
     * @param mapper       a non-interfering, stateless function to apply to the supplied values.
     *
     * @return a float binding
     */
    @Nonnull
    public static FloatBinding mapFloats(@Nonnull final ObservableValue&lt;? extends Number&gt; observable1, @Nonnull final ObservableValue&lt;? extends Number&gt; observable2, @Nonnull final Float defaultValue, @Nonnull final BiFunction&lt;? super Number, ? super Number, Float&gt; mapper) {
<span class="fc" id="L1602">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1603">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1604">        requireNonNull(defaultValue, ERROR_DEFAULT_VALUE_NULL);</span>
<span class="fc" id="L1605">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1606">        return createFloatBinding(() -&gt; {</span>
<span class="fc" id="L1607">            Number value1 = observable1.getValue();</span>
<span class="fc" id="L1608">            Number value2 = observable2.getValue();</span>
<span class="pc bpc" id="L1609" title="2 of 4 branches missed.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L1610">                return mapper.apply(value1, value2);</span>
            }
<span class="nc" id="L1612">            return defaultValue;</span>
        }, observable1, observable2);
    }

    /**
     * Returns a float binding whose value is the combination of two observable values.
     *
     * @param observable1 the first observable value.
     * @param observable2 the second observable value.
     * @param supplier    a {@code Supplier} whose result is returned if no values are present.
     * @param mapper      a non-interfering, stateless function to apply to the supplied values.
     *
     * @return a float binding
     */
    @Nonnull
    public static FloatBinding mapFloats(@Nonnull final ObservableValue&lt;? extends Number&gt; observable1, @Nonnull final ObservableValue&lt;? extends Number&gt; observable2, @Nonnull final Supplier&lt;Float&gt; supplier, @Nonnull final BiFunction&lt;? super Number, ? super Number, Float&gt; mapper) {
<span class="fc" id="L1628">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1629">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1630">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1631">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1632">        return createFloatBinding(() -&gt; {</span>
<span class="fc" id="L1633">            Number value1 = observable1.getValue();</span>
<span class="fc" id="L1634">            Number value2 = observable2.getValue();</span>
<span class="pc bpc" id="L1635" title="2 of 4 branches missed.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L1636">                return mapper.apply(value1, value2);</span>
            }
<span class="nc" id="L1638">            return requireNonNull(supplier.get(), ERROR_DEFAULT_VALUE_NULL);</span>
        }, observable1, observable2);
    }

    /**
     * Returns a float binding whose value is the combination of two observable values.
     *
     * @param observable1  the first observable value.
     * @param observable2  the second observable value.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the supplied values.
     *
     * @return a float binding
     */
    @Nonnull
    public static FloatBinding mapFloats(@Nonnull final ObservableValue&lt;? extends Number&gt; observable1, @Nonnull final ObservableValue&lt;? extends Number&gt; observable2, @Nonnull final Float defaultValue, @Nonnull final ObservableValue&lt;BiFunction&lt;? super Number, ? super Number, Float&gt;&gt; mapper) {
<span class="fc" id="L1654">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1655">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1656">        requireNonNull(defaultValue, ERROR_DEFAULT_VALUE_NULL);</span>
<span class="fc" id="L1657">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1658">        return createFloatBinding(() -&gt; {</span>
<span class="fc" id="L1659">            Number value1 = observable1.getValue();</span>
<span class="fc" id="L1660">            Number value2 = observable2.getValue();</span>
<span class="pc bpc" id="L1661" title="2 of 4 branches missed.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L1662">                BiFunction&lt;? super Number, ? super Number, Float&gt; function = mapper.getValue();</span>
<span class="fc" id="L1663">                return requireNonNull(function, ERROR_MAPPER_NULL).apply(value1, value2);</span>
            }
<span class="nc" id="L1665">            return defaultValue;</span>
        }, observable1, observable2, mapper);
    }

    /**
     * Returns a float binding whose value is the combination of two observable values.
     *
     * @param observable1 the first observable value.
     * @param observable2 the second observable value.
     * @param supplier    a {@code Supplier} whose result is returned if no value is present.
     * @param mapper      a non-interfering, stateless function to apply to the supplied values.
     *
     * @return a float binding
     */
    @Nonnull
    public static FloatBinding mapFloats(@Nonnull final ObservableValue&lt;? extends Number&gt; observable1, @Nonnull final ObservableValue&lt;? extends Number&gt; observable2, @Nonnull final Supplier&lt;Float&gt; supplier, @Nonnull final ObservableValue&lt;BiFunction&lt;? super Number, ? super Number, Float&gt;&gt; mapper) {
<span class="fc" id="L1681">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1682">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1683">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1684">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1685">        return createFloatBinding(() -&gt; {</span>
<span class="fc" id="L1686">            Number value1 = observable1.getValue();</span>
<span class="fc" id="L1687">            Number value2 = observable2.getValue();</span>
<span class="pc bpc" id="L1688" title="2 of 4 branches missed.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L1689">                BiFunction&lt;? super Number, ? super Number, Float&gt; function = mapper.getValue();</span>
<span class="fc" id="L1690">                return requireNonNull(function, ERROR_MAPPER_NULL).apply(value1, value2);</span>
            }
<span class="nc" id="L1692">            return requireNonNull(supplier.get(), ERROR_DEFAULT_VALUE_NULL);</span>
        }, observable1, observable2, mapper);
    }

    /**
     * Returns a double binding whose value is the combination of two observable values.
     *
     * @param observable1  the first observable value.
     * @param observable2  the second observable value.
     * @param defaultValue the value to be returned if there are no values present.
     * @param mapper       a non-interfering, stateless function to apply to the supplied values.
     *
     * @return a double binding
     */
    @Nonnull
    public static DoubleBinding mapDoubles(@Nonnull final ObservableValue&lt;? extends Number&gt; observable1, @Nonnull final ObservableValue&lt;? extends Number&gt; observable2, @Nonnull final Double defaultValue, @Nonnull final BiFunction&lt;? super Number, ? super Number, Double&gt; mapper) {
<span class="fc" id="L1708">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1709">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1710">        requireNonNull(defaultValue, ERROR_DEFAULT_VALUE_NULL);</span>
<span class="fc" id="L1711">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1712">        return createDoubleBinding(() -&gt; {</span>
<span class="fc" id="L1713">            Number value1 = observable1.getValue();</span>
<span class="fc" id="L1714">            Number value2 = observable2.getValue();</span>
<span class="pc bpc" id="L1715" title="2 of 4 branches missed.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L1716">                return mapper.apply(value1, value2);</span>
            }
<span class="nc" id="L1718">            return defaultValue;</span>
        }, observable1, observable2);
    }

    /**
     * Returns a double binding whose value is the combination of two observable values.
     *
     * @param observable1 the first observable value.
     * @param observable2 the second observable value.
     * @param supplier    a {@code Supplier} whose result is returned if no values are present.
     * @param mapper      a non-interfering, stateless function to apply to the supplied values.
     *
     * @return a double binding
     */
    @Nonnull
    public static DoubleBinding mapDoubles(@Nonnull final ObservableValue&lt;? extends Number&gt; observable1, @Nonnull final ObservableValue&lt;? extends Number&gt; observable2, @Nonnull final Supplier&lt;Double&gt; supplier, @Nonnull final BiFunction&lt;? super Number, ? super Number, Double&gt; mapper) {
<span class="fc" id="L1734">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1735">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1736">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1737">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1738">        return createDoubleBinding(() -&gt; {</span>
<span class="fc" id="L1739">            Number value1 = observable1.getValue();</span>
<span class="fc" id="L1740">            Number value2 = observable2.getValue();</span>
<span class="pc bpc" id="L1741" title="2 of 4 branches missed.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L1742">                return mapper.apply(value1, value2);</span>
            }
<span class="nc" id="L1744">            return requireNonNull(supplier.get(), ERROR_DEFAULT_VALUE_NULL);</span>
        }, observable1, observable2);
    }

    /**
     * Returns a double binding whose value is the combination of two observable values.
     *
     * @param observable1  the first observable value.
     * @param observable2  the second observable value.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the supplied values.
     *
     * @return a double binding
     */
    @Nonnull
    public static DoubleBinding mapDoubles(@Nonnull final ObservableValue&lt;? extends Number&gt; observable1, @Nonnull final ObservableValue&lt;? extends Number&gt; observable2, @Nonnull final Double defaultValue, @Nonnull final ObservableValue&lt;BiFunction&lt;? super Number, ? super Number, Double&gt;&gt; mapper) {
<span class="fc" id="L1760">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1761">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1762">        requireNonNull(defaultValue, ERROR_DEFAULT_VALUE_NULL);</span>
<span class="fc" id="L1763">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1764">        return createDoubleBinding(() -&gt; {</span>
<span class="fc" id="L1765">            Number value1 = observable1.getValue();</span>
<span class="fc" id="L1766">            Number value2 = observable2.getValue();</span>
<span class="pc bpc" id="L1767" title="2 of 4 branches missed.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L1768">                BiFunction&lt;? super Number, ? super Number, Double&gt; function = mapper.getValue();</span>
<span class="fc" id="L1769">                return requireNonNull(function, ERROR_MAPPER_NULL).apply(value1, value2);</span>
            }
<span class="nc" id="L1771">            return defaultValue;</span>
        }, observable1, observable2, mapper);
    }

    /**
     * Returns a double binding whose value is the combination of two observable values.
     *
     * @param observable1 the first observable value.
     * @param observable2 the second observable value.
     * @param supplier    a {@code Supplier} whose result is returned if no value is present.
     * @param mapper      a non-interfering, stateless function to apply to the supplied values.
     *
     * @return a double binding
     */
    @Nonnull
    public static DoubleBinding mapDoubles(@Nonnull final ObservableValue&lt;? extends Number&gt; observable1, @Nonnull final ObservableValue&lt;? extends Number&gt; observable2, @Nonnull final Supplier&lt;Double&gt; supplier, @Nonnull final ObservableValue&lt;BiFunction&lt;? super Number, ? super Number, Double&gt;&gt; mapper) {
<span class="fc" id="L1787">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1788">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1789">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1790">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1791">        return createDoubleBinding(() -&gt; {</span>
<span class="fc" id="L1792">            Number value1 = observable1.getValue();</span>
<span class="fc" id="L1793">            Number value2 = observable2.getValue();</span>
<span class="pc bpc" id="L1794" title="2 of 4 branches missed.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L1795">                BiFunction&lt;? super Number, ? super Number, Double&gt; function = mapper.getValue();</span>
<span class="fc" id="L1796">                return requireNonNull(function, ERROR_MAPPER_NULL).apply(value1, value2);</span>
            }
<span class="nc" id="L1798">            return requireNonNull(supplier.get(), ERROR_DEFAULT_VALUE_NULL);</span>
        }, observable1, observable2, mapper);
    }

    /**
     * Returns an object binding whose value is the combination of two observable values.
     *
     * @param observable1  the first observable value.
     * @param observable2  the second observable value.
     * @param defaultValue the value to be returned if there are no values present, may be null.
     * @param mapper       a non-interfering, stateless function to apply to the supplied values.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;A, B, R&gt; ObjectBinding&lt;R&gt; mapObjects(@Nonnull final ObservableValue&lt;A&gt; observable1, @Nonnull final ObservableValue&lt;B&gt; observable2, @Nullable final R defaultValue, @Nonnull final BiFunction&lt;? super A, ? super B, R&gt; mapper) {
<span class="fc" id="L1814">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1815">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1816">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1817">        return createObjectBinding(() -&gt; {</span>
<span class="fc" id="L1818">            A value1 = observable1.getValue();</span>
<span class="fc" id="L1819">            B value2 = observable2.getValue();</span>
<span class="fc bfc" id="L1820" title="All 4 branches covered.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L1821">                return mapper.apply(value1, value2);</span>
            }
<span class="fc" id="L1823">            return defaultValue;</span>
        }, observable1, observable2);
    }

    /**
     * Returns an object binding whose value is the combination of two observable values.
     *
     * @param observable1 the first observable value.
     * @param observable2 the second observable value.
     * @param supplier    a {@code Supplier} whose result is returnedif no values are present.
     * @param mapper      a non-interfering, stateless function to apply to the supplied values.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;A, B, R&gt; ObjectBinding&lt;R&gt; mapObjects(@Nonnull final ObservableValue&lt;A&gt; observable1, @Nonnull final ObservableValue&lt;B&gt; observable2, @Nonnull final Supplier&lt;R&gt; supplier, @Nonnull final BiFunction&lt;? super A, ? super B, R&gt; mapper) {
<span class="fc" id="L1839">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1840">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1841">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1842">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1843">        return createObjectBinding(() -&gt; {</span>
<span class="fc" id="L1844">            A value1 = observable1.getValue();</span>
<span class="fc" id="L1845">            B value2 = observable2.getValue();</span>
<span class="fc bfc" id="L1846" title="All 4 branches covered.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L1847">                return mapper.apply(value1, value2);</span>
            }
<span class="fc" id="L1849">            return supplier.get();</span>
        }, observable1, observable2);
    }

    /**
     * Returns an object binding whose value is the combination of two observable values.
     *
     * @param observable1  the first observable value.
     * @param observable2  the second observable value.
     * @param defaultValue the value to be returned if there is no value present, may be null.
     * @param mapper       a non-interfering, stateless function to apply to the supplied values.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;A, B, R&gt; ObjectBinding&lt;R&gt; mapObjects(@Nonnull final ObservableValue&lt;A&gt; observable1, @Nonnull final ObservableValue&lt;B&gt; observable2, @Nullable final R defaultValue, @Nonnull final ObservableValue&lt;BiFunction&lt;? super A, ? super B, R&gt;&gt; mapper) {
<span class="fc" id="L1865">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1866">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1867">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1868">        return createObjectBinding(() -&gt; {</span>
<span class="fc" id="L1869">            A value1 = observable1.getValue();</span>
<span class="fc" id="L1870">            B value2 = observable2.getValue();</span>
<span class="fc bfc" id="L1871" title="All 4 branches covered.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L1872">                BiFunction&lt;? super A, ? super B, R&gt; function = mapper.getValue();</span>
<span class="fc" id="L1873">                return requireNonNull(function, ERROR_MAPPER_NULL).apply(value1, value2);</span>
            }
<span class="fc" id="L1875">            return defaultValue;</span>
        }, observable1, observable2, mapper);
    }

    /**
     * Returns an object binding whose value is the combination of two observable values.
     *
     * @param observable1 the first observable value.
     * @param observable2 the second observable value.
     * @param supplier    a {@code Supplier} whose result is returned if no values are present.
     * @param mapper      a non-interfering, stateless function to apply to the supplied values.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;A, B, R&gt; ObjectBinding&lt;R&gt; mapObjects(@Nonnull final ObservableValue&lt;A&gt; observable1, @Nonnull final ObservableValue&lt;B&gt; observable2, @Nonnull final Supplier&lt;R&gt; supplier, @Nonnull final ObservableValue&lt;BiFunction&lt;? super A, ? super B, R&gt;&gt; mapper) {
<span class="fc" id="L1891">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1892">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1893">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1894">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1895">        return createObjectBinding(() -&gt; {</span>
<span class="fc" id="L1896">            A value1 = observable1.getValue();</span>
<span class="fc" id="L1897">            B value2 = observable2.getValue();</span>
<span class="fc bfc" id="L1898" title="All 4 branches covered.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L1899">                BiFunction&lt;? super A, ? super B, R&gt; function = mapper.getValue();</span>
<span class="fc" id="L1900">                return requireNonNull(function, ERROR_MAPPER_NULL).apply(value1, value2);</span>
            }
<span class="fc" id="L1902">            return supplier.get();</span>
        }, observable1, observable2, mapper);
    }

    /**
     * Returns a string binding whose value is the combination of two observable values.
     *
     * @param observable1  the first observable value.
     * @param observable2  the second observable value.
     * @param defaultValue the value to be returned if there are no values present.
     * @param mapper       a non-interfering, stateless function to apply to the supplied values.
     *
     * @return a string binding
     */
    @Nonnull
    public static StringBinding mapStrings(@Nonnull final ObservableValue&lt;String&gt; observable1, @Nonnull final ObservableValue&lt;String&gt; observable2, @Nullable final String defaultValue, @Nonnull final BiFunction&lt;String, String, String&gt; mapper) {
<span class="fc" id="L1918">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1919">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1920">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1921">        return createStringBinding(() -&gt; {</span>
<span class="fc" id="L1922">            String value1 = observable1.getValue();</span>
<span class="fc" id="L1923">            String value2 = observable2.getValue();</span>
<span class="pc bpc" id="L1924" title="2 of 4 branches missed.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L1925">                return mapper.apply(value1, value2);</span>
            }
<span class="nc" id="L1927">            return defaultValue;</span>
        }, observable1, observable2);
    }

    /**
     * Returns a string binding whose value is the combination of two observable values.
     *
     * @param observable1 the first observable value.
     * @param observable2 the second observable value.
     * @param supplier    a {@code Supplier} whose result is returned if no values are present.
     * @param mapper      a non-interfering, stateless function to apply to the supplied values.
     *
     * @return a string binding
     */
    @Nonnull
    public static StringBinding mapStrings(@Nonnull final ObservableValue&lt;String&gt; observable1, @Nonnull final ObservableValue&lt;String&gt; observable2, @Nonnull final Supplier&lt;String&gt; supplier, @Nonnull final BiFunction&lt;String, String, String&gt; mapper) {
<span class="fc" id="L1943">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1944">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1945">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1946">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1947">        return createStringBinding(() -&gt; {</span>
<span class="fc" id="L1948">            String value1 = observable1.getValue();</span>
<span class="fc" id="L1949">            String value2 = observable2.getValue();</span>
<span class="pc bpc" id="L1950" title="2 of 4 branches missed.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L1951">                return mapper.apply(value1, value2);</span>
            }
<span class="nc" id="L1953">            return supplier.get();</span>
        }, observable1, observable2);
    }

    /**
     * Returns a string binding whose value is the combination of two observable values.
     *
     * @param observable1  the first observable value.
     * @param observable2  the second observable value.
     * @param defaultValue the value to be returned if there is no value present, may be null.
     * @param mapper       a non-interfering, stateless function to apply to the supplied values.
     *
     * @return a string binding
     */
    @Nonnull
    public static StringBinding mapStrings(@Nonnull final ObservableValue&lt;String&gt; observable1, @Nonnull final ObservableValue&lt;String&gt; observable2, @Nullable final String defaultValue, @Nonnull final ObservableValue&lt;BiFunction&lt;String, String, String&gt;&gt; mapper) {
<span class="fc" id="L1969">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1970">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1971">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1972">        return createStringBinding(() -&gt; {</span>
<span class="fc" id="L1973">            String value1 = observable1.getValue();</span>
<span class="fc" id="L1974">            String value2 = observable2.getValue();</span>
<span class="pc bpc" id="L1975" title="2 of 4 branches missed.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L1976">                BiFunction&lt;String, String, String&gt; function = mapper.getValue();</span>
<span class="fc" id="L1977">                return requireNonNull(function, ERROR_MAPPER_NULL).apply(value1, value2);</span>
            }
<span class="nc" id="L1979">            return defaultValue;</span>
        }, observable1, observable2, mapper);
    }

    /**
     * Returns a string binding whose value is the combination of two observable values.
     *
     * @param observable1 the first observable value.
     * @param observable2 the second observable value.
     * @param supplier    a {@code Supplier} whose result is returned if no values are present.
     * @param mapper      a non-interfering, stateless function to apply to the supplied values.
     *
     * @return a string binding
     */
    @Nonnull
    public static StringBinding mapStrings(@Nonnull final ObservableValue&lt;String&gt; observable1, @Nonnull final ObservableValue&lt;String&gt; observable2, @Nonnull final Supplier&lt;String&gt; supplier, @Nonnull final ObservableValue&lt;BiFunction&lt;String, String, String&gt;&gt; mapper) {
<span class="fc" id="L1995">        requireNonNull(observable1, ERROR_OBSERVABLE1_NULL);</span>
<span class="fc" id="L1996">        requireNonNull(observable2, ERROR_OBSERVABLE2_NULL);</span>
<span class="fc" id="L1997">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1998">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1999">        return createStringBinding(() -&gt; {</span>
<span class="fc" id="L2000">            String value1 = observable1.getValue();</span>
<span class="fc" id="L2001">            String value2 = observable2.getValue();</span>
<span class="pc bpc" id="L2002" title="2 of 4 branches missed.">            if (value1 != null &amp;&amp; value2 != null) {</span>
<span class="fc" id="L2003">                BiFunction&lt;String, String, String&gt; function = mapper.getValue();</span>
<span class="fc" id="L2004">                return requireNonNull(function, ERROR_MAPPER_NULL).apply(value1, value2);</span>
            }
<span class="nc" id="L2006">            return supplier.get();</span>
        }, observable1, observable2, mapper);
    }

    /**
     * Creates an integer binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     *
     * @return an integer binding.
     */
    @Nonnull
    public static IntegerBinding mapInteger(@Nonnull final ObservableValue&lt;? extends Number&gt; observable) {
<span class="nc" id="L2019">        return mapInteger(observable, 0);</span>
    }

    /**
     * Creates an integer binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable   the source observable.
     * @param defaultValue the value to be returned if there is no value present, may be null.
     *
     * @return an integer binding.
     */
    @Nonnull
    public static IntegerBinding mapInteger(@Nonnull final ObservableValue&lt;? extends Number&gt; observable, @Nullable final Integer defaultValue) {
<span class="nc" id="L2032">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc bnc" id="L2033" title="All 2 branches missed.">        if (observable instanceof IntegerBinding) {</span>
<span class="nc" id="L2034">            return (IntegerBinding) observable;</span>
        }
<span class="nc" id="L2036">        return createIntegerBinding(() -&gt; {</span>
<span class="nc" id="L2037">            Number value = observable.getValue();</span>
<span class="nc bnc" id="L2038" title="All 2 branches missed.">            return value != null ? value.intValue() : defaultValue;</span>
        }, observable);
    }

    /**
     * Creates an integer binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param supplier   a {@code Supplier} whose result is returned if no value is present.
     *
     * @return an integer binding.
     */
    @Nonnull
    public static IntegerBinding mapInteger(@Nonnull final ObservableValue&lt;? extends Number&gt; observable, @Nullable final Supplier&lt;Integer&gt; supplier) {
<span class="nc" id="L2052">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L2053">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="nc bnc" id="L2054" title="All 2 branches missed.">        if (observable instanceof IntegerBinding) {</span>
<span class="nc" id="L2055">            return (IntegerBinding) observable;</span>
        }
<span class="nc" id="L2057">        return createIntegerBinding(() -&gt; {</span>
<span class="nc" id="L2058">            Number value = observable.getValue();</span>
<span class="nc bnc" id="L2059" title="All 2 branches missed.">            return value != null ? value.intValue() : supplier.get();</span>
        }, observable);
    }

    /**
     * Creates a long binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     *
     * @return a long binding.
     */
    @Nonnull
    public static LongBinding mapLong(@Nonnull final ObservableValue&lt;? extends Number&gt; observable) {
<span class="nc" id="L2072">        return mapLong(observable, 0L);</span>
    }

    /**
     * Creates a long binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable   the source observable.
     * @param defaultValue the value to be returned if there is no value present, may be null.
     *
     * @return a long binding.
     */
    @Nonnull
    public static LongBinding mapLong(@Nonnull final ObservableValue&lt;? extends Number&gt; observable, @Nullable final Long defaultValue) {
<span class="nc" id="L2085">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc bnc" id="L2086" title="All 2 branches missed.">        if (observable instanceof LongBinding) {</span>
<span class="nc" id="L2087">            return (LongBinding) observable;</span>
        }
<span class="nc" id="L2089">        return createLongBinding(() -&gt; {</span>
<span class="nc" id="L2090">            Number value = observable.getValue();</span>
<span class="nc bnc" id="L2091" title="All 2 branches missed.">            return value != null ? value.longValue() : defaultValue;</span>
        }, observable);
    }

    /**
     * Creates a long binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param supplier   a {@code Supplier} whose result is returned if no value is present.
     *
     * @return a long binding.
     */
    @Nonnull
    public static LongBinding mapLong(@Nonnull final ObservableValue&lt;? extends Number&gt; observable, @Nullable final Supplier&lt;Long&gt; supplier) {
<span class="nc" id="L2105">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L2106">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="nc bnc" id="L2107" title="All 2 branches missed.">        if (observable instanceof LongBinding) {</span>
<span class="nc" id="L2108">            return (LongBinding) observable;</span>
        }
<span class="nc" id="L2110">        return createLongBinding(() -&gt; {</span>
<span class="nc" id="L2111">            Number value = observable.getValue();</span>
<span class="nc bnc" id="L2112" title="All 2 branches missed.">            return value != null ? value.longValue() : supplier.get();</span>
        }, observable);
    }

    /**
     * Creates a float binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     *
     * @return a float binding.
     */
    @Nonnull
    public static FloatBinding mapFloat(@Nonnull final ObservableValue&lt;? extends Number&gt; observable) {
<span class="nc" id="L2125">        return mapFloat(observable, 0f);</span>
    }

    /**
     * Creates a float binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable   the source observable.
     * @param defaultValue the value to be returned if there is no value present, may be null.
     *
     * @return a float binding.
     */
    @Nonnull
    public static FloatBinding mapFloat(@Nonnull final ObservableValue&lt;? extends Number&gt; observable, @Nullable final Float defaultValue) {
<span class="nc" id="L2138">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc bnc" id="L2139" title="All 2 branches missed.">        if (observable instanceof FloatBinding) {</span>
<span class="nc" id="L2140">            return (FloatBinding) observable;</span>
        }
<span class="nc" id="L2142">        return createFloatBinding(() -&gt; {</span>
<span class="nc" id="L2143">            Number value = observable.getValue();</span>
<span class="nc bnc" id="L2144" title="All 2 branches missed.">            return value != null ? value.floatValue() : defaultValue;</span>
        }, observable);
    }

    /**
     * Creates a float binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param supplier   a {@code Supplier} whose result is returned if no value is present.
     *
     * @return a float binding.
     */
    @Nonnull
    public static FloatBinding mapFloat(@Nonnull final ObservableValue&lt;? extends Number&gt; observable, @Nullable final Supplier&lt;Float&gt; supplier) {
<span class="nc" id="L2158">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L2159">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="nc bnc" id="L2160" title="All 2 branches missed.">        if (observable instanceof FloatBinding) {</span>
<span class="nc" id="L2161">            return (FloatBinding) observable;</span>
        }
<span class="nc" id="L2163">        return createFloatBinding(() -&gt; {</span>
<span class="nc" id="L2164">            Number value = observable.getValue();</span>
<span class="nc bnc" id="L2165" title="All 2 branches missed.">            return value != null ? value.floatValue() : supplier.get();</span>
        }, observable);
    }

    /**
     * Creates a double binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     *
     * @return a double binding.
     */
    @Nonnull
    public static DoubleBinding mapDouble(@Nonnull final ObservableValue&lt;? extends Number&gt; observable) {
<span class="nc" id="L2178">        return mapDouble(observable, 0d);</span>
    }

    /**
     * Creates a double binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable   the source observable.
     * @param defaultValue the value to be returned if there is no value present, may be null.
     *
     * @return a double binding.
     */
    @Nonnull
    public static DoubleBinding mapDouble(@Nonnull final ObservableValue&lt;? extends Number&gt; observable, @Nullable final Double defaultValue) {
<span class="nc" id="L2191">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc bnc" id="L2192" title="All 2 branches missed.">        if (observable instanceof DoubleBinding) {</span>
<span class="nc" id="L2193">            return (DoubleBinding) observable;</span>
        }
<span class="nc" id="L2195">        return createDoubleBinding(() -&gt; {</span>
<span class="nc" id="L2196">            Number value = observable.getValue();</span>
<span class="nc bnc" id="L2197" title="All 2 branches missed.">            return value != null ? value.doubleValue() : defaultValue;</span>
        }, observable);
    }

    /**
     * Creates a double binding containing the value of the mapper function applied to the source observable.
     *
     * @param observable the source observable.
     * @param supplier   a {@code Supplier} whose result is returned if no value is present.
     *
     * @return a double binding.
     */
    @Nonnull
    public static DoubleBinding mapDouble(@Nonnull final ObservableValue&lt;? extends Number&gt; observable, @Nullable final Supplier&lt;Double&gt; supplier) {
<span class="nc" id="L2211">        requireNonNull(observable, ERROR_OBSERVABLE_NULL);</span>
<span class="nc" id="L2212">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="nc bnc" id="L2213" title="All 2 branches missed.">        if (observable instanceof DoubleBinding) {</span>
<span class="nc" id="L2214">            return (DoubleBinding) observable;</span>
        }
<span class="nc" id="L2216">        return createDoubleBinding(() -&gt; {</span>
<span class="nc" id="L2217">            Number value = observable.getValue();</span>
<span class="nc bnc" id="L2218" title="All 2 branches missed.">            return value != null ? value.doubleValue() : supplier.get();</span>
        }, observable);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>