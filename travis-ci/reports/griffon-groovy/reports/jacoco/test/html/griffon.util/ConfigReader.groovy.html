<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConfigReader.groovy</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">griffon-groovy</a> &gt; <a href="index.source.html" class="el_package">griffon.util</a> &gt; <span class="el_source">ConfigReader.groovy</span></div><h1>ConfigReader.groovy</h1><pre class="source lang-java linenums">/*
 * Copyright 2008-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package griffon.util

import griffon.core.ApplicationClassLoader
import griffon.core.env.Environment
import griffon.core.env.GriffonEnvironment
import griffon.core.env.Metadata
import org.codehaus.groovy.runtime.InvokerHelper

import javax.annotation.Nonnull
import javax.inject.Inject

import static griffon.util.GriffonNameUtils.isBlank

/**
 * Updated version of {@code groovy.util.ConfigSlurper}.&lt;br/&gt;
 * New features include:
 * &lt;ul&gt;
 *     &lt;li&gt;Ability to specify multiple conditional blocks, not just &quot;environments&quot;.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @author Graeme Rocher (Groovy 1.5)
 * @author Andres Almiray
 * @since 2.0.0
 */
@SuppressWarnings(&quot;rawtypes&quot;)
class ConfigReader {
    private static final ENVIRONMENTS_METHOD = 'environments'
    GroovyClassLoader classLoader
    private Map bindingVars = [:]

<span class="fc" id="L46">    private Stack&lt;String&gt; currentConditionalBlock = new Stack&lt;String&gt;()</span>
    private final Map&lt;String, String&gt; conditionValues = [:]
<span class="fc" id="L48">    private final Stack&lt;Map&lt;String, ConfigObject&gt;&gt; conditionalBlocks = new Stack&lt;Map&lt;String, ConfigObject&gt;&gt;()</span>

    static class Provider implements javax.inject.Provider&lt;ConfigReader&gt; {
        @Inject private ApplicationClassLoader applicationClassLoader
        @Inject private Metadata metadata
        @Inject private Environment environment

        @Override
        ConfigReader get() {
<span class="fc" id="L57">            ConfigReader configReader = new ConfigReader(applicationClassLoader)</span>
<span class="fc" id="L58">            configReader.setBinding(CollectionUtils.map()</span>
<span class="fc" id="L59">                .e(&quot;userHome&quot;, System.getProperty(&quot;user.home&quot;))</span>
<span class="fc" id="L60">                .e(&quot;appName&quot;, metadata.getApplicationName())</span>
<span class="fc" id="L61">                .e(&quot;appVersion&quot;, metadata.getApplicationVersion())</span>
<span class="fc" id="L62">                .e(&quot;griffonVersion&quot;, GriffonEnvironment.getGriffonVersion()));</span>
<span class="fc" id="L63">            configReader.registerConditionalBlock(&quot;environments&quot;, environment.getName())</span>
<span class="fc" id="L64">            configReader.registerConditionalBlock(&quot;projects&quot;, metadata.getApplicationName())</span>
<span class="fc" id="L65">            configReader.registerConditionalBlock(&quot;platforms&quot;, GriffonApplicationUtils.getPlatform())</span>
<span class="pc" id="L66">            configReader</span>
        }
    }

    @Inject
    ConfigReader(@Nonnull ApplicationClassLoader applicationClassLoader) {
<span class="fc" id="L72">        classLoader = new GroovyClassLoader(applicationClassLoader.get())</span>
    }

    void registerConditionalBlock(String blockName, String blockValue) {
<span class="pc bpc" id="L76" title="2 of 4 branches missed.">        if (!isBlank(blockName)) {</span>
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">            if (isBlank(blockValue)) {</span>
<span class="nc" id="L78">                conditionValues.remove(blockName)</span>
            } else {
<span class="fc" id="L80">                conditionValues[blockName] = blockValue</span>
            }
        }
    }

    Map&lt;String, String&gt; getConditionalBlockValues() {
<span class="nc" id="L86">        Collections.unmodifiableMap(conditionValues)</span>
    }

    String getEnvironment() {
<span class="nc" id="L90">        return conditionValues[ENVIRONMENTS_METHOD]</span>
    }

    void setEnvironment(String environment) {
<span class="fc" id="L94">        conditionValues[ENVIRONMENTS_METHOD] = environment</span>
    }

    void setBinding(Map vars) {
<span class="fc" id="L98">        this.bindingVars = vars</span>
    }

    /**
     * Parses a ConfigObject instances from an instance of java.util.Properties
     * @param The java.util.Properties instance
     */
    ConfigObject parse(Properties properties) {
<span class="fc" id="L106">        ConfigObject config = new ConfigObject()</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">        for (key in properties.keySet()) {</span>
<span class="fc" id="L108">            def tokens = key.split(/\./)</span>

<span class="fc" id="L110">            def current = config</span>
<span class="fc" id="L111">            def last</span>
<span class="fc" id="L112">            def lastToken</span>
<span class="fc" id="L113">            def foundBase = false</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">            for (token in tokens) {</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">                if (foundBase) {</span>
                    // handle not properly nested tokens by ignoring
                    // hierarchy below this point
<span class="fc" id="L118">                    lastToken += &quot;.&quot; + token</span>
<span class="fc" id="L119">                    current = last</span>
                } else {
<span class="fc" id="L121">                    last = current</span>
<span class="fc" id="L122">                    lastToken = token</span>
<span class="fc" id="L123">                    current = current.&quot;${token}&quot;</span>
<span class="fc bfc" id="L124" title="All 4 branches covered.">                    if (!(current instanceof ConfigObject)) foundBase = true</span>
                }
            }

<span class="pc bpc" id="L128" title="1 of 2 branches missed.">            if (current instanceof ConfigObject) {</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">                if (last[lastToken]) {</span>
<span class="fc" id="L130">                    def flattened = last.flatten()</span>
<span class="fc" id="L131">                    last.clear()</span>
<span class="pc" id="L132">                    flattened.each { k2, v2 -&gt; last[k2] = v2 }</span>
<span class="fc" id="L133">                    last[lastToken] = properties.get(key)</span>
                } else {
<span class="fc" id="L135">                    last[lastToken] = properties.get(key)</span>
                }
            }
<span class="fc" id="L138">            current = config</span>
        }
<span class="pc" id="L140">        return config</span>
    }
    /**
     * Parse the given script as a string and return the configuration object
     *
     * @see ConfigReader#parse(groovy.lang.Script)
     */
    ConfigObject parse(String script) {
<span class="pc" id="L148">        return parse(classLoader.parseClass(script))</span>
    }

    /**
     * Create a new instance of the given script class and parse a configuration object from it
     *
     * @see ConfigReader#parse(groovy.lang.Script)
     */
    ConfigObject parse(Class&lt;? extends Script&gt; scriptClass) {
<span class="pc" id="L157">        return parse(scriptClass.newInstance())</span>
    }

    /**
     * Parse the given script into a configuration object (a Map)
     * @param script The script to parse
     * @return A Map of maps that can be navigating with dot de-referencing syntax to obtain configuration entries
     */
    ConfigObject parse(Script script) {
<span class="pc" id="L166">        return parse(script, null)</span>
    }

    /**
     * Parses a Script represented by the given URL into a ConfigObject
     *
     * @param scriptLocation The location of the script to parse
     * @return The ConfigObject instance
     */
    ConfigObject parse(URL scriptLocation) {
<span class="pc" id="L176">        return parse(classLoader.parseClass(scriptLocation.text).newInstance(), scriptLocation)</span>
    }

    /**
     * Parses the passed groovy.lang.Script instance using the second argument to allow the ConfigObject
     * to retain an reference to the original location other Groovy script
     *
     * @param script The groovy.lang.Script instance
     * @param location The original location of the Script as a URL
     * @return The ConfigObject instance
     */
    ConfigObject parse(Script script, URL location) {
<span class="fc bfc" id="L188" title="All 2 branches covered.">        def config = location ? new ConfigObject(location) : new ConfigObject()</span>
<span class="fc" id="L189">        GroovySystem.metaClassRegistry.removeMetaClass(script.class)</span>
<span class="fc" id="L190">        def mc = script.class.metaClass</span>
<span class="fc" id="L191">        def prefix = &quot;&quot;</span>
<span class="fc" id="L192">        LinkedList stack = new LinkedList()</span>
<span class="fc" id="L193">        stack &lt;&lt; [config: config, scope: [:]]</span>
<span class="fc" id="L194">        def pushStack = { co -&gt;</span>
<span class="pc" id="L195">            stack &lt;&lt; [config: co, scope: stack.last.scope.clone()]</span>
        }
<span class="fc" id="L197">        def assignName = { name, co -&gt;</span>
<span class="fc" id="L198">            def current = stack.last</span>
            /*
            def cfg = current.config
            if (cfg instanceof ConfigObject) {
                String[] keys = name.split(/\./)
                for (int i = 0; i &lt; keys.length - 1; i++) {
                    String key = keys[i]
                    if (!cfg.containsKey(key)) {
                        cfg[key] = new ConfigObject()
                    }
                    cfg = cfg.get(key)
                }
                name = keys[keys.length - 1]
            }
            cfg[name] = co
            */
<span class="fc" id="L214">            current.config[name] = co</span>
<span class="pc" id="L215">            current.scope[name] = co</span>
        }
<span class="fc" id="L217">        mc.getProperty = { String name -&gt;</span>
<span class="fc" id="L218">            def current = stack.last</span>
<span class="fc" id="L219">            def result</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">            if (current.config.get(name)) {</span>
<span class="fc" id="L221">                result = current.config.get(name)</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">            } else if (current.scope[name]) {</span>
<span class="fc" id="L223">                result = current.scope[name]</span>
            } else {
                try {
<span class="pc" id="L226">                    result = InvokerHelper.getProperty(this, name)</span>
                } catch (GroovyRuntimeException e) {
<span class="fc" id="L228">                    result = new ConfigObject()</span>
<span class="pc" id="L229">                    assignName.call(name, result)</span>
                }
            }
<span class="pc" id="L232">            result</span>
        }

<span class="fc" id="L235">        ConfigObject overrides = new ConfigObject()</span>
<span class="fc" id="L236">        mc.invokeMethod = { String name, args -&gt;</span>
<span class="fc" id="L237">            def result</span>
<span class="pc bpc" id="L238" title="1 of 6 branches missed.">            if (args.length == 1 &amp;&amp; args[0] instanceof Closure) {</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">                if (name in conditionValues.keySet()) {</span>
                    try {
<span class="fc" id="L241">                        currentConditionalBlock.push(name)</span>
<span class="fc" id="L242">                        conditionalBlocks.push([:])</span>
<span class="fc" id="L243">                        args[0].call()</span>
                    } finally {
<span class="pc" id="L245">                        currentConditionalBlock.pop()</span>
<span class="pc bpc" id="L246" title="2 of 4 branches missed.">                        for (entry in conditionalBlocks.pop().entrySet()) {</span>
<span class="pc" id="L247">                            def c = stack.last.config</span>
<span class="pc bpc" id="L248" title="2 of 4 branches missed.">                            (c != config ? c : overrides).merge(entry.value)</span>
                        }
                    }
<span class="fc bfc" id="L251" title="All 2 branches covered.">                } else if (currentConditionalBlock.size() &gt; 0) {</span>
<span class="fc" id="L252">                    String conditionalBlockKey = currentConditionalBlock.peek()</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">                    if (name == conditionValues[conditionalBlockKey]) {</span>
<span class="fc" id="L254">                        def co = new ConfigObject()</span>
<span class="fc" id="L255">                        conditionalBlocks.peek()[conditionalBlockKey] = co</span>

<span class="fc" id="L257">                        pushStack.call(co)</span>
                        try {
<span class="fc" id="L259">                            currentConditionalBlock.pop()</span>
<span class="fc" id="L260">                            args[0].call()</span>
                        } finally {
<span class="pc" id="L262">                            currentConditionalBlock.push(conditionalBlockKey)</span>
                        }
<span class="fc" id="L264">                        stack.pop()</span>
                    }
                } else {
<span class="fc" id="L267">                    def co</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">                    if (stack.last.config.get(name) instanceof ConfigObject) {</span>
<span class="fc" id="L269">                        co = stack.last.config.get(name)</span>
                    } else {
<span class="fc" id="L271">                        co = new ConfigObject()</span>
                    }

<span class="fc" id="L274">                    assignName.call(name, co)</span>
<span class="fc" id="L275">                    pushStack.call(co)</span>
<span class="fc" id="L276">                    args[0].call()</span>
<span class="fc" id="L277">                    stack.pop()</span>
                }
<span class="pc bpc" id="L279" title="1 of 6 branches missed.">            } else if (args.length == 2 &amp;&amp; args[1] instanceof Closure) {</span>
                try {
<span class="fc" id="L281">                    prefix = name + '.'</span>
<span class="fc" id="L282">                    assignName.call(name, args[0])</span>
<span class="fc" id="L283">                    args[1].call()</span>
<span class="pc" id="L284">                } finally { prefix = &quot;&quot; }</span>
            } else {
<span class="fc" id="L286">                MetaMethod mm = mc.getMetaMethod(name, args)</span>
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">                if (mm) {</span>
<span class="fc" id="L288">                    result = mm.invoke(delegate, args)</span>
                } else {
<span class="nc" id="L290">                    throw new MissingMethodException(name, getClass(), args)</span>
                }
            }
<span class="pc" id="L293">            result</span>
        }
<span class="fc" id="L295">        script.metaClass = mc</span>

<span class="fc" id="L297">        def setProperty = { String name, value -&gt;</span>
<span class="pc" id="L298">            assignName.call(prefix + name, value)</span>
        }
<span class="fc" id="L300">        def binding = new ConfigBinding(setProperty)</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">        if (this.bindingVars) {</span>
<span class="fc" id="L302">            binding.getVariables().putAll(this.bindingVars)</span>
        }
<span class="fc" id="L304">        script.binding = binding</span>

<span class="fc" id="L306">        script.run()</span>

<span class="fc" id="L308">        config.merge(overrides)</span>

<span class="pc" id="L310">        return config</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>