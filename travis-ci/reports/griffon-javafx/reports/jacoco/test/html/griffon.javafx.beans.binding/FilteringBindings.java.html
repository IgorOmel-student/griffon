<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FilteringBindings.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">griffon-javafx</a> &gt; <a href="index.source.html" class="el_package">griffon.javafx.beans.binding</a> &gt; <span class="el_source">FilteringBindings.java</span></div><h1>FilteringBindings.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2008-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package griffon.javafx.beans.binding;

import javafx.beans.binding.BooleanBinding;
import javafx.beans.binding.DoubleBinding;
import javafx.beans.binding.FloatBinding;
import javafx.beans.binding.IntegerBinding;
import javafx.beans.binding.LongBinding;
import javafx.beans.binding.ObjectBinding;
import javafx.beans.binding.StringBinding;
import javafx.beans.value.ObservableValue;
import javafx.collections.ObservableList;
import javafx.collections.ObservableMap;
import javafx.collections.ObservableSet;

import javax.annotation.Nonnull;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;

import static java.util.Objects.requireNonNull;
import static javafx.beans.binding.Bindings.createBooleanBinding;
import static javafx.beans.binding.Bindings.createDoubleBinding;
import static javafx.beans.binding.Bindings.createFloatBinding;
import static javafx.beans.binding.Bindings.createIntegerBinding;
import static javafx.beans.binding.Bindings.createLongBinding;
import static javafx.beans.binding.Bindings.createObjectBinding;
import static javafx.beans.binding.Bindings.createStringBinding;

/**
 * @author Andres Almiray
 * @since 2.10.0
 */
public final class FilteringBindings {
    private static final String ERROR_ITEMS_NULL = &quot;Argument 'items' must not be null&quot;;
    private static final String ERROR_FILTER_NULL = &quot;Argument 'filter' must not be null&quot;;
    private static final String ERROR_MAPPER_NULL = &quot;Argument 'mapper' must not be null&quot;;
    private static final String ERROR_SUPPLIER_NULL = &quot;Argument 'supplier' must not be null&quot;;

<span class="nc" id="L54">    private FilteringBindings() {</span>
        // prevent instantiation
<span class="nc" id="L56">    }</span>

    /**
     * Creates an object binding with the first element of an observable list after filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;T&gt; ObjectBinding&lt;T&gt; filterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final T defaultValue, @Nonnull final Predicate&lt;? super T&gt; filter) {
<span class="fc" id="L69">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L70">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L71">        return createObjectBinding(() -&gt; items.stream().filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates an object binding with the first element of an observable list after filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;T&gt; ObjectBinding&lt;T&gt; filterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;T&gt; supplier, @Nonnull final Predicate&lt;? super T&gt; filter) {
<span class="fc" id="L85">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L86">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L87">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L88">        return createObjectBinding(() -&gt; items.stream().filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates an object binding with the first element of an observable list after filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;T&gt; ObjectBinding&lt;T&gt; filterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final T defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter) {
<span class="fc" id="L102">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L103">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L104">        return createObjectBinding(() -&gt; {</span>
<span class="fc" id="L105">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L106">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L107">            return items.stream().filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, filter);
    }

    /**
     * Creates an object binding with the first element of an observable list after filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;T&gt; ObjectBinding&lt;T&gt; filterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;T&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter) {
<span class="fc" id="L122">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L123">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L124">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L125">        return createObjectBinding(() -&gt; {</span>
<span class="fc" id="L126">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L127">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L128">            return items.stream().filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, filter);
    }

    /**
     * Creates a boolean binding with the first element of an observable list after filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return a boolean binding
     */
    @Nonnull
    public static BooleanBinding filterThenFindFirstBoolean(@Nonnull final ObservableList&lt;Boolean&gt; items, @Nonnull final Boolean defaultValue, @Nonnull final Predicate&lt;? super Boolean&gt; filter) {
<span class="fc" id="L143">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L144">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L145">        return createBooleanBinding(() -&gt; items.stream().filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a boolean binding with the first element of an observable list after filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return a boolean binding
     */
    @Nonnull
    public static BooleanBinding filterThenFindFirstBoolean(@Nonnull final ObservableList&lt;Boolean&gt; items, @Nonnull final Supplier&lt;Boolean&gt; supplier, @Nonnull final Predicate&lt;? super Boolean&gt; filter) {
<span class="fc" id="L159">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L160">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L161">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L162">        return createBooleanBinding(() -&gt; items.stream().filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a boolean binding with the first element of an observable list after filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return a boolean binding
     */
    @Nonnull
    public static BooleanBinding filterThenFindFirstBoolean(@Nonnull final ObservableList&lt;Boolean&gt; items, @Nonnull final Boolean defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super Boolean&gt;&gt; filter) {
<span class="fc" id="L176">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L177">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L178">        return createBooleanBinding(() -&gt; {</span>
<span class="fc" id="L179">            Predicate&lt;? super Boolean&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L180">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L181">            return items.stream().filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, filter);
    }

    /**
     * Creates a boolean binding with the first element of an observable list after filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return a boolean binding
     */
    @Nonnull
    public static BooleanBinding filterThenFindFirstBoolean(@Nonnull final ObservableList&lt;Boolean&gt; items, @Nonnull final Supplier&lt;Boolean&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super Boolean&gt;&gt; filter) {
<span class="fc" id="L196">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L197">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L198">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L199">        return createBooleanBinding(() -&gt; {</span>
<span class="fc" id="L200">            Predicate&lt;? super Boolean&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L201">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L202">            return items.stream().filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, filter);
    }

    /**
     * Creates an integer binding with the first element of an observable list after filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return an integer binding
     */
    @Nonnull
    public static IntegerBinding filterThenFindFirstInteger(@Nonnull final ObservableList&lt;Integer&gt; items, @Nonnull final Integer defaultValue, @Nonnull final Predicate&lt;? super Integer&gt; filter) {
<span class="fc" id="L217">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L218">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L219">        return createIntegerBinding(() -&gt; items.stream().filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates an integer binding with the first element of an observable list after filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return an integer binding
     */
    @Nonnull
    public static IntegerBinding filterThenFindFirstInteger(@Nonnull final ObservableList&lt;Integer&gt; items, @Nonnull final Supplier&lt;Integer&gt; supplier, @Nonnull final Predicate&lt;? super Integer&gt; filter) {
<span class="fc" id="L233">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L234">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L235">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L236">        return createIntegerBinding(() -&gt; items.stream().filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates an integer binding with the first element of an observable list after filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return an integer binding
     */
    @Nonnull
    public static IntegerBinding filterThenFindFirstInteger(@Nonnull final ObservableList&lt;Integer&gt; items, @Nonnull final Integer defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super Integer&gt;&gt; filter) {
<span class="fc" id="L250">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L251">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L252">        return createIntegerBinding(() -&gt; {</span>
<span class="fc" id="L253">            Predicate&lt;? super Integer&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L254">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L255">            return items.stream().filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, filter);
    }

    /**
     * Creates an integer binding with the first element of an observable list after filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return an integer binding
     */
    @Nonnull
    public static IntegerBinding filterThenFindFirstInteger(@Nonnull final ObservableList&lt;Integer&gt; items, @Nonnull final Supplier&lt;Integer&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super Integer&gt;&gt; filter) {
<span class="fc" id="L270">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L271">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L272">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L273">        return createIntegerBinding(() -&gt; {</span>
<span class="fc" id="L274">            Predicate&lt;? super Integer&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L275">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L276">            return items.stream().filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, filter);
    }

    /**
     * Creates a long binding with the first element of an observable list after filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return a long binding
     */
    @Nonnull
    public static LongBinding filterThenFindFirstLong(@Nonnull final ObservableList&lt;Long&gt; items, @Nonnull final Long defaultValue, @Nonnull final Predicate&lt;? super Long&gt; filter) {
<span class="fc" id="L291">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L292">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L293">        return createLongBinding(() -&gt; items.stream().filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a long binding with the first element of an observable list after filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return a long binding
     */
    @Nonnull
    public static LongBinding filterThenFindFirstLong(@Nonnull final ObservableList&lt;Long&gt; items, @Nonnull final Supplier&lt;Long&gt; supplier, @Nonnull final Predicate&lt;? super Long&gt; filter) {
<span class="fc" id="L307">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L308">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L309">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L310">        return createLongBinding(() -&gt; items.stream().filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a long binding with the first element of an observable list after filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return a long binding
     */
    @Nonnull
    public static LongBinding filterThenFindFirstLong(@Nonnull final ObservableList&lt;Long&gt; items, @Nonnull final Long defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super Long&gt;&gt; filter) {
<span class="fc" id="L324">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L325">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L326">        return createLongBinding(() -&gt; {</span>
<span class="fc" id="L327">            Predicate&lt;? super Long&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L328">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L329">            return items.stream().filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, filter);
    }

    /**
     * Creates a long binding with the first element of an observable list after filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return a long binding
     */
    @Nonnull
    public static LongBinding filterThenFindFirstLong(@Nonnull final ObservableList&lt;Long&gt; items, @Nonnull final Supplier&lt;Long&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super Long&gt;&gt; filter) {
<span class="fc" id="L344">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L345">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L346">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L347">        return createLongBinding(() -&gt; {</span>
<span class="fc" id="L348">            Predicate&lt;? super Long&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L349">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L350">            return items.stream().filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, filter);
    }

    /**
     * Creates a float binding with the first element of an observable list after filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return a float binding
     */
    @Nonnull
    public static FloatBinding filterThenFindFirstFloat(@Nonnull final ObservableList&lt;Float&gt; items, @Nonnull final Float defaultValue, @Nonnull final Predicate&lt;? super Float&gt; filter) {
<span class="fc" id="L365">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L366">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L367">        return createFloatBinding(() -&gt; items.stream().filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a float binding with the first element of an observable list after filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return a float binding
     */
    @Nonnull
    public static FloatBinding filterThenFindFirstFloat(@Nonnull final ObservableList&lt;Float&gt; items, @Nonnull final Supplier&lt;Float&gt; supplier, @Nonnull final Predicate&lt;? super Float&gt; filter) {
<span class="fc" id="L381">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L382">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L383">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L384">        return createFloatBinding(() -&gt; items.stream().filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a float binding with the first element of an observable list after filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return a float binding
     */
    @Nonnull
    public static FloatBinding filterThenFindFirstFloat(@Nonnull final ObservableList&lt;Float&gt; items, @Nonnull final Float defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super Float&gt;&gt; filter) {
<span class="fc" id="L398">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L399">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L400">        return createFloatBinding(() -&gt; {</span>
<span class="fc" id="L401">            Predicate&lt;? super Float&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L402">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L403">            return items.stream().filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, filter);
    }

    /**
     * Creates a float binding with the first element of an observable list after filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return a float binding
     */
    @Nonnull
    public static FloatBinding filterThenFindFirstFloat(@Nonnull final ObservableList&lt;Float&gt; items, @Nonnull final Supplier&lt;Float&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super Float&gt;&gt; filter) {
<span class="fc" id="L418">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L419">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L420">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L421">        return createFloatBinding(() -&gt; {</span>
<span class="fc" id="L422">            Predicate&lt;? super Float&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L423">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L424">            return items.stream().filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, filter);
    }

    /**
     * Creates a double binding with the first element of an observable list after filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return a double binding
     */
    @Nonnull
    public static DoubleBinding filterThenFindFirstDouble(@Nonnull final ObservableList&lt;Double&gt; items, @Nonnull final Double defaultValue, @Nonnull final Predicate&lt;? super Double&gt; filter) {
<span class="fc" id="L439">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L440">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L441">        return createDoubleBinding(() -&gt; items.stream().filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a double binding with the first element of an observable list after filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return a double binding
     */
    @Nonnull
    public static DoubleBinding filterThenFindFirstDouble(@Nonnull final ObservableList&lt;Double&gt; items, @Nonnull final Supplier&lt;Double&gt; supplier, @Nonnull final Predicate&lt;? super Double&gt; filter) {
<span class="fc" id="L455">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L456">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L457">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L458">        return createDoubleBinding(() -&gt; items.stream().filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a double binding with the first element of an observable list after filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return a double binding
     */
    @Nonnull
    public static DoubleBinding filterThenFindFirstDouble(@Nonnull final ObservableList&lt;Double&gt; items, @Nonnull final Double defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super Double&gt;&gt; filter) {
<span class="fc" id="L472">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L473">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L474">        return createDoubleBinding(() -&gt; {</span>
<span class="fc" id="L475">            Predicate&lt;? super Double&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L476">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L477">            return items.stream().filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, filter);
    }

    /**
     * Creates a double binding with the first element of an observable list after filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return a double binding
     */
    @Nonnull
    public static DoubleBinding filterThenFindFirstDouble(@Nonnull final ObservableList&lt;Double&gt; items, @Nonnull final Supplier&lt;Double&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super Double&gt;&gt; filter) {
<span class="fc" id="L492">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L493">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L494">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L495">        return createDoubleBinding(() -&gt; {</span>
<span class="fc" id="L496">            Predicate&lt;? super Double&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L497">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L498">            return items.stream().filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, filter);
    }

    /**
     * Creates a string binding with the first element of an observable list after filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return a string binding
     */
    @Nonnull
    public static StringBinding filterThenFindFirstString(@Nonnull final ObservableList&lt;String&gt; items, @Nonnull final String defaultValue, @Nonnull final Predicate&lt;? super String&gt; filter) {
<span class="fc" id="L513">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L514">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L515">        return createStringBinding(() -&gt; items.stream().filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a string binding with the first element of an observable list after filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return a string binding
     */
    @Nonnull
    public static StringBinding filterThenFindFirstString(@Nonnull final ObservableList&lt;String&gt; items, @Nonnull final Supplier&lt;String&gt; supplier, @Nonnull final Predicate&lt;? super String&gt; filter) {
<span class="fc" id="L529">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L530">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L531">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L532">        return createStringBinding(() -&gt; items.stream().filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a string binding with the first element of an observable list after filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return a string binding
     */
    @Nonnull
    public static StringBinding filterThenFindFirstString(@Nonnull final ObservableList&lt;String&gt; items, @Nonnull final String defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super String&gt;&gt; filter) {
<span class="fc" id="L546">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L547">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L548">        return createStringBinding(() -&gt; {</span>
<span class="fc" id="L549">            Predicate&lt;? super String&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L550">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L551">            return items.stream().filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, filter);
    }

    /**
     * Creates a string binding with the first element of an observable list after filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return a string binding
     */
    @Nonnull
    public static StringBinding filterThenFindFirstString(@Nonnull final ObservableList&lt;String&gt; items, @Nonnull final Supplier&lt;String&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super String&gt;&gt; filter) {
<span class="fc" id="L566">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L567">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L568">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L569">        return createStringBinding(() -&gt; {</span>
<span class="fc" id="L570">            Predicate&lt;? super String&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L571">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L572">            return items.stream().filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, filter);
    }

    /**
     * Creates an object binding with the first element of an observable set after filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;T&gt; ObjectBinding&lt;T&gt; filterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final T defaultValue, @Nonnull final Predicate&lt;? super T&gt; filter) {
<span class="fc" id="L587">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L588">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L589">        return createObjectBinding(() -&gt; items.stream().filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates an object binding with the first element of an observable set after filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;T&gt; ObjectBinding&lt;T&gt; filterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;T&gt; supplier, @Nonnull final Predicate&lt;? super T&gt; filter) {
<span class="fc" id="L603">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L604">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L605">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L606">        return createObjectBinding(() -&gt; items.stream().filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates an object binding with the first element of an observable set after filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;T&gt; ObjectBinding&lt;T&gt; filterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final T defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter) {
<span class="fc" id="L620">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L621">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L622">        return createObjectBinding(() -&gt; {</span>
<span class="fc" id="L623">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L624">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L625">            return items.stream().filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, filter);
    }

    /**
     * Creates an object binding with the first element of an observable set after filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;T&gt; ObjectBinding&lt;T&gt; filterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;T&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter) {
<span class="fc" id="L640">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L641">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L642">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L643">        return createObjectBinding(() -&gt; {</span>
<span class="fc" id="L644">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L645">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L646">            return items.stream().filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, filter);
    }

    /**
     * Creates a boolean binding with the first element of an observable set after filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return a boolean binding
     */
    @Nonnull
    public static BooleanBinding filterThenFindFirstBoolean(@Nonnull final ObservableSet&lt;Boolean&gt; items, @Nonnull final Boolean defaultValue, @Nonnull final Predicate&lt;? super Boolean&gt; filter) {
<span class="fc" id="L661">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L662">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L663">        return createBooleanBinding(() -&gt; items.stream().filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a boolean binding with the first element of an observable set after filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return a boolean binding
     */
    @Nonnull
    public static BooleanBinding filterThenFindFirstBoolean(@Nonnull final ObservableSet&lt;Boolean&gt; items, @Nonnull final Supplier&lt;Boolean&gt; supplier, @Nonnull final Predicate&lt;? super Boolean&gt; filter) {
<span class="fc" id="L677">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L678">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L679">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L680">        return createBooleanBinding(() -&gt; items.stream().filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a boolean binding with the first element of an observable set after filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return a boolean binding
     */
    @Nonnull
    public static BooleanBinding filterThenFindFirstBoolean(@Nonnull final ObservableSet&lt;Boolean&gt; items, @Nonnull final Boolean defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super Boolean&gt;&gt; filter) {
<span class="fc" id="L694">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L695">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L696">        return createBooleanBinding(() -&gt; {</span>
<span class="fc" id="L697">            Predicate&lt;? super Boolean&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L698">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L699">            return items.stream().filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, filter);
    }

    /**
     * Creates a boolean binding with the first element of an observable set after filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return a boolean binding
     */
    @Nonnull
    public static BooleanBinding filterThenFindFirstBoolean(@Nonnull final ObservableSet&lt;Boolean&gt; items, @Nonnull final Supplier&lt;Boolean&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super Boolean&gt;&gt; filter) {
<span class="fc" id="L714">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L715">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L716">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L717">        return createBooleanBinding(() -&gt; {</span>
<span class="fc" id="L718">            Predicate&lt;? super Boolean&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L719">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L720">            return items.stream().filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, filter);
    }

    /**
     * Creates an integer binding with the first element of an observable set after filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return an integer binding
     */
    @Nonnull
    public static IntegerBinding filterThenFindFirstInteger(@Nonnull final ObservableSet&lt;Integer&gt; items, @Nonnull final Integer defaultValue, @Nonnull final Predicate&lt;? super Integer&gt; filter) {
<span class="fc" id="L735">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L736">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L737">        return createIntegerBinding(() -&gt; items.stream().filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates an integer binding with the first element of an observable set after filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return an integer binding
     */
    @Nonnull
    public static IntegerBinding filterThenFindFirstInteger(@Nonnull final ObservableSet&lt;Integer&gt; items, @Nonnull final Supplier&lt;Integer&gt; supplier, @Nonnull final Predicate&lt;? super Integer&gt; filter) {
<span class="fc" id="L751">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L752">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L753">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L754">        return createIntegerBinding(() -&gt; items.stream().filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates an integer binding with the first element of an observable set after filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return an integer binding
     */
    @Nonnull
    public static IntegerBinding filterThenFindFirstInteger(@Nonnull final ObservableSet&lt;Integer&gt; items, @Nonnull final Integer defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super Integer&gt;&gt; filter) {
<span class="fc" id="L768">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L769">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L770">        return createIntegerBinding(() -&gt; {</span>
<span class="fc" id="L771">            Predicate&lt;? super Integer&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L772">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L773">            return items.stream().filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, filter);
    }

    /**
     * Creates an integer binding with the first element of an observable set after filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return an integer binding
     */
    @Nonnull
    public static IntegerBinding filterThenFindFirstInteger(@Nonnull final ObservableSet&lt;Integer&gt; items, @Nonnull final Supplier&lt;Integer&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super Integer&gt;&gt; filter) {
<span class="fc" id="L788">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L789">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L790">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L791">        return createIntegerBinding(() -&gt; {</span>
<span class="fc" id="L792">            Predicate&lt;? super Integer&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L793">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L794">            return items.stream().filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, filter);
    }

    /**
     * Creates a long binding with the first element of an observable set after filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return a long binding
     */
    @Nonnull
    public static LongBinding filterThenFindFirstLong(@Nonnull final ObservableSet&lt;Long&gt; items, @Nonnull final Long defaultValue, @Nonnull final Predicate&lt;? super Long&gt; filter) {
<span class="fc" id="L809">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L810">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L811">        return createLongBinding(() -&gt; items.stream().filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a long binding with the first element of an observable set after filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return a long binding
     */
    @Nonnull
    public static LongBinding filterThenFindFirstLong(@Nonnull final ObservableSet&lt;Long&gt; items, @Nonnull final Supplier&lt;Long&gt; supplier, @Nonnull final Predicate&lt;? super Long&gt; filter) {
<span class="fc" id="L825">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L826">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L827">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L828">        return createLongBinding(() -&gt; items.stream().filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a long binding with the first element of an observable set after filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return a long binding
     */
    @Nonnull
    public static LongBinding filterThenFindFirstLong(@Nonnull final ObservableSet&lt;Long&gt; items, @Nonnull final Long defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super Long&gt;&gt; filter) {
<span class="fc" id="L842">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L843">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L844">        return createLongBinding(() -&gt; {</span>
<span class="fc" id="L845">            Predicate&lt;? super Long&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L846">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L847">            return items.stream().filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, filter);
    }

    /**
     * Creates a long binding with the first element of an observable set after filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return a long binding
     */
    @Nonnull
    public static LongBinding filterThenFindFirstLong(@Nonnull final ObservableSet&lt;Long&gt; items, @Nonnull final Supplier&lt;Long&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super Long&gt;&gt; filter) {
<span class="fc" id="L862">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L863">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L864">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L865">        return createLongBinding(() -&gt; {</span>
<span class="fc" id="L866">            Predicate&lt;? super Long&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L867">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L868">            return items.stream().filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, filter);
    }

    /**
     * Creates a float binding with the first element of an observable set after filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return a float binding
     */
    @Nonnull
    public static FloatBinding filterThenFindFirstFloat(@Nonnull final ObservableSet&lt;Float&gt; items, @Nonnull final Float defaultValue, @Nonnull final Predicate&lt;? super Float&gt; filter) {
<span class="fc" id="L883">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L884">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L885">        return createFloatBinding(() -&gt; items.stream().filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a float binding with the first element of an observable set after filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return a float binding
     */
    @Nonnull
    public static FloatBinding filterThenFindFirstFloat(@Nonnull final ObservableSet&lt;Float&gt; items, @Nonnull final Supplier&lt;Float&gt; supplier, @Nonnull final Predicate&lt;? super Float&gt; filter) {
<span class="fc" id="L899">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L900">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L901">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L902">        return createFloatBinding(() -&gt; items.stream().filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a float binding with the first element of an observable set after filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return a float binding
     */
    @Nonnull
    public static FloatBinding filterThenFindFirstFloat(@Nonnull final ObservableSet&lt;Float&gt; items, @Nonnull final Float defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super Float&gt;&gt; filter) {
<span class="fc" id="L916">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L917">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L918">        return createFloatBinding(() -&gt; {</span>
<span class="fc" id="L919">            Predicate&lt;? super Float&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L920">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L921">            return items.stream().filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, filter);
    }

    /**
     * Creates a float binding with the first element of an observable set after filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return a float binding
     */
    @Nonnull
    public static FloatBinding filterThenFindFirstFloat(@Nonnull final ObservableSet&lt;Float&gt; items, @Nonnull final Supplier&lt;Float&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super Float&gt;&gt; filter) {
<span class="fc" id="L936">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L937">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L938">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L939">        return createFloatBinding(() -&gt; {</span>
<span class="fc" id="L940">            Predicate&lt;? super Float&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L941">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L942">            return items.stream().filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, filter);
    }

    /**
     * Creates a double binding with the first element of an observable set after filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return a double binding
     */
    @Nonnull
    public static DoubleBinding filterThenFindFirstDouble(@Nonnull final ObservableSet&lt;Double&gt; items, @Nonnull final Double defaultValue, @Nonnull final Predicate&lt;? super Double&gt; filter) {
<span class="fc" id="L957">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L958">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L959">        return createDoubleBinding(() -&gt; items.stream().filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a double binding with the first element of an observable set after filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return a double binding
     */
    @Nonnull
    public static DoubleBinding filterThenFindFirstDouble(@Nonnull final ObservableSet&lt;Double&gt; items, @Nonnull final Supplier&lt;Double&gt; supplier, @Nonnull final Predicate&lt;? super Double&gt; filter) {
<span class="fc" id="L973">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L974">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L975">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L976">        return createDoubleBinding(() -&gt; items.stream().filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a double binding with the first element of an observable set after filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return a double binding
     */
    @Nonnull
    public static DoubleBinding filterThenFindFirstDouble(@Nonnull final ObservableSet&lt;Double&gt; items, @Nonnull final Double defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super Double&gt;&gt; filter) {
<span class="fc" id="L990">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L991">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L992">        return createDoubleBinding(() -&gt; {</span>
<span class="fc" id="L993">            Predicate&lt;? super Double&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L994">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L995">            return items.stream().filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, filter);
    }

    /**
     * Creates a double binding with the first element of an observable set after filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return a double binding
     */
    @Nonnull
    public static DoubleBinding filterThenFindFirstDouble(@Nonnull final ObservableSet&lt;Double&gt; items, @Nonnull final Supplier&lt;Double&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super Double&gt;&gt; filter) {
<span class="fc" id="L1010">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1011">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1012">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1013">        return createDoubleBinding(() -&gt; {</span>
<span class="fc" id="L1014">            Predicate&lt;? super Double&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L1015">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1016">            return items.stream().filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, filter);
    }

    /**
     * Creates a string binding with the first element of an observable set after filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return a string binding
     */
    @Nonnull
    public static StringBinding filterThenFindFirstString(@Nonnull final ObservableSet&lt;String&gt; items, @Nonnull final String defaultValue, @Nonnull final Predicate&lt;? super String&gt; filter) {
<span class="fc" id="L1031">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1032">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1033">        return createStringBinding(() -&gt; items.stream().filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a string binding with the first element of an observable set after filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return a string binding
     */
    @Nonnull
    public static StringBinding filterThenFindFirstString(@Nonnull final ObservableSet&lt;String&gt; items, @Nonnull final Supplier&lt;String&gt; supplier, @Nonnull final Predicate&lt;? super String&gt; filter) {
<span class="fc" id="L1047">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1048">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1049">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1050">        return createStringBinding(() -&gt; items.stream().filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a string binding with the first element of an observable set after filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element
     *
     * @return a string binding
     */
    @Nonnull
    public static StringBinding filterThenFindFirstString(@Nonnull final ObservableSet&lt;String&gt; items, @Nonnull final String defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super String&gt;&gt; filter) {
<span class="fc" id="L1064">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1065">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1066">        return createStringBinding(() -&gt; {</span>
<span class="fc" id="L1067">            Predicate&lt;? super String&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L1068">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1069">            return items.stream().filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, filter);
    }

    /**
     * Creates a string binding with the first element of an observable set after filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element
     *
     * @return a string binding
     */
    @Nonnull
    public static StringBinding filterThenFindFirstString(@Nonnull final ObservableSet&lt;String&gt; items, @Nonnull final Supplier&lt;String&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super String&gt;&gt; filter) {
<span class="fc" id="L1084">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1085">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1086">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1087">        return createStringBinding(() -&gt; {</span>
<span class="fc" id="L1088">            Predicate&lt;? super String&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L1089">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1090">            return items.stream().filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, filter);
    }

    /**
     * Creates an object binding with the first value of an observable map after filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;K, V&gt; ObjectBinding&lt;V&gt; filterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final V defaultValue, @Nonnull final Predicate&lt;? super V&gt; filter) {
<span class="fc" id="L1105">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1106">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1107">        return createObjectBinding(() -&gt; items.values().stream().filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates an object binding with the first value of an observable map after filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;K, V&gt; ObjectBinding&lt;V&gt; filterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;V&gt; supplier, @Nonnull final Predicate&lt;? super V&gt; filter) {
<span class="fc" id="L1121">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1122">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1123">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1124">        return createObjectBinding(() -&gt; items.values().stream().filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates an object binding with the first value of an observable map after filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;K, V&gt; ObjectBinding&lt;V&gt; filterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final V defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super V&gt;&gt; filter) {
<span class="fc" id="L1138">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1139">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1140">        return createObjectBinding(() -&gt; {</span>
<span class="fc" id="L1141">            Predicate&lt;? super V&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L1142">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1143">            return items.values().stream().filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, filter);
    }

    /**
     * Creates an object binding with the first value of an observable map after filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;K, V&gt; ObjectBinding&lt;V&gt; filterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;V&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super V&gt;&gt; filter) {
<span class="fc" id="L1158">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1159">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1160">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1161">        return createObjectBinding(() -&gt; {</span>
<span class="fc" id="L1162">            Predicate&lt;? super V&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L1163">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1164">            return items.values().stream().filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, filter);
    }

    /**
     * Creates a boolean binding with the first value of an observable map after filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;K&gt; BooleanBinding filterThenFindFirstBoolean(@Nonnull final ObservableMap&lt;K, Boolean&gt; items, @Nonnull final Boolean defaultValue, @Nonnull final Predicate&lt;? super Boolean&gt; filter) {
<span class="fc" id="L1179">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1180">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1181">        return createBooleanBinding(() -&gt; items.values().stream().filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a boolean binding with the first value of an observable map after filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;K&gt; BooleanBinding filterThenFindFirstBoolean(@Nonnull final ObservableMap&lt;K, Boolean&gt; items, @Nonnull final Supplier&lt;Boolean&gt; supplier, @Nonnull final Predicate&lt;? super Boolean&gt; filter) {
<span class="fc" id="L1195">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1196">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1197">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1198">        return createBooleanBinding(() -&gt; items.values().stream().filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a boolean binding with the first value of an observable map after filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;K&gt; BooleanBinding filterThenFindFirstBoolean(@Nonnull final ObservableMap&lt;K, Boolean&gt; items, @Nonnull final Boolean defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super Boolean&gt;&gt; filter) {
<span class="fc" id="L1212">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1213">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1214">        return createBooleanBinding(() -&gt; {</span>
<span class="fc" id="L1215">            Predicate&lt;? super Boolean&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L1216">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1217">            return items.values().stream().filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, filter);
    }

    /**
     * Creates a boolean binding with the first value of an observable map after filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;K&gt; BooleanBinding filterThenFindFirstBoolean(@Nonnull final ObservableMap&lt;K, Boolean&gt; items, @Nonnull final Supplier&lt;Boolean&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super Boolean&gt;&gt; filter) {
<span class="fc" id="L1232">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1233">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1234">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1235">        return createBooleanBinding(() -&gt; {</span>
<span class="fc" id="L1236">            Predicate&lt;? super Boolean&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L1237">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1238">            return items.values().stream().filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, filter);
    }

    /**
     * Creates an integer binding with the first value of an observable map after filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;K&gt; IntegerBinding filterThenFindFirstInteger(@Nonnull final ObservableMap&lt;K, Integer&gt; items, @Nonnull final Integer defaultValue, @Nonnull final Predicate&lt;? super Integer&gt; filter) {
<span class="fc" id="L1253">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1254">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1255">        return createIntegerBinding(() -&gt; items.values().stream().filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates an integer binding with the first value of an observable map after filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;K&gt; IntegerBinding filterThenFindFirstInteger(@Nonnull final ObservableMap&lt;K, Integer&gt; items, @Nonnull final Supplier&lt;Integer&gt; supplier, @Nonnull final Predicate&lt;? super Integer&gt; filter) {
<span class="fc" id="L1269">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1270">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1271">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1272">        return createIntegerBinding(() -&gt; items.values().stream().filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates an integer binding with the first value of an observable map after filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;K&gt; IntegerBinding filterThenFindFirstInteger(@Nonnull final ObservableMap&lt;K, Integer&gt; items, @Nonnull final Integer defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super Integer&gt;&gt; filter) {
<span class="fc" id="L1286">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1287">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1288">        return createIntegerBinding(() -&gt; {</span>
<span class="fc" id="L1289">            Predicate&lt;? super Integer&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L1290">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1291">            return items.values().stream().filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, filter);
    }

    /**
     * Creates an integer binding with the first value of an observable map after filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;K&gt; IntegerBinding filterThenFindFirstInteger(@Nonnull final ObservableMap&lt;K, Integer&gt; items, @Nonnull final Supplier&lt;Integer&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super Integer&gt;&gt; filter) {
<span class="fc" id="L1306">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1307">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1308">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1309">        return createIntegerBinding(() -&gt; {</span>
<span class="fc" id="L1310">            Predicate&lt;? super Integer&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L1311">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1312">            return items.values().stream().filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, filter);
    }

    /**
     * Creates a long binding with the first value of an observable map after filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;K&gt; LongBinding filterThenFindFirstLong(@Nonnull final ObservableMap&lt;K, Long&gt; items, @Nonnull final Long defaultValue, @Nonnull final Predicate&lt;? super Long&gt; filter) {
<span class="fc" id="L1327">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1328">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1329">        return createLongBinding(() -&gt; items.values().stream().filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a long binding with the first value of an observable map after filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;K&gt; LongBinding filterThenFindFirstLong(@Nonnull final ObservableMap&lt;K, Long&gt; items, @Nonnull final Supplier&lt;Long&gt; supplier, @Nonnull final Predicate&lt;? super Long&gt; filter) {
<span class="fc" id="L1343">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1344">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1345">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1346">        return createLongBinding(() -&gt; items.values().stream().filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a long binding with the first value of an observable map after filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;K&gt; LongBinding filterThenFindFirstLong(@Nonnull final ObservableMap&lt;K, Long&gt; items, @Nonnull final Long defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super Long&gt;&gt; filter) {
<span class="fc" id="L1360">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1361">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1362">        return createLongBinding(() -&gt; {</span>
<span class="fc" id="L1363">            Predicate&lt;? super Long&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L1364">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1365">            return items.values().stream().filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, filter);
    }

    /**
     * Creates a long binding with the first value of an observable map after filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;K&gt; LongBinding filterThenFindFirstLong(@Nonnull final ObservableMap&lt;K, Long&gt; items, @Nonnull final Supplier&lt;Long&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super Long&gt;&gt; filter) {
<span class="fc" id="L1380">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1381">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1382">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1383">        return createLongBinding(() -&gt; {</span>
<span class="fc" id="L1384">            Predicate&lt;? super Long&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L1385">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1386">            return items.values().stream().filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, filter);
    }

    /**
     * Creates a float binding with the first value of an observable map after filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;K&gt; FloatBinding filterThenFindFirstFloat(@Nonnull final ObservableMap&lt;K, Float&gt; items, @Nonnull final Float defaultValue, @Nonnull final Predicate&lt;? super Float&gt; filter) {
<span class="fc" id="L1401">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1402">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1403">        return createFloatBinding(() -&gt; items.values().stream().filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a float binding with the first value of an observable map after filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;K&gt; FloatBinding filterThenFindFirstFloat(@Nonnull final ObservableMap&lt;K, Float&gt; items, @Nonnull final Supplier&lt;Float&gt; supplier, @Nonnull final Predicate&lt;? super Float&gt; filter) {
<span class="fc" id="L1417">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1418">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1419">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1420">        return createFloatBinding(() -&gt; items.values().stream().filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a float binding with the first value of an observable map after filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;K&gt; FloatBinding filterThenFindFirstFloat(@Nonnull final ObservableMap&lt;K, Float&gt; items, @Nonnull final Float defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super Float&gt;&gt; filter) {
<span class="fc" id="L1434">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1435">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1436">        return createFloatBinding(() -&gt; {</span>
<span class="fc" id="L1437">            Predicate&lt;? super Float&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L1438">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1439">            return items.values().stream().filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, filter);
    }

    /**
     * Creates a float binding with the first value of an observable map after filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;K&gt; FloatBinding filterThenFindFirstFloat(@Nonnull final ObservableMap&lt;K, Float&gt; items, @Nonnull final Supplier&lt;Float&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super Float&gt;&gt; filter) {
<span class="fc" id="L1454">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1455">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1456">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1457">        return createFloatBinding(() -&gt; {</span>
<span class="fc" id="L1458">            Predicate&lt;? super Float&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L1459">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1460">            return items.values().stream().filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, filter);
    }

    /**
     * Creates a double binding with the first value of an observable map after filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;K&gt; DoubleBinding filterThenFindFirstDouble(@Nonnull final ObservableMap&lt;K, Double&gt; items, @Nonnull final Double defaultValue, @Nonnull final Predicate&lt;? super Double&gt; filter) {
<span class="fc" id="L1475">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1476">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1477">        return createDoubleBinding(() -&gt; items.values().stream().filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a double binding with the first value of an observable map after filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;K&gt; DoubleBinding filterThenFindFirstDouble(@Nonnull final ObservableMap&lt;K, Double&gt; items, @Nonnull final Supplier&lt;Double&gt; supplier, @Nonnull final Predicate&lt;? super Double&gt; filter) {
<span class="fc" id="L1491">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1492">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1493">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1494">        return createDoubleBinding(() -&gt; items.values().stream().filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a double binding with the first value of an observable map after filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;K&gt; DoubleBinding filterThenFindFirstDouble(@Nonnull final ObservableMap&lt;K, Double&gt; items, @Nonnull final Double defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super Double&gt;&gt; filter) {
<span class="fc" id="L1508">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1509">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1510">        return createDoubleBinding(() -&gt; {</span>
<span class="fc" id="L1511">            Predicate&lt;? super Double&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L1512">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1513">            return items.values().stream().filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, filter);
    }

    /**
     * Creates a double binding with the first value of an observable map after filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;K&gt; DoubleBinding filterThenFindFirstDouble(@Nonnull final ObservableMap&lt;K, Double&gt; items, @Nonnull final Supplier&lt;Double&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super Double&gt;&gt; filter) {
<span class="fc" id="L1528">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1529">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1530">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1531">        return createDoubleBinding(() -&gt; {</span>
<span class="fc" id="L1532">            Predicate&lt;? super Double&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L1533">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1534">            return items.values().stream().filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, filter);
    }

    /**
     * Creates a string binding with the first value of an observable map after filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;K&gt; StringBinding filterThenFindFirstString(@Nonnull final ObservableMap&lt;K, String&gt; items, @Nonnull final String defaultValue, @Nonnull final Predicate&lt;? super String&gt; filter) {
<span class="fc" id="L1549">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1550">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1551">        return createStringBinding(() -&gt; items.values().stream().filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a string binding with the first value of an observable map after filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;K&gt; StringBinding filterThenFindFirstString(@Nonnull final ObservableMap&lt;K, String&gt; items, @Nonnull final Supplier&lt;String&gt; supplier, @Nonnull final Predicate&lt;? super String&gt; filter) {
<span class="fc" id="L1565">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1566">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1567">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1568">        return createStringBinding(() -&gt; items.values().stream().filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a string binding with the first value of an observable map after filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;K&gt; StringBinding filterThenFindFirstString(@Nonnull final ObservableMap&lt;K, String&gt; items, @Nonnull final String defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super String&gt;&gt; filter) {
<span class="fc" id="L1582">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1583">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1584">        return createStringBinding(() -&gt; {</span>
<span class="fc" id="L1585">            Predicate&lt;? super String&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L1586">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1587">            return items.values().stream().filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, filter);
    }

    /**
     * Creates a string binding with the first value of an observable map after filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;K&gt; StringBinding filterThenFindFirstString(@Nonnull final ObservableMap&lt;K, String&gt; items, @Nonnull final Supplier&lt;String&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super String&gt;&gt; filter) {
<span class="fc" id="L1602">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1603">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1604">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1605">        return createStringBinding(() -&gt; {</span>
<span class="fc" id="L1606">            Predicate&lt;? super String&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L1607">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1608">            return items.values().stream().filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, filter);
    }

    /**
     * Creates an object binding with the first element of an observable list after mapping and filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;T, R&gt; ObjectBinding&lt;R&gt; mapThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final R defaultValue, @Nonnull final Function&lt;? super T, R&gt; mapper, @Nonnull final Predicate&lt;? super R&gt; filter) {
<span class="fc" id="L1624">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1625">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1626">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1627">        return createObjectBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates an object binding with the first element of an observable list after mapping and filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;T, R&gt; ObjectBinding&lt;R&gt; mapThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;R&gt; supplier, @Nonnull final Function&lt;? super T, R&gt; mapper, @Nonnull final Predicate&lt;? super R&gt; filter) {
<span class="fc" id="L1642">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1643">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1644">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1645">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1646">        return createObjectBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates an object binding with the first element of an observable list after mapping and filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;T, R&gt; ObjectBinding&lt;R&gt; mapThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final R defaultValue, @Nonnull final ObservableValue&lt;Function&lt;? super T, R&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;? super R&gt;&gt; filter) {
<span class="fc" id="L1661">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1662">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1663">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1664">        return createObjectBinding(() -&gt; {</span>
<span class="fc" id="L1665">            Function&lt;? super T, R&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L1666">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1667">            Predicate&lt;? super R&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L1668">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1669">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates an object binding with the first element of an observable list after mapping and filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;T, R&gt; ObjectBinding&lt;R&gt; mapThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;R&gt; supplier, @Nonnull final ObservableValue&lt;Function&lt;? super T, R&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;? super R&gt;&gt; filter) {
<span class="fc" id="L1685">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1686">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1687">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1688">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1689">        return createObjectBinding(() -&gt; {</span>
<span class="fc" id="L1690">            Function&lt;? super T, R&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L1691">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1692">            Predicate&lt;? super R&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L1693">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1694">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a boolean binding with the first element of an observable list after mapping and filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;T&gt; BooleanBinding mapToBooleanThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Boolean defaultValue, @Nonnull final Function&lt;? super T, Boolean&gt; mapper, @Nonnull final Predicate&lt;Boolean&gt; filter) {
<span class="fc" id="L1710">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1711">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1712">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1713">        return createBooleanBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a boolean binding with the first element of an observable list after mapping and filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;T&gt; BooleanBinding mapToBooleanThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;Boolean&gt; supplier, @Nonnull final Function&lt;? super T, Boolean&gt; mapper, @Nonnull final Predicate&lt;Boolean&gt; filter) {
<span class="fc" id="L1728">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1729">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1730">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1731">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1732">        return createBooleanBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a boolean binding with the first element of an observable list after mapping and filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;T&gt; BooleanBinding mapToBooleanThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Boolean defaultValue, @Nonnull final ObservableValue&lt;Function&lt;? super T, Boolean&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Boolean&gt;&gt; filter) {
<span class="fc" id="L1747">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1748">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1749">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1750">        return createBooleanBinding(() -&gt; {</span>
<span class="fc" id="L1751">            Function&lt;? super T, Boolean&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L1752">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1753">            Predicate&lt;Boolean&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L1754">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1755">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a boolean binding with the first element of an observable list after mapping and filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;T&gt; BooleanBinding mapToBooleanThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;Boolean&gt; supplier, @Nonnull final ObservableValue&lt;Function&lt;? super T, Boolean&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Boolean&gt;&gt; filter) {
<span class="fc" id="L1771">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1772">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1773">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1774">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1775">        return createBooleanBinding(() -&gt; {</span>
<span class="fc" id="L1776">            Function&lt;? super T, Boolean&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L1777">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1778">            Predicate&lt;Boolean&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L1779">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1780">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates an integer binding with the first element of an observable list after mapping and filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;T&gt; IntegerBinding mapToIntegerThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Integer defaultValue, @Nonnull final Function&lt;? super T, Integer&gt; mapper, @Nonnull final Predicate&lt;Integer&gt; filter) {
<span class="fc" id="L1796">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1797">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1798">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1799">        return createIntegerBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates an integer binding with the first element of an observable list after mapping and filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;T&gt; IntegerBinding mapToIntegerThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;Integer&gt; supplier, @Nonnull final Function&lt;? super T, Integer&gt; mapper, @Nonnull final Predicate&lt;Integer&gt; filter) {
<span class="fc" id="L1814">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1815">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1816">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1817">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1818">        return createIntegerBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates an integer binding with the first element of an observable list after mapping and filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;T&gt; IntegerBinding mapToIntegerThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Integer defaultValue, @Nonnull final ObservableValue&lt;Function&lt;? super T, Integer&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Integer&gt;&gt; filter) {
<span class="fc" id="L1833">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1834">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1835">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1836">        return createIntegerBinding(() -&gt; {</span>
<span class="fc" id="L1837">            Function&lt;? super T, Integer&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L1838">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1839">            Predicate&lt;Integer&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L1840">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1841">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates an integer binding with the first element of an observable list after mapping and filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;T&gt; IntegerBinding mapToIntegerThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;Integer&gt; supplier, @Nonnull final ObservableValue&lt;Function&lt;? super T, Integer&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Integer&gt;&gt; filter) {
<span class="fc" id="L1857">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1858">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1859">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1860">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1861">        return createIntegerBinding(() -&gt; {</span>
<span class="fc" id="L1862">            Function&lt;? super T, Integer&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L1863">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1864">            Predicate&lt;Integer&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L1865">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1866">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a long binding with the first element of an observable list after mapping and filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;T&gt; LongBinding mapToLongThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Long defaultValue, @Nonnull final Function&lt;? super T, Long&gt; mapper, @Nonnull final Predicate&lt;Long&gt; filter) {
<span class="fc" id="L1882">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1883">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1884">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1885">        return createLongBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a long binding with the first element of an observable list after mapping and filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;T&gt; LongBinding mapToLongThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;Long&gt; supplier, @Nonnull final Function&lt;? super T, Long&gt; mapper, @Nonnull final Predicate&lt;Long&gt; filter) {
<span class="fc" id="L1900">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1901">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1902">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1903">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1904">        return createLongBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a long binding with the first element of an observable list after mapping and filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;T&gt; LongBinding mapToLongThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Long defaultValue, @Nonnull final ObservableValue&lt;Function&lt;? super T, Long&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Long&gt;&gt; filter) {
<span class="fc" id="L1919">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1920">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1921">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1922">        return createLongBinding(() -&gt; {</span>
<span class="fc" id="L1923">            Function&lt;? super T, Long&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L1924">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1925">            Predicate&lt;Long&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L1926">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1927">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a long binding with the first element of an observable list after mapping and filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;T&gt; LongBinding mapToLongThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;Long&gt; supplier, @Nonnull final ObservableValue&lt;Function&lt;? super T, Long&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Long&gt;&gt; filter) {
<span class="fc" id="L1943">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1944">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1945">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1946">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1947">        return createLongBinding(() -&gt; {</span>
<span class="fc" id="L1948">            Function&lt;? super T, Long&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L1949">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1950">            Predicate&lt;Long&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L1951">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1952">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a float binding with the first element of an observable list after mapping and filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;T&gt; FloatBinding mapToFloatThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Float defaultValue, @Nonnull final Function&lt;? super T, Float&gt; mapper, @Nonnull final Predicate&lt;Float&gt; filter) {
<span class="fc" id="L1968">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1969">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1970">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1971">        return createFloatBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a float binding with the first element of an observable list after mapping and filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;T&gt; FloatBinding mapToFloatThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;Float&gt; supplier, @Nonnull final Function&lt;? super T, Float&gt; mapper, @Nonnull final Predicate&lt;Float&gt; filter) {
<span class="fc" id="L1986">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L1987">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L1988">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L1989">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L1990">        return createFloatBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a float binding with the first element of an observable list after mapping and filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;T&gt; FloatBinding mapToFloatThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Float defaultValue, @Nonnull final ObservableValue&lt;Function&lt;? super T, Float&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Float&gt;&gt; filter) {
<span class="fc" id="L2005">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2006">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2007">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2008">        return createFloatBinding(() -&gt; {</span>
<span class="fc" id="L2009">            Function&lt;? super T, Float&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L2010">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2011">            Predicate&lt;Float&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L2012">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2013">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a float binding with the first element of an observable list after mapping and filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;T&gt; FloatBinding mapToFloatThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;Float&gt; supplier, @Nonnull final ObservableValue&lt;Function&lt;? super T, Float&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Float&gt;&gt; filter) {
<span class="fc" id="L2029">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2030">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L2031">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2032">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2033">        return createFloatBinding(() -&gt; {</span>
<span class="fc" id="L2034">            Function&lt;? super T, Float&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L2035">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2036">            Predicate&lt;Float&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L2037">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2038">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a double binding with the first element of an observable list after mapping and filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;T&gt; DoubleBinding mapToDoubleThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Double defaultValue, @Nonnull final Function&lt;? super T, Double&gt; mapper, @Nonnull final Predicate&lt;Double&gt; filter) {
<span class="fc" id="L2054">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2055">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2056">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2057">        return createDoubleBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a double binding with the first element of an observable list after mapping and filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;T&gt; DoubleBinding mapToDoubleThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;Double&gt; supplier, @Nonnull final Function&lt;? super T, Double&gt; mapper, @Nonnull final Predicate&lt;Double&gt; filter) {
<span class="fc" id="L2072">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2073">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L2074">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2075">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2076">        return createDoubleBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a double binding with the first element of an observable list after mapping and filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;T&gt; DoubleBinding mapToDoubleThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Double defaultValue, @Nonnull final ObservableValue&lt;Function&lt;? super T, Double&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Double&gt;&gt; filter) {
<span class="fc" id="L2091">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2092">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2093">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2094">        return createDoubleBinding(() -&gt; {</span>
<span class="fc" id="L2095">            Function&lt;? super T, Double&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L2096">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2097">            Predicate&lt;Double&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L2098">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2099">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a double binding with the first element of an observable list after mapping and filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;T&gt; DoubleBinding mapToDoubleThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;Double&gt; supplier, @Nonnull final ObservableValue&lt;Function&lt;? super T, Double&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Double&gt;&gt; filter) {
<span class="fc" id="L2115">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2116">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L2117">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2118">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2119">        return createDoubleBinding(() -&gt; {</span>
<span class="fc" id="L2120">            Function&lt;? super T, Double&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L2121">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2122">            Predicate&lt;Double&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L2123">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2124">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a string binding with the first element of an observable list after mapping and filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;T&gt; StringBinding mapToStringThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final String defaultValue, @Nonnull final Function&lt;? super T, String&gt; mapper, @Nonnull final Predicate&lt;String&gt; filter) {
<span class="fc" id="L2140">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2141">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2142">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2143">        return createStringBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a string binding with the first element of an observable list after mapping and filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;T&gt; StringBinding mapToStringThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;String&gt; supplier, @Nonnull final Function&lt;? super T, String&gt; mapper, @Nonnull final Predicate&lt;String&gt; filter) {
<span class="fc" id="L2158">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2159">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L2160">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2161">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2162">        return createStringBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a string binding with the first element of an observable list after mapping and filtering.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;T&gt; StringBinding mapToStringThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final String defaultValue, @Nonnull final ObservableValue&lt;Function&lt;? super T, String&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;String&gt;&gt; filter) {
<span class="fc" id="L2177">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2178">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2179">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2180">        return createStringBinding(() -&gt; {</span>
<span class="fc" id="L2181">            Function&lt;? super T, String&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L2182">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2183">            Predicate&lt;String&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L2184">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2185">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a string binding with the first element of an observable list after mapping and filtering.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;T&gt; StringBinding mapToStringThenFilterThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;String&gt; supplier, @Nonnull final ObservableValue&lt;Function&lt;? super T, String&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;String&gt;&gt; filter) {
<span class="fc" id="L2201">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2202">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L2203">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2204">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2205">        return createStringBinding(() -&gt; {</span>
<span class="fc" id="L2206">            Function&lt;? super T, String&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L2207">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2208">            Predicate&lt;String&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L2209">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2210">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates an object binding with the first element of an observable set after mapping and filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;T, R&gt; ObjectBinding&lt;R&gt; mapThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final R defaultValue, @Nonnull final Function&lt;? super T, R&gt; mapper, @Nonnull final Predicate&lt;? super R&gt; filter) {
<span class="fc" id="L2226">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2227">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2228">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2229">        return createObjectBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates an object binding with the first element of an observable set after mapping and filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;T, R&gt; ObjectBinding&lt;R&gt; mapThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;R&gt; supplier, @Nonnull final Function&lt;? super T, R&gt; mapper, @Nonnull final Predicate&lt;? super R&gt; filter) {
<span class="fc" id="L2244">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2245">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L2246">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2247">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2248">        return createObjectBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates an object binding with the first element of an observable set after mapping and filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;T, R&gt; ObjectBinding&lt;R&gt; mapThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final R defaultValue, @Nonnull final ObservableValue&lt;Function&lt;? super T, R&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;? super R&gt;&gt; filter) {
<span class="fc" id="L2263">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2264">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2265">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2266">        return createObjectBinding(() -&gt; {</span>
<span class="fc" id="L2267">            Function&lt;? super T, R&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L2268">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2269">            Predicate&lt;? super R&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L2270">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2271">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates an object binding with the first element of an observable set after mapping and filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;T, R&gt; ObjectBinding&lt;R&gt; mapThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;R&gt; supplier, @Nonnull final ObservableValue&lt;Function&lt;? super T, R&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;? super R&gt;&gt; filter) {
<span class="fc" id="L2287">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2288">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L2289">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2290">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2291">        return createObjectBinding(() -&gt; {</span>
<span class="fc" id="L2292">            Function&lt;? super T, R&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L2293">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2294">            Predicate&lt;? super R&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L2295">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2296">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a boolean binding with the first element of an observable set after mapping and filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;T&gt; BooleanBinding mapToBooleanThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Boolean defaultValue, @Nonnull final Function&lt;? super T, Boolean&gt; mapper, @Nonnull final Predicate&lt;Boolean&gt; filter) {
<span class="fc" id="L2312">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2313">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2314">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2315">        return createBooleanBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a boolean binding with the first element of an observable set after mapping and filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;T&gt; BooleanBinding mapToBooleanThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;Boolean&gt; supplier, @Nonnull final Function&lt;? super T, Boolean&gt; mapper, @Nonnull final Predicate&lt;Boolean&gt; filter) {
<span class="fc" id="L2330">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2331">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L2332">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2333">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2334">        return createBooleanBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a boolean binding with the first element of an observable set after mapping and filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;T&gt; BooleanBinding mapToBooleanThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Boolean defaultValue, @Nonnull final ObservableValue&lt;Function&lt;? super T, Boolean&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Boolean&gt;&gt; filter) {
<span class="fc" id="L2349">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2350">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2351">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2352">        return createBooleanBinding(() -&gt; {</span>
<span class="fc" id="L2353">            Function&lt;? super T, Boolean&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L2354">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2355">            Predicate&lt;Boolean&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L2356">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2357">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a boolean binding with the first element of an observable set after mapping and filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;T&gt; BooleanBinding mapToBooleanThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;Boolean&gt; supplier, @Nonnull final ObservableValue&lt;Function&lt;? super T, Boolean&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Boolean&gt;&gt; filter) {
<span class="fc" id="L2373">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2374">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L2375">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2376">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2377">        return createBooleanBinding(() -&gt; {</span>
<span class="fc" id="L2378">            Function&lt;? super T, Boolean&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L2379">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2380">            Predicate&lt;Boolean&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L2381">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2382">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates an integer binding with the first element of an observable set after mapping and filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;T&gt; IntegerBinding mapToIntegerThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Integer defaultValue, @Nonnull final Function&lt;? super T, Integer&gt; mapper, @Nonnull final Predicate&lt;Integer&gt; filter) {
<span class="fc" id="L2398">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2399">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2400">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2401">        return createIntegerBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates an integer binding with the first element of an observable set after mapping and filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;T&gt; IntegerBinding mapToIntegerThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;Integer&gt; supplier, @Nonnull final Function&lt;? super T, Integer&gt; mapper, @Nonnull final Predicate&lt;Integer&gt; filter) {
<span class="fc" id="L2416">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2417">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L2418">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2419">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2420">        return createIntegerBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates an integer binding with the first element of an observable set after mapping and filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;T&gt; IntegerBinding mapToIntegerThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Integer defaultValue, @Nonnull final ObservableValue&lt;Function&lt;? super T, Integer&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Integer&gt;&gt; filter) {
<span class="fc" id="L2435">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2436">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2437">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2438">        return createIntegerBinding(() -&gt; {</span>
<span class="fc" id="L2439">            Function&lt;? super T, Integer&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L2440">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2441">            Predicate&lt;Integer&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L2442">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2443">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates an integer binding with the first element of an observable set after mapping and filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;T&gt; IntegerBinding mapToIntegerThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;Integer&gt; supplier, @Nonnull final ObservableValue&lt;Function&lt;? super T, Integer&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Integer&gt;&gt; filter) {
<span class="fc" id="L2459">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2460">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L2461">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2462">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2463">        return createIntegerBinding(() -&gt; {</span>
<span class="fc" id="L2464">            Function&lt;? super T, Integer&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L2465">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2466">            Predicate&lt;Integer&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L2467">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2468">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a long binding with the first element of an observable set after mapping and filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;T&gt; LongBinding mapToLongThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Long defaultValue, @Nonnull final Function&lt;? super T, Long&gt; mapper, @Nonnull final Predicate&lt;Long&gt; filter) {
<span class="fc" id="L2484">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2485">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2486">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2487">        return createLongBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a long binding with the first element of an observable set after mapping and filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;T&gt; LongBinding mapToLongThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;Long&gt; supplier, @Nonnull final Function&lt;? super T, Long&gt; mapper, @Nonnull final Predicate&lt;Long&gt; filter) {
<span class="fc" id="L2502">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2503">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L2504">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2505">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2506">        return createLongBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a long binding with the first element of an observable set after mapping and filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;T&gt; LongBinding mapToLongThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Long defaultValue, @Nonnull final ObservableValue&lt;Function&lt;? super T, Long&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Long&gt;&gt; filter) {
<span class="fc" id="L2521">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2522">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2523">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2524">        return createLongBinding(() -&gt; {</span>
<span class="fc" id="L2525">            Function&lt;? super T, Long&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L2526">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2527">            Predicate&lt;Long&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L2528">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2529">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a long binding with the first element of an observable set after mapping and filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;T&gt; LongBinding mapToLongThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;Long&gt; supplier, @Nonnull final ObservableValue&lt;Function&lt;? super T, Long&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Long&gt;&gt; filter) {
<span class="fc" id="L2545">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2546">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L2547">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2548">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2549">        return createLongBinding(() -&gt; {</span>
<span class="fc" id="L2550">            Function&lt;? super T, Long&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L2551">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2552">            Predicate&lt;Long&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L2553">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2554">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a float binding with the first element of an observable set after mapping and filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;T&gt; FloatBinding mapToFloatThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Float defaultValue, @Nonnull final Function&lt;? super T, Float&gt; mapper, @Nonnull final Predicate&lt;Float&gt; filter) {
<span class="fc" id="L2570">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2571">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2572">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2573">        return createFloatBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a float binding with the first element of an observable set after mapping and filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;T&gt; FloatBinding mapToFloatThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;Float&gt; supplier, @Nonnull final Function&lt;? super T, Float&gt; mapper, @Nonnull final Predicate&lt;Float&gt; filter) {
<span class="fc" id="L2588">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2589">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L2590">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2591">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2592">        return createFloatBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a float binding with the first element of an observable set after mapping and filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;T&gt; FloatBinding mapToFloatThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Float defaultValue, @Nonnull final ObservableValue&lt;Function&lt;? super T, Float&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Float&gt;&gt; filter) {
<span class="fc" id="L2607">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2608">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2609">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2610">        return createFloatBinding(() -&gt; {</span>
<span class="fc" id="L2611">            Function&lt;? super T, Float&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L2612">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2613">            Predicate&lt;Float&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L2614">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2615">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a float binding with the first element of an observable set after mapping and filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;T&gt; FloatBinding mapToFloatThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;Float&gt; supplier, @Nonnull final ObservableValue&lt;Function&lt;? super T, Float&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Float&gt;&gt; filter) {
<span class="fc" id="L2631">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2632">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L2633">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2634">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2635">        return createFloatBinding(() -&gt; {</span>
<span class="fc" id="L2636">            Function&lt;? super T, Float&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L2637">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2638">            Predicate&lt;Float&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L2639">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2640">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a double binding with the first element of an observable set after mapping and filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;T&gt; DoubleBinding mapToDoubleThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Double defaultValue, @Nonnull final Function&lt;? super T, Double&gt; mapper, @Nonnull final Predicate&lt;Double&gt; filter) {
<span class="fc" id="L2656">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2657">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2658">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2659">        return createDoubleBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a double binding with the first element of an observable set after mapping and filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;T&gt; DoubleBinding mapToDoubleThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;Double&gt; supplier, @Nonnull final Function&lt;? super T, Double&gt; mapper, @Nonnull final Predicate&lt;Double&gt; filter) {
<span class="fc" id="L2674">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2675">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L2676">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2677">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2678">        return createDoubleBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a double binding with the first element of an observable set after mapping and filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;T&gt; DoubleBinding mapToDoubleThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Double defaultValue, @Nonnull final ObservableValue&lt;Function&lt;? super T, Double&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Double&gt;&gt; filter) {
<span class="fc" id="L2693">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2694">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2695">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2696">        return createDoubleBinding(() -&gt; {</span>
<span class="fc" id="L2697">            Function&lt;? super T, Double&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L2698">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2699">            Predicate&lt;Double&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L2700">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2701">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a double binding with the first element of an observable set after mapping and filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;T&gt; DoubleBinding mapToDoubleThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;Double&gt; supplier, @Nonnull final ObservableValue&lt;Function&lt;? super T, Double&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Double&gt;&gt; filter) {
<span class="fc" id="L2717">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2718">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L2719">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2720">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2721">        return createDoubleBinding(() -&gt; {</span>
<span class="fc" id="L2722">            Function&lt;? super T, Double&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L2723">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2724">            Predicate&lt;Double&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L2725">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2726">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a string binding with the first element of an observable set after mapping and filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;T&gt; StringBinding mapToStringThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final String defaultValue, @Nonnull final Function&lt;? super T, String&gt; mapper, @Nonnull final Predicate&lt;String&gt; filter) {
<span class="fc" id="L2742">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2743">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2744">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2745">        return createStringBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a string binding with the first element of an observable set after mapping and filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;T&gt; StringBinding mapToStringThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;String&gt; supplier, @Nonnull final Function&lt;? super T, String&gt; mapper, @Nonnull final Predicate&lt;String&gt; filter) {
<span class="fc" id="L2760">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2761">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L2762">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2763">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2764">        return createStringBinding(() -&gt; items.stream().map(mapper).filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a string binding with the first element of an observable set after mapping and filtering.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;T&gt; StringBinding mapToStringThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final String defaultValue, @Nonnull final ObservableValue&lt;Function&lt;? super T, String&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;String&gt;&gt; filter) {
<span class="fc" id="L2779">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2780">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2781">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2782">        return createStringBinding(() -&gt; {</span>
<span class="fc" id="L2783">            Function&lt;? super T, String&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L2784">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2785">            Predicate&lt;String&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L2786">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2787">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a string binding with the first element of an observable set after mapping and filtering.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each element before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each element after mapping.
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;T&gt; StringBinding mapToStringThenFilterThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;String&gt; supplier, @Nonnull final ObservableValue&lt;Function&lt;? super T, String&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;String&gt;&gt; filter) {
<span class="fc" id="L2803">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2804">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L2805">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2806">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2807">        return createStringBinding(() -&gt; {</span>
<span class="fc" id="L2808">            Function&lt;? super T, String&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L2809">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2810">            Predicate&lt;String&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L2811">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2812">            return items.stream().map(mapperValue).filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates an object binding with the first value of an observable map after mapping and filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;K, V, R&gt; ObjectBinding&lt;R&gt; mapThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final R defaultValue, @Nonnull final Function&lt;? super V, R&gt; mapper, @Nonnull final Predicate&lt;? super R&gt; filter) {
<span class="fc" id="L2828">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2829">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2830">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2831">        return createObjectBinding(() -&gt; items.values().stream().map(mapper).filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates an object binding with the first value of an observable map after mapping and filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;K, V, R&gt; ObjectBinding&lt;R&gt; mapThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;R&gt; supplier, @Nonnull final Function&lt;? super V, R&gt; mapper, @Nonnull final Predicate&lt;? super R&gt; filter) {
<span class="fc" id="L2846">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2847">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L2848">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2849">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2850">        return createObjectBinding(() -&gt; items.values().stream().map(mapper).filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates an object binding with the first value of an observable map after mapping and filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;K, V, R&gt; ObjectBinding&lt;R&gt; mapThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final R defaultValue, @Nonnull final ObservableValue&lt;Function&lt;? super V, R&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;? super R&gt;&gt; filter) {
<span class="fc" id="L2865">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2866">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2867">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2868">        return createObjectBinding(() -&gt; {</span>
<span class="fc" id="L2869">            Function&lt;? super V, R&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L2870">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2871">            Predicate&lt;? super R&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L2872">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2873">            return items.values().stream().map(mapperValue).filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates an object binding with the first value of an observable map after mapping and filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;K, V, R&gt; ObjectBinding&lt;R&gt; mapThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;R&gt; supplier, @Nonnull final ObservableValue&lt;Function&lt;? super V, R&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;? super R&gt;&gt; filter) {
<span class="fc" id="L2889">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2890">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L2891">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2892">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2893">        return createObjectBinding(() -&gt; {</span>
<span class="fc" id="L2894">            Function&lt;? super V, R&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L2895">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2896">            Predicate&lt;? super R&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L2897">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2898">            return items.values().stream().map(mapperValue).filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a boolean binding with the first value of an observable map after mapping and filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;K, V&gt; BooleanBinding mapToBooleanThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Boolean defaultValue, @Nonnull final Function&lt;? super V, Boolean&gt; mapper, @Nonnull final Predicate&lt;Boolean&gt; filter) {
<span class="fc" id="L2914">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2915">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2916">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2917">        return createBooleanBinding(() -&gt; items.values().stream().map(mapper).filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a boolean binding with the first value of an observable map after mapping and filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;K, V&gt; BooleanBinding mapToBooleanThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;Boolean&gt; supplier, @Nonnull final Function&lt;? super V, Boolean&gt; mapper, @Nonnull final Predicate&lt;Boolean&gt; filter) {
<span class="fc" id="L2932">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2933">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L2934">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2935">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2936">        return createBooleanBinding(() -&gt; items.values().stream().map(mapper).filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a boolean binding with the first value of an observable map after mapping and filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;K, V&gt; BooleanBinding mapToBooleanThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Boolean defaultValue, @Nonnull final ObservableValue&lt;Function&lt;? super V, Boolean&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Boolean&gt;&gt; filter) {
<span class="fc" id="L2951">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2952">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2953">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2954">        return createBooleanBinding(() -&gt; {</span>
<span class="fc" id="L2955">            Function&lt;? super V, Boolean&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L2956">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2957">            Predicate&lt;Boolean&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L2958">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2959">            return items.values().stream().map(mapperValue).filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a boolean binding with the first value of an observable map after mapping and filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;K, V&gt; BooleanBinding mapToBooleanThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;Boolean&gt; supplier, @Nonnull final ObservableValue&lt;Function&lt;? super V, Boolean&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Boolean&gt;&gt; filter) {
<span class="fc" id="L2975">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L2976">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L2977">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2978">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2979">        return createBooleanBinding(() -&gt; {</span>
<span class="fc" id="L2980">            Function&lt;? super V, Boolean&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L2981">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L2982">            Predicate&lt;Boolean&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L2983">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L2984">            return items.values().stream().map(mapperValue).filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates an integer binding with the first value of an observable map after mapping and filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;K, V&gt; IntegerBinding mapToIntegerThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Integer defaultValue, @Nonnull final Function&lt;? super V, Integer&gt; mapper, @Nonnull final Predicate&lt;Integer&gt; filter) {
<span class="fc" id="L3000">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3001">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3002">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3003">        return createIntegerBinding(() -&gt; items.values().stream().map(mapper).filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates an integer binding with the first value of an observable map after mapping and filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;K, V&gt; IntegerBinding mapToIntegerThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;Integer&gt; supplier, @Nonnull final Function&lt;? super V, Integer&gt; mapper, @Nonnull final Predicate&lt;Integer&gt; filter) {
<span class="fc" id="L3018">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3019">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L3020">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3021">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3022">        return createIntegerBinding(() -&gt; items.values().stream().map(mapper).filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates an integer binding with the first value of an observable map after mapping and filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;K, V&gt; IntegerBinding mapToIntegerThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Integer defaultValue, @Nonnull final ObservableValue&lt;Function&lt;? super V, Integer&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Integer&gt;&gt; filter) {
<span class="fc" id="L3037">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3038">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3039">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3040">        return createIntegerBinding(() -&gt; {</span>
<span class="fc" id="L3041">            Function&lt;? super V, Integer&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L3042">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3043">            Predicate&lt;Integer&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L3044">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3045">            return items.values().stream().map(mapperValue).filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates an integer binding with the first value of an observable map after mapping and filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;K, V&gt; IntegerBinding mapToIntegerThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;Integer&gt; supplier, @Nonnull final ObservableValue&lt;Function&lt;? super V, Integer&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Integer&gt;&gt; filter) {
<span class="fc" id="L3061">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3062">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L3063">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3064">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3065">        return createIntegerBinding(() -&gt; {</span>
<span class="fc" id="L3066">            Function&lt;? super V, Integer&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L3067">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3068">            Predicate&lt;Integer&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L3069">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3070">            return items.values().stream().map(mapperValue).filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a long binding with the first value of an observable map after mapping and filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;K, V&gt; LongBinding mapToLongThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Long defaultValue, @Nonnull final Function&lt;? super V, Long&gt; mapper, @Nonnull final Predicate&lt;Long&gt; filter) {
<span class="fc" id="L3086">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3087">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3088">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3089">        return createLongBinding(() -&gt; items.values().stream().map(mapper).filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a long binding with the first value of an observable map after mapping and filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;K, V&gt; LongBinding mapToLongThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;Long&gt; supplier, @Nonnull final Function&lt;? super V, Long&gt; mapper, @Nonnull final Predicate&lt;Long&gt; filter) {
<span class="fc" id="L3104">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3105">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L3106">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3107">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3108">        return createLongBinding(() -&gt; items.values().stream().map(mapper).filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a long binding with the first value of an observable map after mapping and filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;K, V&gt; LongBinding mapToLongThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Long defaultValue, @Nonnull final ObservableValue&lt;Function&lt;? super V, Long&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Long&gt;&gt; filter) {
<span class="fc" id="L3123">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3124">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3125">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3126">        return createLongBinding(() -&gt; {</span>
<span class="fc" id="L3127">            Function&lt;? super V, Long&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L3128">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3129">            Predicate&lt;Long&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L3130">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3131">            return items.values().stream().map(mapperValue).filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a long binding with the first value of an observable map after mapping and filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;K, V&gt; LongBinding mapToLongThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;Long&gt; supplier, @Nonnull final ObservableValue&lt;Function&lt;? super V, Long&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Long&gt;&gt; filter) {
<span class="fc" id="L3147">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3148">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L3149">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3150">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3151">        return createLongBinding(() -&gt; {</span>
<span class="fc" id="L3152">            Function&lt;? super V, Long&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L3153">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3154">            Predicate&lt;Long&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L3155">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3156">            return items.values().stream().map(mapperValue).filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a float binding with the first value of an observable map after mapping and filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;K, V&gt; FloatBinding mapToFloatThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Float defaultValue, @Nonnull final Function&lt;? super V, Float&gt; mapper, @Nonnull final Predicate&lt;Float&gt; filter) {
<span class="fc" id="L3172">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3173">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3174">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3175">        return createFloatBinding(() -&gt; items.values().stream().map(mapper).filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a float binding with the first value of an observable map after mapping and filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;K, V&gt; FloatBinding mapToFloatThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;Float&gt; supplier, @Nonnull final Function&lt;? super V, Float&gt; mapper, @Nonnull final Predicate&lt;Float&gt; filter) {
<span class="fc" id="L3190">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3191">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L3192">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3193">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3194">        return createFloatBinding(() -&gt; items.values().stream().map(mapper).filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a float binding with the first value of an observable map after mapping and filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;K, V&gt; FloatBinding mapToFloatThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Float defaultValue, @Nonnull final ObservableValue&lt;Function&lt;? super V, Float&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Float&gt;&gt; filter) {
<span class="fc" id="L3209">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3210">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3211">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3212">        return createFloatBinding(() -&gt; {</span>
<span class="fc" id="L3213">            Function&lt;? super V, Float&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L3214">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3215">            Predicate&lt;Float&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L3216">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3217">            return items.values().stream().map(mapperValue).filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a float binding with the first value of an observable map after mapping and filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;K, V&gt; FloatBinding mapToFloatThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;Float&gt; supplier, @Nonnull final ObservableValue&lt;Function&lt;? super V, Float&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Float&gt;&gt; filter) {
<span class="fc" id="L3233">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3234">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L3235">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3236">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3237">        return createFloatBinding(() -&gt; {</span>
<span class="fc" id="L3238">            Function&lt;? super V, Float&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L3239">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3240">            Predicate&lt;Float&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L3241">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3242">            return items.values().stream().map(mapperValue).filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a double binding with the first value of an observable map after mapping and filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;K, V&gt; DoubleBinding mapToDoubleThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Double defaultValue, @Nonnull final Function&lt;? super V, Double&gt; mapper, @Nonnull final Predicate&lt;Double&gt; filter) {
<span class="fc" id="L3258">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3259">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3260">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3261">        return createDoubleBinding(() -&gt; items.values().stream().map(mapper).filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a double binding with the first value of an observable map after mapping and filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;K, V&gt; DoubleBinding mapToDoubleThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;Double&gt; supplier, @Nonnull final Function&lt;? super V, Double&gt; mapper, @Nonnull final Predicate&lt;Double&gt; filter) {
<span class="fc" id="L3276">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3277">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L3278">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3279">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3280">        return createDoubleBinding(() -&gt; items.values().stream().map(mapper).filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a double binding with the first value of an observable map after mapping and filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;K, V&gt; DoubleBinding mapToDoubleThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Double defaultValue, @Nonnull final ObservableValue&lt;Function&lt;? super V, Double&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Double&gt;&gt; filter) {
<span class="fc" id="L3295">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3296">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3297">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3298">        return createDoubleBinding(() -&gt; {</span>
<span class="fc" id="L3299">            Function&lt;? super V, Double&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L3300">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3301">            Predicate&lt;Double&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L3302">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3303">            return items.values().stream().map(mapperValue).filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a double binding with the first value of an observable map after mapping and filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;K, V&gt; DoubleBinding mapToDoubleThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;Double&gt; supplier, @Nonnull final ObservableValue&lt;Function&lt;? super V, Double&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;Double&gt;&gt; filter) {
<span class="fc" id="L3319">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3320">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L3321">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3322">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3323">        return createDoubleBinding(() -&gt; {</span>
<span class="fc" id="L3324">            Function&lt;? super V, Double&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L3325">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3326">            Predicate&lt;Double&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L3327">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3328">            return items.values().stream().map(mapperValue).filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a string binding with the first value of an observable map after mapping and filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;K, V&gt; StringBinding mapToStringThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final String defaultValue, @Nonnull final Function&lt;? super V, String&gt; mapper, @Nonnull final Predicate&lt;String&gt; filter) {
<span class="fc" id="L3344">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3345">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3346">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3347">        return createStringBinding(() -&gt; items.values().stream().map(mapper).filter(filter).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a string binding with the first value of an observable map after mapping and filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;K, V&gt; StringBinding mapToStringThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;String&gt; supplier, @Nonnull final Function&lt;? super V, String&gt; mapper, @Nonnull final Predicate&lt;String&gt; filter) {
<span class="fc" id="L3362">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3363">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L3364">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3365">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3366">        return createStringBinding(() -&gt; items.values().stream().map(mapper).filter(filter).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a string binding with the first value of an observable map after mapping and filtering.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param mapper       a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter       a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;K, V&gt; StringBinding mapToStringThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final String defaultValue, @Nonnull final ObservableValue&lt;Function&lt;? super V, String&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;String&gt;&gt; filter) {
<span class="fc" id="L3381">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3382">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3383">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3384">        return createStringBinding(() -&gt; {</span>
<span class="fc" id="L3385">            Function&lt;? super V, String&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L3386">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3387">            Predicate&lt;String&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L3388">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3389">            return items.values().stream().map(mapperValue).filter(filterValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a string binding with the first value of an observable map after mapping and filtering.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param mapper   a non-interfering, stateless function to apply to the each value before filtering.
     * @param filter   a non-interfering, stateless predicate to apply to the each value after mapping.
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;K, V&gt; StringBinding mapToStringThenFilterThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;String&gt; supplier, @Nonnull final ObservableValue&lt;Function&lt;? super V, String&gt;&gt; mapper, @Nonnull final ObservableValue&lt;Predicate&lt;String&gt;&gt; filter) {
<span class="fc" id="L3405">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3406">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L3407">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3408">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3409">        return createStringBinding(() -&gt; {</span>
<span class="fc" id="L3410">            Function&lt;? super V, String&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L3411">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3412">            Predicate&lt;String&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L3413">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3414">            return items.values().stream().map(mapperValue).filter(filterValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates an object binding with the first element of an observable list after filtering and mapping.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;T, R&gt; ObjectBinding&lt;R&gt; filterThenMapThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final R defaultValue, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, R&gt; mapper) {
<span class="fc" id="L3430">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3431">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3432">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3433">        return createObjectBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates an object binding with the first element of an observable list after filtering and mapping.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;T, R&gt; ObjectBinding&lt;R&gt; filterThenMapThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;R&gt; supplier, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, R&gt; mapper) {
<span class="fc" id="L3448">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3449">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L3450">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3451">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3452">        return createObjectBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates an object binding with the first element of an observable list after filtering and mapping.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;T, R&gt; ObjectBinding&lt;R&gt; filterThenMapThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final R defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, R&gt;&gt; mapper) {
<span class="fc" id="L3467">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3468">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3469">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3470">        return createObjectBinding(() -&gt; {</span>
<span class="fc" id="L3471">            Function&lt;? super T, R&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L3472">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3473">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L3474">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3475">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates an object binding with the first element of an observable list after filtering and mapping.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;T, R&gt; ObjectBinding&lt;R&gt; filterThenMapThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;R&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, R&gt;&gt; mapper) {
<span class="fc" id="L3491">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3492">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L3493">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3494">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3495">        return createObjectBinding(() -&gt; {</span>
<span class="fc" id="L3496">            Function&lt;? super T, R&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L3497">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3498">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L3499">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3500">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a boolean binding with the first element of an observable list after filtering and mapping.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;T&gt; BooleanBinding filterThenMapToBooleanThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Boolean defaultValue, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, Boolean&gt; mapper) {
<span class="fc" id="L3516">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3517">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3518">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3519">        return createBooleanBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a boolean binding with the first element of an observable list after filtering and mapping.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;T&gt; BooleanBinding filterThenMapToBooleanThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;Boolean&gt; supplier, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, Boolean&gt; mapper) {
<span class="fc" id="L3534">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3535">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L3536">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3537">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3538">        return createBooleanBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a boolean binding with the first element of an observable list after filtering and mapping.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;T&gt; BooleanBinding filterThenMapToBooleanThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Boolean defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, Boolean&gt;&gt; mapper) {
<span class="fc" id="L3553">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3554">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3555">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3556">        return createBooleanBinding(() -&gt; {</span>
<span class="fc" id="L3557">            Function&lt;? super T, Boolean&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L3558">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3559">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L3560">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3561">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a boolean binding with the first element of an observable list after filtering and mapping.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;T&gt; BooleanBinding filterThenMapToBooleanThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;Boolean&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, Boolean&gt;&gt; mapper) {
<span class="fc" id="L3577">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3578">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L3579">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3580">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3581">        return createBooleanBinding(() -&gt; {</span>
<span class="fc" id="L3582">            Function&lt;? super T, Boolean&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L3583">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3584">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L3585">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3586">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates an integer binding with the first element of an observable list after filtering and mapping.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;T&gt; IntegerBinding filterThenMapToIntegerThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Integer defaultValue, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, Integer&gt; mapper) {
<span class="fc" id="L3602">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3603">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3604">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3605">        return createIntegerBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates an integer binding with the first element of an observable list after filtering and mapping.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;T&gt; IntegerBinding filterThenMapToIntegerThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;Integer&gt; supplier, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, Integer&gt; mapper) {
<span class="fc" id="L3620">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3621">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L3622">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3623">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3624">        return createIntegerBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates an integer binding with the first element of an observable list after filtering and mapping.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;T&gt; IntegerBinding filterThenMapToIntegerThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Integer defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, Integer&gt;&gt; mapper) {
<span class="fc" id="L3639">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3640">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3641">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3642">        return createIntegerBinding(() -&gt; {</span>
<span class="fc" id="L3643">            Function&lt;? super T, Integer&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L3644">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3645">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L3646">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3647">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates an integer binding with the first element of an observable list after filtering and mapping.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;T&gt; IntegerBinding filterThenMapToIntegerThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;Integer&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, Integer&gt;&gt; mapper) {
<span class="fc" id="L3663">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3664">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L3665">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3666">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3667">        return createIntegerBinding(() -&gt; {</span>
<span class="fc" id="L3668">            Function&lt;? super T, Integer&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L3669">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3670">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L3671">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3672">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a long binding with the first element of an observable list after filtering and mapping.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;T&gt; LongBinding filterThenMapToLongThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Long defaultValue, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, Long&gt; mapper) {
<span class="fc" id="L3688">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3689">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3690">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3691">        return createLongBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a long binding with the first element of an observable list after filtering and mapping.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;T&gt; LongBinding filterThenMapToLongThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;Long&gt; supplier, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, Long&gt; mapper) {
<span class="fc" id="L3706">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3707">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L3708">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3709">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3710">        return createLongBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a long binding with the first element of an observable list after filtering and mapping.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;T&gt; LongBinding filterThenMapToLongThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Long defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, Long&gt;&gt; mapper) {
<span class="fc" id="L3725">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3726">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3727">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3728">        return createLongBinding(() -&gt; {</span>
<span class="fc" id="L3729">            Function&lt;? super T, Long&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L3730">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3731">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L3732">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3733">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a long binding with the first element of an observable list after filtering and mapping.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;T&gt; LongBinding filterThenMapToLongThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;Long&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, Long&gt;&gt; mapper) {
<span class="fc" id="L3749">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3750">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L3751">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3752">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3753">        return createLongBinding(() -&gt; {</span>
<span class="fc" id="L3754">            Function&lt;? super T, Long&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L3755">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3756">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L3757">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3758">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a float binding with the first element of an observable list after filtering and mapping.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;T&gt; FloatBinding filterThenMapToFloatThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Float defaultValue, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, Float&gt; mapper) {
<span class="fc" id="L3774">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3775">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3776">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3777">        return createFloatBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a float binding with the first element of an observable list after filtering and mapping.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;T&gt; FloatBinding filterThenMapToFloatThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;Float&gt; supplier, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, Float&gt; mapper) {
<span class="fc" id="L3792">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3793">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L3794">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3795">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3796">        return createFloatBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a float binding with the first element of an observable list after filtering and mapping.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;T&gt; FloatBinding filterThenMapToFloatThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Float defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, Float&gt;&gt; mapper) {
<span class="fc" id="L3811">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3812">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3813">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3814">        return createFloatBinding(() -&gt; {</span>
<span class="fc" id="L3815">            Function&lt;? super T, Float&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L3816">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3817">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L3818">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3819">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a float binding with the first element of an observable list after filtering and mapping.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;T&gt; FloatBinding filterThenMapToFloatThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;Float&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, Float&gt;&gt; mapper) {
<span class="fc" id="L3835">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3836">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L3837">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3838">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3839">        return createFloatBinding(() -&gt; {</span>
<span class="fc" id="L3840">            Function&lt;? super T, Float&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L3841">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3842">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L3843">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3844">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a double binding with the first element of an observable list after filtering and mapping.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;T&gt; DoubleBinding filterThenMapToDoubleThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Double defaultValue, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, Double&gt; mapper) {
<span class="fc" id="L3860">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3861">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3862">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3863">        return createDoubleBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a double binding with the first element of an observable list after filtering and mapping.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;T&gt; DoubleBinding filterThenMapToDoubleThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;Double&gt; supplier, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, Double&gt; mapper) {
<span class="fc" id="L3878">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3879">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L3880">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3881">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3882">        return createDoubleBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a double binding with the first element of an observable list after filtering and mapping.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;T&gt; DoubleBinding filterThenMapToDoubleThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Double defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, Double&gt;&gt; mapper) {
<span class="fc" id="L3897">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3898">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3899">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3900">        return createDoubleBinding(() -&gt; {</span>
<span class="fc" id="L3901">            Function&lt;? super T, Double&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L3902">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3903">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L3904">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3905">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a double binding with the first element of an observable list after filtering and mapping.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;T&gt; DoubleBinding filterThenMapToDoubleThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;Double&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, Double&gt;&gt; mapper) {
<span class="fc" id="L3921">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3922">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L3923">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3924">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3925">        return createDoubleBinding(() -&gt; {</span>
<span class="fc" id="L3926">            Function&lt;? super T, Double&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L3927">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3928">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L3929">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3930">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a string binding with the first element of an observable list after filtering and mapping.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;T&gt; StringBinding filterThenMapToStringThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final String defaultValue, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, String&gt; mapper) {
<span class="fc" id="L3946">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3947">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3948">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3949">        return createStringBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a string binding with the first element of an observable list after filtering and mapping.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;T&gt; StringBinding filterThenMapToStringThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;String&gt; supplier, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, String&gt; mapper) {
<span class="fc" id="L3964">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3965">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L3966">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3967">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3968">        return createStringBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a string binding with the first element of an observable list after filtering and mapping.
     *
     * @param items        the observable list of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;T&gt; StringBinding filterThenMapToStringThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final String defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, String&gt;&gt; mapper) {
<span class="fc" id="L3983">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L3984">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3985">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3986">        return createStringBinding(() -&gt; {</span>
<span class="fc" id="L3987">            Function&lt;? super T, String&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L3988">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L3989">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L3990">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L3991">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a string binding with the first element of an observable list after filtering and mapping.
     *
     * @param items    the observable list of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;T&gt; StringBinding filterThenMapToStringThenFindFirst(@Nonnull final ObservableList&lt;T&gt; items, @Nonnull final Supplier&lt;String&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, String&gt;&gt; mapper) {
<span class="fc" id="L4007">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4008">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L4009">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4010">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4011">        return createStringBinding(() -&gt; {</span>
<span class="fc" id="L4012">            Function&lt;? super T, String&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L4013">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4014">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L4015">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4016">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates an object binding with the first element of an observable set after filtering and mapping.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;T, R&gt; ObjectBinding&lt;R&gt; filterThenMapThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final R defaultValue, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, R&gt; mapper) {
<span class="fc" id="L4032">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4033">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4034">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4035">        return createObjectBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates an object binding with the first element of an observable set after filtering and mapping.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;T, R&gt; ObjectBinding&lt;R&gt; filterThenMapThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;R&gt; supplier, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, R&gt; mapper) {
<span class="fc" id="L4050">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4051">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L4052">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4053">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4054">        return createObjectBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates an object binding with the first element of an observable set after filtering and mapping.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;T, R&gt; ObjectBinding&lt;R&gt; filterThenMapThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final R defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, R&gt;&gt; mapper) {
<span class="fc" id="L4069">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4070">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4071">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4072">        return createObjectBinding(() -&gt; {</span>
<span class="fc" id="L4073">            Function&lt;? super T, R&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L4074">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4075">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L4076">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4077">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates an object binding with the first element of an observable set after filtering and mapping.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;T, R&gt; ObjectBinding&lt;R&gt; filterThenMapThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;R&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, R&gt;&gt; mapper) {
<span class="fc" id="L4093">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4094">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L4095">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4096">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4097">        return createObjectBinding(() -&gt; {</span>
<span class="fc" id="L4098">            Function&lt;? super T, R&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L4099">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4100">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L4101">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4102">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a boolean binding with the first element of an observable set after filtering and mapping.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;T&gt; BooleanBinding filterThenMapToBooleanThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Boolean defaultValue, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, Boolean&gt; mapper) {
<span class="fc" id="L4118">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4119">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4120">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4121">        return createBooleanBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a boolean binding with the first element of an observable set after filtering and mapping.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;T&gt; BooleanBinding filterThenMapToBooleanThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;Boolean&gt; supplier, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, Boolean&gt; mapper) {
<span class="fc" id="L4136">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4137">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L4138">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4139">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4140">        return createBooleanBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a boolean binding with the first element of an observable set after filtering and mapping.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;T&gt; BooleanBinding filterThenMapToBooleanThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Boolean defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, Boolean&gt;&gt; mapper) {
<span class="fc" id="L4155">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4156">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4157">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4158">        return createBooleanBinding(() -&gt; {</span>
<span class="fc" id="L4159">            Function&lt;? super T, Boolean&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L4160">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4161">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L4162">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4163">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a boolean binding with the first element of an observable set after filtering and mapping.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;T&gt; BooleanBinding filterThenMapToBooleanThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;Boolean&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, Boolean&gt;&gt; mapper) {
<span class="fc" id="L4179">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4180">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L4181">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4182">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4183">        return createBooleanBinding(() -&gt; {</span>
<span class="fc" id="L4184">            Function&lt;? super T, Boolean&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L4185">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4186">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L4187">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4188">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates an integer binding with the first element of an observable set after filtering and mapping.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;T&gt; IntegerBinding filterThenMapToIntegerThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Integer defaultValue, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, Integer&gt; mapper) {
<span class="fc" id="L4204">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4205">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4206">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4207">        return createIntegerBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates an integer binding with the first element of an observable set after filtering and mapping.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;T&gt; IntegerBinding filterThenMapToIntegerThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;Integer&gt; supplier, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, Integer&gt; mapper) {
<span class="fc" id="L4222">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4223">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L4224">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4225">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4226">        return createIntegerBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates an integer binding with the first element of an observable set after filtering and mapping.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;T&gt; IntegerBinding filterThenMapToIntegerThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Integer defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, Integer&gt;&gt; mapper) {
<span class="fc" id="L4241">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4242">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4243">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4244">        return createIntegerBinding(() -&gt; {</span>
<span class="fc" id="L4245">            Function&lt;? super T, Integer&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L4246">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4247">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L4248">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4249">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates an integer binding with the first element of an observable set after filtering and mapping.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;T&gt; IntegerBinding filterThenMapToIntegerThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;Integer&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, Integer&gt;&gt; mapper) {
<span class="fc" id="L4265">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4266">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L4267">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4268">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4269">        return createIntegerBinding(() -&gt; {</span>
<span class="fc" id="L4270">            Function&lt;? super T, Integer&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L4271">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4272">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L4273">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4274">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a long binding with the first element of an observable set after filtering and mapping.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;T&gt; LongBinding filterThenMapToLongThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Long defaultValue, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, Long&gt; mapper) {
<span class="fc" id="L4290">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4291">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4292">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4293">        return createLongBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a long binding with the first element of an observable set after filtering and mapping.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;T&gt; LongBinding filterThenMapToLongThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;Long&gt; supplier, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, Long&gt; mapper) {
<span class="fc" id="L4308">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4309">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L4310">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4311">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4312">        return createLongBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a long binding with the first element of an observable set after filtering and mapping.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;T&gt; LongBinding filterThenMapToLongThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Long defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, Long&gt;&gt; mapper) {
<span class="fc" id="L4327">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4328">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4329">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4330">        return createLongBinding(() -&gt; {</span>
<span class="fc" id="L4331">            Function&lt;? super T, Long&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L4332">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4333">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L4334">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4335">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a long binding with the first element of an observable set after filtering and mapping.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;T&gt; LongBinding filterThenMapToLongThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;Long&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, Long&gt;&gt; mapper) {
<span class="fc" id="L4351">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4352">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L4353">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4354">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4355">        return createLongBinding(() -&gt; {</span>
<span class="fc" id="L4356">            Function&lt;? super T, Long&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L4357">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4358">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L4359">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4360">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a float binding with the first element of an observable set after filtering and mapping.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;T&gt; FloatBinding filterThenMapToFloatThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Float defaultValue, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, Float&gt; mapper) {
<span class="fc" id="L4376">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4377">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4378">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4379">        return createFloatBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a float binding with the first element of an observable set after filtering and mapping.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;T&gt; FloatBinding filterThenMapToFloatThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;Float&gt; supplier, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, Float&gt; mapper) {
<span class="fc" id="L4394">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4395">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L4396">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4397">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4398">        return createFloatBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a float binding with the first element of an observable set after filtering and mapping.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;T&gt; FloatBinding filterThenMapToFloatThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Float defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, Float&gt;&gt; mapper) {
<span class="fc" id="L4413">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4414">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4415">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4416">        return createFloatBinding(() -&gt; {</span>
<span class="fc" id="L4417">            Function&lt;? super T, Float&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L4418">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4419">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L4420">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4421">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a float binding with the first element of an observable set after filtering and mapping.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;T&gt; FloatBinding filterThenMapToFloatThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;Float&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, Float&gt;&gt; mapper) {
<span class="fc" id="L4437">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4438">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L4439">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4440">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4441">        return createFloatBinding(() -&gt; {</span>
<span class="fc" id="L4442">            Function&lt;? super T, Float&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L4443">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4444">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L4445">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4446">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a double binding with the first element of an observable set after filtering and mapping.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;T&gt; DoubleBinding filterThenMapToDoubleThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Double defaultValue, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, Double&gt; mapper) {
<span class="fc" id="L4462">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4463">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4464">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4465">        return createDoubleBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a double binding with the first element of an observable set after filtering and mapping.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;T&gt; DoubleBinding filterThenMapToDoubleThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;Double&gt; supplier, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, Double&gt; mapper) {
<span class="fc" id="L4480">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4481">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L4482">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4483">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4484">        return createDoubleBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a double binding with the first element of an observable set after filtering and mapping.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;T&gt; DoubleBinding filterThenMapToDoubleThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Double defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, Double&gt;&gt; mapper) {
<span class="fc" id="L4499">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4500">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4501">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4502">        return createDoubleBinding(() -&gt; {</span>
<span class="fc" id="L4503">            Function&lt;? super T, Double&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L4504">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4505">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L4506">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4507">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a double binding with the first element of an observable set after filtering and mapping.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;T&gt; DoubleBinding filterThenMapToDoubleThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;Double&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, Double&gt;&gt; mapper) {
<span class="fc" id="L4523">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4524">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L4525">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4526">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4527">        return createDoubleBinding(() -&gt; {</span>
<span class="fc" id="L4528">            Function&lt;? super T, Double&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L4529">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4530">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L4531">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4532">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a string binding with the first element of an observable set after filtering and mapping.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;T&gt; StringBinding filterThenMapToStringThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final String defaultValue, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, String&gt; mapper) {
<span class="fc" id="L4548">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4549">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4550">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4551">        return createStringBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a string binding with the first element of an observable set after filtering and mapping.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;T&gt; StringBinding filterThenMapToStringThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;String&gt; supplier, @Nonnull final Predicate&lt;? super T&gt; filter, @Nonnull final Function&lt;? super T, String&gt; mapper) {
<span class="fc" id="L4566">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4567">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L4568">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4569">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4570">        return createStringBinding(() -&gt; items.stream().filter(filter).map(mapper).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a string binding with the first element of an observable set after filtering and mapping.
     *
     * @param items        the observable set of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;T&gt; StringBinding filterThenMapToStringThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final String defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, String&gt;&gt; mapper) {
<span class="fc" id="L4585">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4586">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4587">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4588">        return createStringBinding(() -&gt; {</span>
<span class="fc" id="L4589">            Function&lt;? super T, String&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L4590">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4591">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L4592">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4593">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a string binding with the first element of an observable set after filtering and mapping.
     *
     * @param items    the observable set of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each element before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each element after filtering.
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;T&gt; StringBinding filterThenMapToStringThenFindFirst(@Nonnull final ObservableSet&lt;T&gt; items, @Nonnull final Supplier&lt;String&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super T&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super T, String&gt;&gt; mapper) {
<span class="fc" id="L4609">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4610">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L4611">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4612">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4613">        return createStringBinding(() -&gt; {</span>
<span class="fc" id="L4614">            Function&lt;? super T, String&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L4615">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4616">            Predicate&lt;? super T&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L4617">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4618">            return items.stream().filter(filterValue).map(mapperValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates an object binding with the first value of an observable map after filtering and mapping.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;K, V, R&gt; ObjectBinding&lt;R&gt; filterThenMapThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final R defaultValue, @Nonnull final Predicate&lt;? super V&gt; filter, @Nonnull final Function&lt;? super V, R&gt; mapper) {
<span class="fc" id="L4634">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4635">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4636">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4637">        return createObjectBinding(() -&gt; items.values().stream().filter(filter).map(mapper).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates an object binding with the first value of an observable map after filtering and mapping.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;K, V, R&gt; ObjectBinding&lt;R&gt; filterThenMapThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;R&gt; supplier, @Nonnull final Predicate&lt;? super V&gt; filter, @Nonnull final Function&lt;? super V, R&gt; mapper) {
<span class="fc" id="L4652">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4653">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L4654">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4655">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4656">        return createObjectBinding(() -&gt; items.values().stream().filter(filter).map(mapper).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates an object binding with the first value of an observable map after filtering and mapping.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;K, V, R&gt; ObjectBinding&lt;R&gt; filterThenMapThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final R defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super V&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super V, R&gt;&gt; mapper) {
<span class="fc" id="L4671">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4672">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4673">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4674">        return createObjectBinding(() -&gt; {</span>
<span class="fc" id="L4675">            Function&lt;? super V, R&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L4676">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4677">            Predicate&lt;? super V&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L4678">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4679">            return items.values().stream().filter(filterValue).map(mapperValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates an object binding with the first value of an observable map after filtering and mapping.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return an object binding
     */
    @Nonnull
    public static &lt;K, V, R&gt; ObjectBinding&lt;R&gt; filterThenMapThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;R&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super V&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super V, R&gt;&gt; mapper) {
<span class="fc" id="L4695">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4696">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L4697">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4698">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4699">        return createObjectBinding(() -&gt; {</span>
<span class="fc" id="L4700">            Function&lt;? super V, R&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L4701">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4702">            Predicate&lt;? super V&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L4703">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4704">            return items.values().stream().filter(filterValue).map(mapperValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a boolean binding with the first value of an observable map after filtering and mapping.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;K, V&gt; BooleanBinding filterThenMapToBooleanThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Boolean defaultValue, @Nonnull final Predicate&lt;? super V&gt; filter, @Nonnull final Function&lt;? super V, Boolean&gt; mapper) {
<span class="fc" id="L4720">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4721">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4722">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4723">        return createBooleanBinding(() -&gt; items.values().stream().filter(filter).map(mapper).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a boolean binding with the first value of an observable map after filtering and mapping.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;K, V&gt; BooleanBinding filterThenMapToBooleanThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;Boolean&gt; supplier, @Nonnull final Predicate&lt;? super V&gt; filter, @Nonnull final Function&lt;? super V, Boolean&gt; mapper) {
<span class="fc" id="L4738">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4739">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L4740">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4741">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4742">        return createBooleanBinding(() -&gt; items.values().stream().filter(filter).map(mapper).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a boolean binding with the first value of an observable map after filtering and mapping.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;K, V&gt; BooleanBinding filterThenMapToBooleanThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Boolean defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super V&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super V, Boolean&gt;&gt; mapper) {
<span class="fc" id="L4757">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4758">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4759">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4760">        return createBooleanBinding(() -&gt; {</span>
<span class="fc" id="L4761">            Function&lt;? super V, Boolean&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L4762">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4763">            Predicate&lt;? super V&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L4764">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4765">            return items.values().stream().filter(filterValue).map(mapperValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a boolean binding with the first value of an observable map after filtering and mapping.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return a boolean binding
     */
    @Nonnull
    public static &lt;K, V&gt; BooleanBinding filterThenMapToBooleanThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;Boolean&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super V&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super V, Boolean&gt;&gt; mapper) {
<span class="fc" id="L4781">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4782">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L4783">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4784">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4785">        return createBooleanBinding(() -&gt; {</span>
<span class="fc" id="L4786">            Function&lt;? super V, Boolean&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L4787">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4788">            Predicate&lt;? super V&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L4789">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4790">            return items.values().stream().filter(filterValue).map(mapperValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates an integer binding with the first value of an observable map after filtering and mapping.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;K, V&gt; IntegerBinding filterThenMapToIntegerThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Integer defaultValue, @Nonnull final Predicate&lt;? super V&gt; filter, @Nonnull final Function&lt;? super V, Integer&gt; mapper) {
<span class="fc" id="L4806">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4807">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4808">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4809">        return createIntegerBinding(() -&gt; items.values().stream().filter(filter).map(mapper).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates an integer binding with the first value of an observable map after filtering and mapping.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;K, V&gt; IntegerBinding filterThenMapToIntegerThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;Integer&gt; supplier, @Nonnull final Predicate&lt;? super V&gt; filter, @Nonnull final Function&lt;? super V, Integer&gt; mapper) {
<span class="fc" id="L4824">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4825">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L4826">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4827">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4828">        return createIntegerBinding(() -&gt; items.values().stream().filter(filter).map(mapper).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates an integer binding with the first value of an observable map after filtering and mapping.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;K, V&gt; IntegerBinding filterThenMapToIntegerThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Integer defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super V&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super V, Integer&gt;&gt; mapper) {
<span class="fc" id="L4843">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4844">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4845">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4846">        return createIntegerBinding(() -&gt; {</span>
<span class="fc" id="L4847">            Function&lt;? super V, Integer&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L4848">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4849">            Predicate&lt;? super V&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L4850">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4851">            return items.values().stream().filter(filterValue).map(mapperValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates an integer binding with the first value of an observable map after filtering and mapping.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return an integer binding
     */
    @Nonnull
    public static &lt;K, V&gt; IntegerBinding filterThenMapToIntegerThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;Integer&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super V&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super V, Integer&gt;&gt; mapper) {
<span class="fc" id="L4867">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4868">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L4869">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4870">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4871">        return createIntegerBinding(() -&gt; {</span>
<span class="fc" id="L4872">            Function&lt;? super V, Integer&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L4873">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4874">            Predicate&lt;? super V&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L4875">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4876">            return items.values().stream().filter(filterValue).map(mapperValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a long binding with the first value of an observable map after filtering and mapping.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;K, V&gt; LongBinding filterThenMapToLongThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Long defaultValue, @Nonnull final Predicate&lt;? super V&gt; filter, @Nonnull final Function&lt;? super V, Long&gt; mapper) {
<span class="fc" id="L4892">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4893">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4894">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4895">        return createLongBinding(() -&gt; items.values().stream().filter(filter).map(mapper).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a long binding with the first value of an observable map after filtering and mapping.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;K, V&gt; LongBinding filterThenMapToLongThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;Long&gt; supplier, @Nonnull final Predicate&lt;? super V&gt; filter, @Nonnull final Function&lt;? super V, Long&gt; mapper) {
<span class="fc" id="L4910">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4911">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L4912">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4913">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4914">        return createLongBinding(() -&gt; items.values().stream().filter(filter).map(mapper).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a long binding with the first value of an observable map after filtering and mapping.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;K, V&gt; LongBinding filterThenMapToLongThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Long defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super V&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super V, Long&gt;&gt; mapper) {
<span class="fc" id="L4929">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4930">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4931">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4932">        return createLongBinding(() -&gt; {</span>
<span class="fc" id="L4933">            Function&lt;? super V, Long&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L4934">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4935">            Predicate&lt;? super V&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L4936">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4937">            return items.values().stream().filter(filterValue).map(mapperValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a long binding with the first value of an observable map after filtering and mapping.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return a long binding
     */
    @Nonnull
    public static &lt;K, V&gt; LongBinding filterThenMapToLongThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;Long&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super V&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super V, Long&gt;&gt; mapper) {
<span class="fc" id="L4953">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4954">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L4955">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4956">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4957">        return createLongBinding(() -&gt; {</span>
<span class="fc" id="L4958">            Function&lt;? super V, Long&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L4959">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4960">            Predicate&lt;? super V&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L4961">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4962">            return items.values().stream().filter(filterValue).map(mapperValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a float binding with the first value of an observable map after filtering and mapping.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;K, V&gt; FloatBinding filterThenMapToFloatThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Float defaultValue, @Nonnull final Predicate&lt;? super V&gt; filter, @Nonnull final Function&lt;? super V, Float&gt; mapper) {
<span class="fc" id="L4978">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4979">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4980">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L4981">        return createFloatBinding(() -&gt; items.values().stream().filter(filter).map(mapper).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a float binding with the first value of an observable map after filtering and mapping.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;K, V&gt; FloatBinding filterThenMapToFloatThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;Float&gt; supplier, @Nonnull final Predicate&lt;? super V&gt; filter, @Nonnull final Function&lt;? super V, Float&gt; mapper) {
<span class="fc" id="L4996">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L4997">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L4998">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L4999">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L5000">        return createFloatBinding(() -&gt; items.values().stream().filter(filter).map(mapper).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a float binding with the first value of an observable map after filtering and mapping.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;K, V&gt; FloatBinding filterThenMapToFloatThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Float defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super V&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super V, Float&gt;&gt; mapper) {
<span class="fc" id="L5015">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L5016">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L5017">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L5018">        return createFloatBinding(() -&gt; {</span>
<span class="fc" id="L5019">            Function&lt;? super V, Float&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L5020">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L5021">            Predicate&lt;? super V&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L5022">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L5023">            return items.values().stream().filter(filterValue).map(mapperValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a float binding with the first value of an observable map after filtering and mapping.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return a float binding
     */
    @Nonnull
    public static &lt;K, V&gt; FloatBinding filterThenMapToFloatThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;Float&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super V&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super V, Float&gt;&gt; mapper) {
<span class="fc" id="L5039">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L5040">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L5041">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L5042">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L5043">        return createFloatBinding(() -&gt; {</span>
<span class="fc" id="L5044">            Function&lt;? super V, Float&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L5045">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L5046">            Predicate&lt;? super V&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L5047">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L5048">            return items.values().stream().filter(filterValue).map(mapperValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a double binding with the first value of an observable map after filtering and mapping.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;K, V&gt; DoubleBinding filterThenMapToDoubleThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Double defaultValue, @Nonnull final Predicate&lt;? super V&gt; filter, @Nonnull final Function&lt;? super V, Double&gt; mapper) {
<span class="fc" id="L5064">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L5065">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L5066">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L5067">        return createDoubleBinding(() -&gt; items.values().stream().filter(filter).map(mapper).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a double binding with the first value of an observable map after filtering and mapping.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;K, V&gt; DoubleBinding filterThenMapToDoubleThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;Double&gt; supplier, @Nonnull final Predicate&lt;? super V&gt; filter, @Nonnull final Function&lt;? super V, Double&gt; mapper) {
<span class="fc" id="L5082">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L5083">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L5084">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L5085">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L5086">        return createDoubleBinding(() -&gt; items.values().stream().filter(filter).map(mapper).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a double binding with the first value of an observable map after filtering and mapping.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;K, V&gt; DoubleBinding filterThenMapToDoubleThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Double defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super V&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super V, Double&gt;&gt; mapper) {
<span class="fc" id="L5101">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L5102">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L5103">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L5104">        return createDoubleBinding(() -&gt; {</span>
<span class="fc" id="L5105">            Function&lt;? super V, Double&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L5106">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L5107">            Predicate&lt;? super V&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L5108">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L5109">            return items.values().stream().filter(filterValue).map(mapperValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a double binding with the first value of an observable map after filtering and mapping.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return a double binding
     */
    @Nonnull
    public static &lt;K, V&gt; DoubleBinding filterThenMapToDoubleThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;Double&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super V&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super V, Double&gt;&gt; mapper) {
<span class="fc" id="L5125">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L5126">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L5127">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L5128">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L5129">        return createDoubleBinding(() -&gt; {</span>
<span class="fc" id="L5130">            Function&lt;? super V, Double&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L5131">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L5132">            Predicate&lt;? super V&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L5133">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L5134">            return items.values().stream().filter(filterValue).map(mapperValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a string binding with the first value of an observable map after filtering and mapping.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;K, V&gt; StringBinding filterThenMapToStringThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final String defaultValue, @Nonnull final Predicate&lt;? super V&gt; filter, @Nonnull final Function&lt;? super V, String&gt; mapper) {
<span class="fc" id="L5150">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L5151">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L5152">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L5153">        return createStringBinding(() -&gt; items.values().stream().filter(filter).map(mapper).findFirst().orElse(defaultValue), items);</span>
    }

    /**
     * Creates a string binding with the first value of an observable map after filtering and mapping.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;K, V&gt; StringBinding filterThenMapToStringThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;String&gt; supplier, @Nonnull final Predicate&lt;? super V&gt; filter, @Nonnull final Function&lt;? super V, String&gt; mapper) {
<span class="fc" id="L5168">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L5169">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L5170">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L5171">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L5172">        return createStringBinding(() -&gt; items.values().stream().filter(filter).map(mapper).findFirst().orElseGet(supplier), items);</span>
    }

    /**
     * Creates a string binding with the first value of an observable map after filtering and mapping.
     *
     * @param items        the observable map of items.
     * @param defaultValue the value to be returned if there is no value present.
     * @param filter       a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper       a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;K, V&gt; StringBinding filterThenMapToStringThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final String defaultValue, @Nonnull final ObservableValue&lt;Predicate&lt;? super V&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super V, String&gt;&gt; mapper) {
<span class="fc" id="L5187">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L5188">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L5189">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L5190">        return createStringBinding(() -&gt; {</span>
<span class="fc" id="L5191">            Function&lt;? super V, String&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L5192">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L5193">            Predicate&lt;? super V&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L5194">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L5195">            return items.values().stream().filter(filterValue).map(mapperValue).findFirst().orElse(defaultValue);</span>
        }, items, mapper, filter);
    }

    /**
     * Creates a string binding with the first value of an observable map after filtering and mapping.
     *
     * @param items    the observable map of items.
     * @param supplier a {@code Supplier} whose result is returned if no value is present.
     * @param filter   a non-interfering, stateless predicate to apply to the each value before mapping.
     * @param mapper   a non-interfering, stateless function to apply to the each value after filtering.
     *
     * @return a string binding
     */
    @Nonnull
    public static &lt;K, V&gt; StringBinding filterThenMapToStringThenFindFirst(@Nonnull final ObservableMap&lt;K, V&gt; items, @Nonnull final Supplier&lt;String&gt; supplier, @Nonnull final ObservableValue&lt;Predicate&lt;? super V&gt;&gt; filter, @Nonnull final ObservableValue&lt;Function&lt;? super V, String&gt;&gt; mapper) {
<span class="fc" id="L5211">        requireNonNull(items, ERROR_ITEMS_NULL);</span>
<span class="fc" id="L5212">        requireNonNull(supplier, ERROR_SUPPLIER_NULL);</span>
<span class="fc" id="L5213">        requireNonNull(filter, ERROR_FILTER_NULL);</span>
<span class="fc" id="L5214">        requireNonNull(mapper, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L5215">        return createStringBinding(() -&gt; {</span>
<span class="fc" id="L5216">            Function&lt;? super V, String&gt; mapperValue = mapper.getValue();</span>
<span class="fc" id="L5217">            requireNonNull(mapperValue, ERROR_MAPPER_NULL);</span>
<span class="fc" id="L5218">            Predicate&lt;? super V&gt; filterValue = filter.getValue();</span>
<span class="fc" id="L5219">            requireNonNull(filterValue, ERROR_FILTER_NULL);</span>
<span class="fc" id="L5220">            return items.values().stream().filter(filterValue).map(mapperValue).findFirst().orElseGet(supplier);</span>
        }, items, mapper, filter);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>