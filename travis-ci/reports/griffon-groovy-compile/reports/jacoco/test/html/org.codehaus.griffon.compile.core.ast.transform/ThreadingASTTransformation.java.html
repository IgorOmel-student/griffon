<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ThreadingASTTransformation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">griffon-groovy-compile</a> &gt; <a href="index.source.html" class="el_package">org.codehaus.griffon.compile.core.ast.transform</a> &gt; <span class="el_source">ThreadingASTTransformation.java</span></div><h1>ThreadingASTTransformation.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2008-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.codehaus.griffon.compile.core.ast.transform;

import griffon.core.artifact.GriffonController;
import griffon.transform.Threading;
import griffon.util.GriffonClassUtils;
import griffon.util.MethodDescriptor;
import org.codehaus.griffon.compile.core.AnnotationHandler;
import org.codehaus.griffon.compile.core.AnnotationHandlerFor;
import org.codehaus.griffon.compile.core.ThreadingAwareConstants;
import org.codehaus.groovy.ast.ASTNode;
import org.codehaus.groovy.ast.AnnotatedNode;
import org.codehaus.groovy.ast.AnnotationNode;
import org.codehaus.groovy.ast.ClassHelper;
import org.codehaus.groovy.ast.ClassNode;
import org.codehaus.groovy.ast.MethodNode;
import org.codehaus.groovy.ast.Parameter;
import org.codehaus.groovy.ast.Variable;
import org.codehaus.groovy.ast.VariableScope;
import org.codehaus.groovy.ast.expr.ClosureExpression;
import org.codehaus.groovy.ast.expr.MethodCallExpression;
import org.codehaus.groovy.ast.expr.PropertyExpression;
import org.codehaus.groovy.ast.stmt.BlockStatement;
import org.codehaus.groovy.ast.stmt.Statement;
import org.codehaus.groovy.control.CompilePhase;
import org.codehaus.groovy.control.SourceUnit;
import org.codehaus.groovy.transform.GroovyASTTransformation;

import java.util.Iterator;
import java.util.List;

import static org.codehaus.griffon.compile.core.ast.GriffonASTUtils.THIS;
import static org.codehaus.griffon.compile.core.ast.GriffonASTUtils.args;
import static org.codehaus.griffon.compile.core.ast.GriffonASTUtils.stmnt;
import static org.codehaus.griffon.compile.core.ast.transform.ThreadingAwareASTTransformation.addThreadingHandlerIfNeeded;

/**
 * Handles generation of code for the {@code @Threading} annotation.
 * &lt;p/&gt;
 *
 * @author Andres Almiray
 * @since 2.0.0
 */
@AnnotationHandlerFor(Threading.class)
@GroovyASTTransformation(phase = CompilePhase.CANONICALIZATION)
<span class="nc" id="L60">public class ThreadingASTTransformation extends AbstractASTTransformation implements ThreadingAwareConstants, AnnotationHandler {</span>
<span class="nc" id="L61">    private static final ClassNode THREADING_CNODE = makeClassSafe(Threading.class);</span>
<span class="nc" id="L62">    private static final ClassNode GRIFFON_CONTROLLER_CNODE = makeClassSafe(GriffonController.class);</span>

    /**
     * Convenience method to see if an annotated node is {@code @Threading}.
     *
     * @param node the node to check
     *
     * @return true if the node is an event publisher
     */
    public static boolean hasThreadingAnnotation(AnnotatedNode node) {
<span class="nc bnc" id="L72" title="All 2 branches missed.">        for (AnnotationNode annotation : node.getAnnotations()) {</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">            if (THREADING_CNODE.equals(annotation.getClassNode())) {</span>
<span class="nc" id="L74">                return true;</span>
            }
<span class="nc" id="L76">        }</span>
<span class="nc" id="L77">        return false;</span>
    }

    /**
     * Handles the bulk of the processing, mostly delegating to other methods.
     *
     * @param nodes  the ast nodes
     * @param source the source unit for the nodes
     */
    public void visit(ASTNode[] nodes, SourceUnit source) {
<span class="nc" id="L87">        AnnotationNode annotation = (AnnotationNode) nodes[0];</span>
<span class="nc" id="L88">        AnnotatedNode node = (AnnotatedNode) nodes[1];</span>

<span class="nc" id="L90">        Threading.Policy threadingPolicy = getThreadingPolicy(annotation);</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">        if (threadingPolicy == Threading.Policy.SKIP) { return; }</span>

<span class="nc" id="L93">        String threadingMethod = resolveThreadingMethod(threadingPolicy);</span>

<span class="nc bnc" id="L95" title="All 2 branches missed.">        if (node instanceof MethodNode) {</span>
<span class="nc" id="L96">            ClassNode declaringClass = node.getDeclaringClass();</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">            if (declaringClass.implementsInterface(GRIFFON_CONTROLLER_CNODE)) {</span>
<span class="nc" id="L98">                return;</span>
            }

<span class="nc" id="L101">            addThreadingHandlerIfNeeded(source, declaringClass);</span>
<span class="nc" id="L102">            handleMethodForInjection(declaringClass, (MethodNode) node, threadingMethod);</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">        } else if (node instanceof ClassNode) {</span>
<span class="nc" id="L104">            ClassNode declaringClass = (ClassNode) node;</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">            if (declaringClass.implementsInterface(GRIFFON_CONTROLLER_CNODE)) {</span>
<span class="nc" id="L106">                return;</span>
            }

<span class="nc" id="L109">            addThreadingHandlerIfNeeded(source, declaringClass);</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">            for (MethodNode methodNode : declaringClass.getAllDeclaredMethods()) {</span>
<span class="nc" id="L111">                threadingPolicy = getThreadingPolicy(methodNode, threadingPolicy);</span>
<span class="nc" id="L112">                threadingMethod = resolveThreadingMethod(threadingPolicy);</span>
<span class="nc" id="L113">                handleMethodForInjection(declaringClass, methodNode, threadingMethod);</span>
<span class="nc" id="L114">            }</span>
        }
<span class="nc" id="L116">    }</span>

    private String resolveThreadingMethod(Threading.Policy threadingPolicy) {
<span class="nc" id="L119">        String threadingMethod = METHOD_RUN_OUTSIDE_UI;</span>
<span class="nc bnc" id="L120" title="All 4 branches missed.">        switch (threadingPolicy) {</span>
            case INSIDE_UITHREAD_SYNC:
<span class="nc" id="L122">                threadingMethod = METHOD_RUN_INSIDE_UI_SYNC;</span>
<span class="nc" id="L123">                break;</span>
            case INSIDE_UITHREAD_ASYNC:
<span class="nc" id="L125">                threadingMethod = METHOD_RUN_INSIDE_UI_ASYNC;</span>
<span class="nc" id="L126">                break;</span>
            case BACKGROUND_THREAD:
<span class="nc" id="L128">                threadingMethod = METHOD_RUN_IN_BACKGROUND;</span>
<span class="nc" id="L129">                break;</span>
            case OUTSIDE_UITHREAD:
            default:
                break;
        }
<span class="nc" id="L134">        return threadingMethod;</span>
    }

    public static Threading.Policy getThreadingPolicy(AnnotationNode annotation) {
<span class="nc" id="L138">        PropertyExpression value = (PropertyExpression) annotation.getMember(&quot;value&quot;);</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">        if (value == null) { return Threading.Policy.OUTSIDE_UITHREAD; }</span>
<span class="nc" id="L140">        return Threading.Policy.valueOf(value.getPropertyAsString());</span>
    }

    public static Threading.Policy getThreadingPolicy(MethodNode method, Threading.Policy defaultPolicy) {
<span class="nc" id="L144">        List&lt;AnnotationNode&gt; annotations = method.getAnnotations(THREADING_CNODE);</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">        if (annotations.size() &gt; 0) {</span>
<span class="nc" id="L146">            return getThreadingPolicy(annotations.get(0));</span>
        }
<span class="nc" id="L148">        return defaultPolicy;</span>
    }

    public static void handleMethodForInjection(ClassNode classNode, MethodNode method, String threadingMethod) {
<span class="nc" id="L152">        MethodDescriptor md = methodDescriptorFor(method);</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">        if (GriffonClassUtils.isPlainMethod(md) &amp;&amp;</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">            !GriffonClassUtils.isEventHandler(md) &amp;&amp;</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">            hasVoidOrDefAsReturnType(method)) {</span>
<span class="nc" id="L156">            wrapStatements(classNode, method, threadingMethod);</span>
        }
<span class="nc" id="L158">    }</span>

    private static boolean hasVoidOrDefAsReturnType(MethodNode method) {
<span class="nc" id="L161">        Class&lt;?&gt; returnType = method.getReturnType().getTypeClass();</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">        return returnType.equals(ClassHelper.DYNAMIC_TYPE.getTypeClass()) ||</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">            returnType.equals(ClassHelper.VOID_TYPE.getTypeClass());</span>
    }

    private static MethodDescriptor methodDescriptorFor(MethodNode method) {
<span class="nc bnc" id="L167" title="All 2 branches missed.">        if (method == null) { return null; }</span>
<span class="nc" id="L168">        Parameter[] types = method.getParameters();</span>
<span class="nc" id="L169">        String[] parameterTypes = new String[types.length];</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">        for (int i = 0; i &lt; types.length; i++) {</span>
<span class="nc" id="L171">            parameterTypes[i] = newClass(types[i].getType()).getName();</span>
        }
<span class="nc" id="L173">        return new MethodDescriptor(method.getName(), parameterTypes, method.getModifiers());</span>
    }

    private static void wrapStatements(ClassNode declaringClass, MethodNode method, String threadingMethod) {
<span class="nc" id="L177">        Statement code = method.getCode();</span>
<span class="nc" id="L178">        Statement wrappedCode = wrapStatements(code, threadingMethod);</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">        if (code != wrappedCode) {</span>
<span class="nc" id="L180">            method.setCode(wrappedCode);</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">            for (Parameter param : method.getParameters()) {</span>
<span class="nc" id="L182">                param.setClosureSharedVariable(true);</span>
            }
        }
<span class="nc" id="L185">    }</span>

    private static Statement wrapStatements(Statement code, String threadingMethod) {
        // TODO deal with non-block statements
<span class="nc bnc" id="L189" title="All 2 branches missed.">        if (!(code instanceof BlockStatement)) { return code; }</span>

<span class="nc" id="L191">        BlockStatement codeBlock = (BlockStatement) code;</span>
<span class="nc" id="L192">        List&lt;Statement&gt; statements = codeBlock.getStatements();</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">        if (statements.isEmpty()) { return code; }</span>

<span class="nc" id="L195">        VariableScope variableScope = codeBlock.getVariableScope();</span>
<span class="nc" id="L196">        BlockStatement block = new BlockStatement();</span>
<span class="nc" id="L197">        VariableScope blockScope = variableScope.copy();</span>
<span class="nc" id="L198">        makeVariablesShared(blockScope);</span>
<span class="nc" id="L199">        block.setVariableScope(blockScope);</span>
<span class="nc" id="L200">        ClosureExpression closure = new ClosureExpression(Parameter.EMPTY_ARRAY, code);</span>
<span class="nc" id="L201">        VariableScope closureScope = variableScope.copy();</span>
<span class="nc" id="L202">        makeVariablesShared(closureScope);</span>
<span class="nc" id="L203">        closure.setVariableScope(closureScope);</span>
<span class="nc" id="L204">        block.addStatement(stmnt(new MethodCallExpression(THIS, threadingMethod, args(closure))));</span>

<span class="nc" id="L206">        return block;</span>
    }

    private static void makeVariablesShared(VariableScope scope) {
<span class="nc bnc" id="L210" title="All 2 branches missed.">        for (Iterator&lt;Variable&gt; vars = scope.getReferencedLocalVariablesIterator(); vars.hasNext(); ) {</span>
<span class="nc" id="L211">            Variable var = vars.next();</span>
<span class="nc" id="L212">            var.setClosureSharedVariable(true);</span>
<span class="nc" id="L213">        }</span>
<span class="nc" id="L214">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>