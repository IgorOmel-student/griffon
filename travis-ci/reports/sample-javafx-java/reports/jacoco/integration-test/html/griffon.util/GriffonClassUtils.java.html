<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GriffonClassUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sample-javafx-java</a> &gt; <a href="index.source.html" class="el_package">griffon.util</a> &gt; <span class="el_source">GriffonClassUtils.java</span></div><h1>GriffonClassUtils.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2008-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package griffon.util;

import griffon.core.Observable;
import griffon.core.Vetoable;
import griffon.core.artifact.GriffonArtifact;
import griffon.core.artifact.GriffonMvcArtifact;
import griffon.core.event.EventPublisher;
import griffon.core.i18n.MessageSource;
import griffon.core.mvc.MVCHandler;
import griffon.core.resources.ResourceHandler;
import griffon.core.resources.ResourceResolver;
import griffon.core.threading.ThreadingHandler;
import griffon.exceptions.BeanInstantiationException;
import griffon.exceptions.FieldException;
import griffon.exceptions.InstanceMethodInvocationException;
import griffon.exceptions.PropertyException;
import griffon.exceptions.StaticMethodInvocationException;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.regex.Pattern;

import static griffon.util.GriffonNameUtils.requireNonBlank;
import static griffon.util.MethodUtils.invokeExactMethod;
import static griffon.util.MethodUtils.invokeMethod;
import static java.util.Objects.requireNonNull;

/**
 * Class containing utility methods for dealing with Griffon class artifacts.&lt;p&gt;
 * Contains utility methods copied from commons-lang and commons-beanutils in order
 * to reduce dependencies on external libraries.&lt;p&gt;
 * &lt;p&gt;
 * &lt;b&gt;Contains code copied from commons-beanutils and commons-langs&lt;/b&gt;
 *
 * @author Graeme Rocher (Grails 0.1)
 */
<span class="nc" id="L75">public class GriffonClassUtils {</span>
<span class="fc" id="L76">    public static final Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = new Class&lt;?&gt;[0];</span>
<span class="fc" id="L77">    public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];</span>
<span class="fc" id="L78">    public static final Object[] EMPTY_ARGS = EMPTY_OBJECT_ARRAY;</span>

    private static final String PROPERTY_GET_PREFIX = &quot;get&quot;;
    private static final String PROPERTY_IS_PREFIX = &quot;is&quot;;
    private static final String PROPERTY_SET_PREFIX = &quot;set&quot;;
    private static final String ON_SHUTDOWN_METHOD_NAME = &quot;onShutdown&quot;;
<span class="fc" id="L84">    public static final Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; PRIMITIVE_TYPE_COMPATIBLE_CLASSES = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L85">    public static final Map&lt;String, String&gt; PRIMITIVE_TYPE_COMPATIBLE_TYPES = new LinkedHashMap&lt;&gt;();</span>

<span class="fc" id="L87">    private static final Pattern EVENT_HANDLER_PATTERN = Pattern.compile(&quot;^on[A-Z][\\w]*$&quot;);</span>
<span class="fc" id="L88">    private static final Pattern CONTRIBUTION_PATTERN = Pattern.compile(&quot;^with[A-Z][a-z0-9_]*[\\w]*$&quot;);</span>
<span class="fc" id="L89">    private static final Pattern GETTER_PATTERN_1 = Pattern.compile(&quot;^get[A-Z][\\w]*$&quot;);</span>
<span class="fc" id="L90">    private static final Pattern GETTER_PATTERN_2 = Pattern.compile(&quot;^is[A-Z][\\w]*$&quot;);</span>
<span class="fc" id="L91">    private static final Pattern SETTER_PATTERN = Pattern.compile(&quot;^set[A-Z][\\w]*$&quot;);</span>
<span class="fc" id="L92">    private static final Set&lt;MethodDescriptor&gt; BASIC_METHODS = new TreeSet&lt;&gt;();</span>
<span class="fc" id="L93">    private static final Set&lt;MethodDescriptor&gt; ARTIFACT_METHODS = new TreeSet&lt;&gt;();</span>
<span class="fc" id="L94">    private static final Set&lt;MethodDescriptor&gt; MVC_METHODS = new TreeSet&lt;&gt;();</span>
<span class="fc" id="L95">    private static final Set&lt;MethodDescriptor&gt; THREADING_METHODS = new TreeSet&lt;&gt;();</span>
<span class="fc" id="L96">    private static final Set&lt;MethodDescriptor&gt; EVENT_PUBLISHER_METHODS = new TreeSet&lt;&gt;();</span>
<span class="fc" id="L97">    private static final Set&lt;MethodDescriptor&gt; OBSERVABLE_METHODS = new TreeSet&lt;&gt;();</span>
<span class="fc" id="L98">    private static final Set&lt;MethodDescriptor&gt; RESOURCE_HANDLER_METHODS = new TreeSet&lt;&gt;();</span>
<span class="fc" id="L99">    private static final Set&lt;MethodDescriptor&gt; MESSAGE_SOURCE_METHODS = new TreeSet&lt;&gt;();</span>
<span class="fc" id="L100">    private static final Set&lt;MethodDescriptor&gt; RESOURCE_RESOLVER_METHODS = new TreeSet&lt;&gt;();</span>
    private static final String ERROR_TYPE_NULL = &quot;Argument 'type' must not be null&quot;;
    private static final String ERROR_METHOD_NAME_BLANK = &quot;Argument 'methodName' must not be blank&quot;;
    private static final String ERROR_OBJECT_NULL = &quot;Argument 'object' must not be null&quot;;
    private static final String ERROR_CLAZZ_NULL = &quot;Argument 'clazz' must not be null&quot;;
    private static final String ERROR_DESCRIPTOR_NULL = &quot;Argument 'descriptor' must not be null&quot;;
    private static final String ERROR_BEAN_NULL = &quot;Argument 'bean' must not be null&quot;;
    private static final String ERROR_NAME_BLANK = &quot;Argument 'name' must not be blank&quot;;
    private static final String ERROR_PROPERTIES_NULL = &quot;Argument 'properties' must not be null&quot;;
    private static final String ERROR_FIELDS_NULL = &quot;Argument 'fields' must not be null&quot;;
    private static final String ERROR_PROPERTY_NAME_BLANK = &quot;Argument 'propertyName' must not be blank&quot;;
    private static final String ERROR_METHOD_NULL = &quot;Argument 'method' must not be null&quot;;

    /**
     * Just add two entries to the class compatibility map
     *
     * @param left
     * @param right
     */
    private static void registerPrimitiveClassPair(Class&lt;?&gt; left, Class&lt;?&gt; right) {
<span class="fc" id="L120">        PRIMITIVE_TYPE_COMPATIBLE_CLASSES.put(left, right);</span>
<span class="fc" id="L121">        PRIMITIVE_TYPE_COMPATIBLE_CLASSES.put(right, left);</span>
<span class="fc" id="L122">        PRIMITIVE_TYPE_COMPATIBLE_TYPES.put(left.getName(), right.getName());</span>
<span class="fc" id="L123">        PRIMITIVE_TYPE_COMPATIBLE_TYPES.put(right.getName(), left.getName());</span>
<span class="fc" id="L124">    }</span>

    static {
<span class="fc" id="L127">        registerPrimitiveClassPair(Boolean.class, boolean.class);</span>
<span class="fc" id="L128">        registerPrimitiveClassPair(Integer.class, int.class);</span>
<span class="fc" id="L129">        registerPrimitiveClassPair(Short.class, short.class);</span>
<span class="fc" id="L130">        registerPrimitiveClassPair(Byte.class, byte.class);</span>
<span class="fc" id="L131">        registerPrimitiveClassPair(Character.class, char.class);</span>
<span class="fc" id="L132">        registerPrimitiveClassPair(Long.class, long.class);</span>
<span class="fc" id="L133">        registerPrimitiveClassPair(Float.class, float.class);</span>
<span class="fc" id="L134">        registerPrimitiveClassPair(Double.class, double.class);</span>

<span class="fc bfc" id="L136" title="All 2 branches covered.">        for (Method method : Object.class.getMethods()) {</span>
<span class="fc" id="L137">            MethodDescriptor md = MethodDescriptor.forMethod(method);</span>
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">            if (!BASIC_METHODS.contains(md)) {</span>
<span class="fc" id="L139">                BASIC_METHODS.add(md);</span>
            }
        }

        try {
<span class="fc" id="L144">            Class groovyObjectClass = GriffonClassUtils.class.getClassLoader().loadClass(&quot;groovy.lang.GroovyObject&quot;);</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">            for (Method method : groovyObjectClass.getMethods()) {</span>
<span class="fc" id="L146">                MethodDescriptor md = MethodDescriptor.forMethod(method, true);</span>
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">                if (!BASIC_METHODS.contains(md)) {</span>
<span class="fc" id="L148">                    BASIC_METHODS.add(md);</span>
                }
            }
<span class="nc" id="L151">        } catch (ClassNotFoundException cnfe) {</span>
            // ignore
<span class="fc" id="L153">        }</span>

        try {
<span class="fc" id="L156">            Class groovyObjectClass = GriffonClassUtils.class.getClassLoader().loadClass(&quot;groovy.lang.GroovyObjectSupport&quot;);</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">            for (Method method : groovyObjectClass.getMethods()) {</span>
<span class="fc" id="L158">                MethodDescriptor md = MethodDescriptor.forMethod(method);</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">                if (!BASIC_METHODS.contains(md)) {</span>
<span class="nc" id="L160">                    BASIC_METHODS.add(md);</span>
                }
            }
<span class="nc" id="L163">        } catch (ClassNotFoundException cnfe) {</span>
            // ignore
<span class="fc" id="L165">        }</span>

<span class="fc bfc" id="L167" title="All 2 branches covered.">        for (Method method : GriffonArtifact.class.getMethods()) {</span>
<span class="fc" id="L168">            MethodDescriptor md = MethodDescriptor.forMethod(method, true);</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">            if (!ARTIFACT_METHODS.contains(md)) {</span>
<span class="fc" id="L170">                ARTIFACT_METHODS.add(md);</span>
            }
        }

        // MVC_METHODS.add(new MethodDescriptor(&quot;getMvcGroup&quot;));
<span class="fc bfc" id="L175" title="All 2 branches covered.">        for (Method method : MVCHandler.class.getMethods()) {</span>
<span class="fc" id="L176">            MethodDescriptor md = MethodDescriptor.forMethod(method, true);</span>
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">            if (!MVC_METHODS.contains(md)) {</span>
<span class="fc" id="L178">                MVC_METHODS.add(md);</span>
            }
        }
<span class="fc bfc" id="L181" title="All 2 branches covered.">        for (Method method : GriffonMvcArtifact.class.getMethods()) {</span>
<span class="fc" id="L182">            MethodDescriptor md = MethodDescriptor.forMethod(method, true);</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">            if (!MVC_METHODS.contains(md)) {</span>
<span class="fc" id="L184">                MVC_METHODS.add(md);</span>
            }
        }

        // GriffonView
<span class="fc" id="L189">        MVC_METHODS.add(new MethodDescriptor(&quot;initUI&quot;));</span>
        // GriffonController
<span class="fc" id="L191">        MVC_METHODS.add(new MethodDescriptor(&quot;invokeAction&quot;, new Class&lt;?&gt;[]{String.class, Object[].class}));</span>
<span class="fc" id="L192">        MVC_METHODS.add(new MethodDescriptor(&quot;invokeAction&quot;, new Class&lt;?&gt;[]{String.class, Object[].class}, Modifier.PUBLIC | Modifier.TRANSIENT));</span>

<span class="fc bfc" id="L194" title="All 2 branches covered.">        for (Method method : ThreadingHandler.class.getMethods()) {</span>
<span class="fc" id="L195">            MethodDescriptor md = MethodDescriptor.forMethod(method, true);</span>
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">            if (!THREADING_METHODS.contains(md)) {</span>
<span class="fc" id="L197">                THREADING_METHODS.add(md);</span>
            }
        }
        // Special case due to the usage of varargs
        //THREADING_METHODS.add(new MethodDescriptor(&quot;runFuture&quot;, new Class&lt;?&gt;[]{Object[].class}));

<span class="fc bfc" id="L203" title="All 2 branches covered.">        for (Method method : EventPublisher.class.getMethods()) {</span>
<span class="fc" id="L204">            MethodDescriptor md = MethodDescriptor.forMethod(method, true);</span>
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">            if (!EVENT_PUBLISHER_METHODS.contains(md)) {</span>
<span class="fc" id="L206">                EVENT_PUBLISHER_METHODS.add(md);</span>
            }
        }

<span class="fc bfc" id="L210" title="All 2 branches covered.">        for (Method method : Observable.class.getMethods()) {</span>
<span class="fc" id="L211">            MethodDescriptor md = MethodDescriptor.forMethod(method, true);</span>
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">            if (!OBSERVABLE_METHODS.contains(md)) {</span>
<span class="fc" id="L213">                OBSERVABLE_METHODS.add(md);</span>
            }
        }
<span class="fc bfc" id="L216" title="All 2 branches covered.">        for (Method method : Vetoable.class.getMethods()) {</span>
<span class="fc" id="L217">            MethodDescriptor md = MethodDescriptor.forMethod(method, true);</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">            if (!OBSERVABLE_METHODS.contains(md)) {</span>
<span class="fc" id="L219">                OBSERVABLE_METHODS.add(md);</span>
            }
        }

<span class="fc bfc" id="L223" title="All 2 branches covered.">        for (Method method : ResourceHandler.class.getMethods()) {</span>
<span class="fc" id="L224">            MethodDescriptor md = MethodDescriptor.forMethod(method, true);</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">            if (!RESOURCE_HANDLER_METHODS.contains(md)) {</span>
<span class="fc" id="L226">                RESOURCE_HANDLER_METHODS.add(md);</span>
            }
        }

<span class="fc bfc" id="L230" title="All 2 branches covered.">        for (Method method : MessageSource.class.getMethods()) {</span>
<span class="fc" id="L231">            MethodDescriptor md = MethodDescriptor.forMethod(method, true);</span>
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">            if (!MESSAGE_SOURCE_METHODS.contains(md)) {</span>
<span class="fc" id="L233">                MESSAGE_SOURCE_METHODS.add(md);</span>
            }
        }

<span class="fc bfc" id="L237" title="All 2 branches covered.">        for (Method method : ResourceResolver.class.getMethods()) {</span>
<span class="fc" id="L238">            MethodDescriptor md = MethodDescriptor.forMethod(method, true);</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">            if (!RESOURCE_RESOLVER_METHODS.contains(md)) {</span>
<span class="fc" id="L240">                RESOURCE_RESOLVER_METHODS.add(md);</span>
            }
        }
    }

    /**
     * Checks that the specified condition is met. This method is designed
     * primarily for doing parameter validation in methods and constructors,
     * as demonstrated below:
     * &lt;blockquote&gt;&lt;pre&gt;
     * public Foo(int[] array) {
     *     GriffonClassUtils.requireState(array.length &gt; 0);
     * }
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @param condition the condition to check
     * @throws IllegalStateException if {@code condition} evaluates to false
     */
    public static void requireState(boolean condition) {
<span class="nc bnc" id="L259" title="All 2 branches missed.">        if (!condition) {</span>
<span class="nc" id="L260">            throw new IllegalStateException();</span>
        }
<span class="nc" id="L262">    }</span>

    /**
     * Checks that the specified condition is met and throws a customized
     * {@link IllegalStateException} if it is. This method is designed primarily
     * for doing parameter validation in methods and constructors with multiple
     * parameters, as demonstrated below:
     * &lt;blockquote&gt;&lt;pre&gt;
     * public Foo(int[] array) {
     *     GriffonClassUtils.requireState(array.length &gt; 0, &quot;array must not be empty&quot;);
     * }
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @param condition the condition to check
     * @param message   detail message to be used in the event that a {@code
     *                  IllegalStateException} is thrown
     * @throws IllegalStateException if {@code condition} evaluates to false
     */
    public static void requireState(boolean condition, String message) {
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">        if (!condition) {</span>
<span class="nc" id="L282">            throw new IllegalStateException(message);</span>
        }
<span class="fc" id="L284">    }</span>

    /**
     * Checks that the specified array is not empty, throwing a
     * {@link IllegalStateException} if it is.
     *
     * @param array the array to check
     * @throws NullPointerException  if {@code array} is null
     * @throws IllegalStateException if {@code array} is empty
     */
    public static byte[] requireNonEmpty(@Nonnull byte[] array) {
<span class="nc" id="L295">        requireNonNull(array);</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">        requireState(array.length != 0);</span>
<span class="nc" id="L297">        return array;</span>
    }

    /**
     * Checks that the specified array is not empty, throwing a customized
     * {@link IllegalStateException} if it is.
     *
     * @param array   the array to check
     * @param message detail message to be used in the event that a {@code
     *                IllegalStateException} is thrown
     * @throws NullPointerException     if {@code array} is null
     * @throws IllegalArgumentException if {@code message} is {@code blank}
     * @throws IllegalStateException    if {@code array} is empty
     */
    public static byte[] requireNonEmpty(@Nonnull byte[] array, @Nonnull String message) {
<span class="nc" id="L312">        requireNonNull(array);</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">        requireState(array.length != 0, requireNonBlank(message, &quot;message&quot;));</span>
<span class="nc" id="L314">        return array;</span>
    }

    /**
     * Checks that the specified array is not empty, throwing a
     * {@link IllegalStateException} if it is.
     *
     * @param array the array to check
     * @throws NullPointerException  if {@code array} is null
     * @throws IllegalStateException if {@code array} is empty
     */
    public static short[] requireNonEmpty(@Nonnull short[] array) {
<span class="nc" id="L326">        requireNonNull(array);</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">        requireState(array.length != 0);</span>
<span class="nc" id="L328">        return array;</span>
    }

    /**
     * Checks that the specified array is not empty, throwing a customized
     * {@link IllegalStateException} if it is.
     *
     * @param array   the array to check
     * @param message detail message to be used in the event that a {@code
     *                IllegalStateException} is thrown
     * @throws NullPointerException     if {@code array} is null
     * @throws IllegalArgumentException if {@code message} is {@code blank}
     * @throws IllegalStateException    if {@code array} is empty
     */
    public static short[] requireNonEmpty(@Nonnull short[] array, @Nonnull String message) {
<span class="nc" id="L343">        requireNonNull(array);</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">        requireState(array.length != 0, requireNonBlank(message, &quot;message&quot;));</span>
<span class="nc" id="L345">        return array;</span>
    }

    /**
     * Checks that the specified array is not empty, throwing a
     * {@link IllegalStateException} if it is.
     *
     * @param array the array to check
     * @throws NullPointerException  if {@code array} is null
     * @throws IllegalStateException if {@code array} is empty
     */
    public static int[] requireNonEmpty(@Nonnull int[] array) {
<span class="nc" id="L357">        requireNonNull(array);</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">        requireState(array.length != 0);</span>
<span class="nc" id="L359">        return array;</span>
    }

    /**
     * Checks that the specified array is not empty, throwing a customized
     * {@link IllegalStateException} if it is.
     *
     * @param array   the array to check
     * @param message detail message to be used in the event that a {@code
     *                IllegalStateException} is thrown
     * @throws NullPointerException     if {@code array} is null
     * @throws IllegalArgumentException if {@code message} is {@code blank}
     * @throws IllegalStateException    if {@code array} is empty
     */
    public static int[] requireNonEmpty(@Nonnull int[] array, @Nonnull String message) {
<span class="nc" id="L374">        requireNonNull(array);</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">        requireState(array.length != 0, requireNonBlank(message, &quot;message&quot;));</span>
<span class="nc" id="L376">        return array;</span>
    }

    /**
     * Checks that the specified array is not empty, throwing a
     * {@link IllegalStateException} if it is.
     *
     * @param array the array to check
     * @throws NullPointerException  if {@code array} is null
     * @throws IllegalStateException if {@code array} is empty
     */
    public static long[] requireNonEmpty(@Nonnull long[] array) {
<span class="nc" id="L388">        requireNonNull(array);</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">        requireState(array.length != 0);</span>
<span class="nc" id="L390">        return array;</span>
    }

    /**
     * Checks that the specified array is not empty, throwing a customized
     * {@link IllegalStateException} if it is.
     *
     * @param array   the array to check
     * @param message detail message to be used in the event that a {@code
     *                IllegalStateException} is thrown
     * @throws NullPointerException     if {@code array} is null
     * @throws IllegalArgumentException if {@code message} is {@code blank}
     * @throws IllegalStateException    if {@code array} is empty
     */
    public static long[] requireNonEmpty(@Nonnull long[] array, @Nonnull String message) {
<span class="nc" id="L405">        requireNonNull(array);</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">        requireState(array.length != 0, requireNonBlank(message, &quot;message&quot;));</span>
<span class="nc" id="L407">        return array;</span>
    }

    /**
     * Checks that the specified array is not empty, throwing a
     * {@link IllegalStateException} if it is.
     *
     * @param array the array to check
     * @throws NullPointerException  if {@code array} is null
     * @throws IllegalStateException if {@code array} is empty
     */
    public static float[] requireNonEmpty(@Nonnull float[] array) {
<span class="nc" id="L419">        requireNonNull(array);</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">        requireState(array.length != 0);</span>
<span class="nc" id="L421">        return array;</span>
    }

    /**
     * Checks that the specified array is not empty, throwing a customized
     * {@link IllegalStateException} if it is.
     *
     * @param array   the array to check
     * @param message detail message to be used in the event that a {@code
     *                IllegalStateException} is thrown
     * @throws NullPointerException     if {@code array} is null
     * @throws IllegalArgumentException if {@code message} is {@code blank}
     * @throws IllegalStateException    if {@code array} is empty
     */
    public static float[] requireNonEmpty(@Nonnull float[] array, @Nonnull String message) {
<span class="nc" id="L436">        requireNonNull(array);</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">        requireState(array.length != 0, requireNonBlank(message, &quot;message&quot;));</span>
<span class="nc" id="L438">        return array;</span>
    }

    /**
     * Checks that the specified array is not empty, throwing a
     * {@link IllegalStateException} if it is.
     *
     * @param array the array to check
     * @throws NullPointerException  if {@code array} is null
     * @throws IllegalStateException if {@code array} is empty
     */
    public static double[] requireNonEmpty(@Nonnull double[] array) {
<span class="nc" id="L450">        requireNonNull(array);</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">        requireState(array.length != 0);</span>
<span class="nc" id="L452">        return array;</span>
    }

    /**
     * Checks that the specified array is not empty, throwing a customized
     * {@link IllegalStateException} if it is.
     *
     * @param array   the array to check
     * @param message detail message to be used in the event that a {@code
     *                IllegalStateException} is thrown
     * @throws NullPointerException     if {@code array} is null
     * @throws IllegalArgumentException if {@code message} is {@code blank}
     * @throws IllegalStateException    if {@code array} is empty
     */
    public static double[] requireNonEmpty(@Nonnull double[] array, @Nonnull String message) {
<span class="nc" id="L467">        requireNonNull(array);</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">        requireState(array.length != 0, requireNonBlank(message, &quot;message&quot;));</span>
<span class="nc" id="L469">        return array;</span>
    }

    /**
     * Checks that the specified array is not empty, throwing a
     * {@link IllegalStateException} if it is.
     *
     * @param array the array to check
     * @throws NullPointerException  if {@code array} is null
     * @throws IllegalStateException if {@code array} is empty
     */
    public static char[] requireNonEmpty(@Nonnull char[] array) {
<span class="nc" id="L481">        requireNonNull(array);</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">        requireState(array.length != 0);</span>
<span class="nc" id="L483">        return array;</span>
    }

    /**
     * Checks that the specified array is not empty, throwing a customized
     * {@link IllegalStateException} if it is.
     *
     * @param array   the array to check
     * @param message detail message to be used in the event that a {@code
     *                IllegalStateException} is thrown
     * @throws NullPointerException     if {@code array} is null
     * @throws IllegalArgumentException if {@code message} is {@code blank}
     * @throws IllegalStateException    if {@code array} is empty
     */
    public static char[] requireNonEmpty(@Nonnull char[] array, @Nonnull String message) {
<span class="nc" id="L498">        requireNonNull(array);</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">        requireState(array.length != 0, requireNonBlank(message, &quot;message&quot;));</span>
<span class="nc" id="L500">        return array;</span>
    }

    /**
     * Checks that the specified array is not empty, throwing a
     * {@link IllegalStateException} if it is.
     *
     * @param array the array to check
     * @throws NullPointerException  if {@code array} is null
     * @throws IllegalStateException if {@code array} is empty
     */
    public static boolean[] requireNonEmpty(@Nonnull boolean[] array) {
<span class="nc" id="L512">        requireNonNull(array);</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">        requireState(array.length != 0);</span>
<span class="nc" id="L514">        return array;</span>
    }

    /**
     * Checks that the specified array is not empty, throwing a customized
     * {@link IllegalStateException} if it is.
     *
     * @param array   the array to check
     * @param message detail message to be used in the event that a {@code
     *                IllegalStateException} is thrown
     * @throws NullPointerException     if {@code array} is null
     * @throws IllegalArgumentException if {@code message} is {@code blank}
     * @throws IllegalStateException    if {@code array} is empty
     */
    public static boolean[] requireNonEmpty(@Nonnull boolean[] array, @Nonnull String message) {
<span class="nc" id="L529">        requireNonNull(array);</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">        requireState(array.length != 0, requireNonBlank(message, &quot;message&quot;));</span>
<span class="nc" id="L531">        return array;</span>
    }

    /**
     * Checks that the specified array is not empty, throwing a
     * {@link IllegalStateException} if it is.
     *
     * @param array the array to check
     * @throws NullPointerException  if {@code array} is null
     * @throws IllegalStateException if {@code array} is empty
     */
    public static &lt;E&gt; E[] requireNonEmpty(@Nonnull E[] array) {
<span class="nc" id="L543">        requireNonNull(array);</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">        requireState(array.length != 0);</span>
<span class="nc" id="L545">        return array;</span>
    }

    /**
     * Checks that the specified array is not empty, throwing a customized
     * {@link IllegalStateException} if it is.
     *
     * @param array   the array to check
     * @param message detail message to be used in the event that a {@code
     *                IllegalStateException} is thrown
     * @throws NullPointerException     if {@code array} is null
     * @throws IllegalArgumentException if {@code message} is {@code blank}
     * @throws IllegalStateException    if {@code array} is empty
     */
    public static &lt;E&gt; E[] requireNonEmpty(@Nonnull E[] array, @Nonnull String message) {
<span class="fc" id="L560">        requireNonNull(array);</span>
<span class="pc bpc" id="L561" title="1 of 2 branches missed.">        requireState(array.length != 0, requireNonBlank(message, &quot;message&quot;));</span>
<span class="fc" id="L562">        return array;</span>
    }

    /**
     * Checks that the specified collection is not empty, throwing a
     * {@link IllegalStateException} if it is.
     *
     * @param collection the collection to check
     * @throws NullPointerException  if {@code collection} is null
     * @throws IllegalStateException if {@code collection} is empty
     */
    public static Collection&lt;?&gt; requireNonEmpty(@Nonnull Collection&lt;?&gt; collection) {
<span class="nc" id="L574">        requireNonNull(collection);</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">        requireState(!collection.isEmpty());</span>
<span class="nc" id="L576">        return collection;</span>
    }

    /**
     * Checks that the specified collection is not empty, throwing a customized
     * {@link IllegalStateException} if it is.
     *
     * @param collection the collection to check
     * @param message    detail message to be used in the event that a {@code
     *                   IllegalStateException} is thrown
     * @throws NullPointerException     if {@code collection} is null
     * @throws IllegalArgumentException if {@code message} is {@code blank}
     * @throws IllegalStateException    if {@code collection} is empty
     */
    public static Collection&lt;?&gt; requireNonEmpty(@Nonnull Collection&lt;?&gt; collection, @Nonnull String message) {
<span class="nc" id="L591">        requireNonNull(collection);</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">        requireState(!collection.isEmpty(), requireNonBlank(message, &quot;message&quot;));</span>
<span class="nc" id="L593">        return collection;</span>
    }

    /**
     * Checks that the specified map is not empty, throwing a
     * {@link IllegalStateException} if it is.
     *
     * @param map the map to check
     * @throws NullPointerException  if {@code map} is null
     * @throws IllegalStateException if {@code map} is empty
     */
    public static Map&lt;?, ?&gt; requireNonEmpty(@Nonnull Map&lt;?, ?&gt; map) {
<span class="nc" id="L605">        requireNonNull(map);</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">        requireState(!map.isEmpty());</span>
<span class="nc" id="L607">        return map;</span>
    }

    /**
     * Checks that the specified map is not empty, throwing a customized
     * {@link IllegalStateException} if it is.
     *
     * @param map     the map to check
     * @param message detail message to be used in the event that a {@code
     *                IllegalStateException} is thrown
     * @throws NullPointerException     if {@code map} is null
     * @throws IllegalArgumentException if {@code message} is {@code blank}
     * @throws IllegalStateException    if {@code map} is empty
     */
    public static Map&lt;?, ?&gt; requireNonEmpty(@Nonnull Map&lt;?, ?&gt; map, @Nonnull String message) {
<span class="nc" id="L622">        requireNonNull(map);</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">        requireState(!map.isEmpty(), requireNonBlank(message, &quot;message&quot;));</span>
<span class="nc" id="L624">        return map;</span>
    }

    /**
     * Finds out if the given string represents the name of an
     * event handler by matching against the following pattern:
     * &quot;^on[A-Z][\\w]*$&quot;&lt;p&gt;
     * &lt;p&gt;
     * &lt;pre&gt;
     * isEventHandler(&quot;onBootstrapEnd&quot;) = true
     * isEventHandler(&quot;mvcGroupInit&quot;)   = false
     * isEventHandler(&quot;online&quot;)         = false
     * &lt;/pre&gt;
     *
     * @param name the name of a possible event handler
     * @return true if the name matches the given event handler
     * pattern, false otherwise.
     */
    public static boolean isEventHandler(@Nonnull String name) {
<span class="fc" id="L643">        requireNonBlank(name, ERROR_NAME_BLANK);</span>
<span class="pc bpc" id="L644" title="1 of 2 branches missed.">        return EVENT_HANDLER_PATTERN.matcher(name).matches() &amp;&amp;</span>
<span class="pc bnc" id="L645" title="All 2 branches missed.">            !ON_SHUTDOWN_METHOD_NAME.equals(name);</span>
    }

    /**
     * Finds out if the given Method represents an event handler
     * by matching its name against the following pattern:
     * &quot;^on[A-Z][\\w]*$&quot;&lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate Method reference
     * isEventHandler(getMethod(&quot;onBootstrapEnd&quot;)) = true
     * isEventHandler(getMethod(&quot;mvcGroupInit&quot;))   = false
     * isEventHandler(getMethod(&quot;online&quot;))         = false
     * &lt;/pre&gt;
     *
     * @param method a Method reference
     * @return true if the method name matches the given event handler
     * pattern, false otherwise.
     */
    public static boolean isEventHandler(@Nonnull Method method) {
<span class="nc" id="L664">        return isEventHandler(method, false);</span>
    }

    /**
     * Finds out if the given Method represents an event handler
     * by matching its name against the following pattern:
     * &quot;^on[A-Z][\\w]*$&quot;&lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate Method reference
     * isEventHandler(getMethod(&quot;onBootstrapEnd&quot;)) = true
     * isEventHandler(getMethod(&quot;mvcGroupInit&quot;))   = false
     * isEventHandler(getMethod(&quot;online&quot;))         = false
     * &lt;/pre&gt;
     *
     * @param method a Method reference
     * @return true if the method name matches the given event handler
     * pattern, false otherwise.
     */
    public static boolean isEventHandler(@Nonnull Method method, boolean removeAbstractModifier) {
<span class="nc" id="L683">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="nc" id="L684">        return isEventHandler(MethodDescriptor.forMethod(method, removeAbstractModifier));</span>
    }

    /**
     * Finds out if the given Method represents an event handler
     * by matching its name against the following pattern:
     * &quot;^on[A-Z][\\w]*$&quot;&lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate MethodDescriptor reference
     * isEventHandler(getMethod(&quot;onBootstrapEnd&quot;)) = true
     * isEventHandler(getMethod(&quot;mvcGroupInit&quot;))   = false
     * isEventHandler(getMethod(&quot;online&quot;))         = false
     * &lt;/pre&gt;
     *
     * @param method a MethodDescriptor reference
     * @return true if the method name matches the given event handler
     * pattern, false otherwise.
     */
    public static boolean isEventHandler(@Nonnull MethodDescriptor method) {
<span class="fc" id="L703">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="pc bpc" id="L704" title="1 of 2 branches missed.">        return isInstanceMethod(method) &amp;&amp;</span>
<span class="pc bpc" id="L705" title="1 of 2 branches missed.">            isEventHandler(method.getName());</span>
    }

    /**
     * Finds out if the given {@code Method} belongs either to the
     * {@code Object} class or the {@code GroovyObject} class.&lt;p&gt;
     *
     * @param method a Method reference
     * @return true if the method belongs to {@code Object} or
     * {@code GroovyObject}, false otherwise.
     */
    public static boolean isBasicMethod(@Nonnull Method method) {
<span class="nc" id="L717">        return isBasicMethod(method, false);</span>
    }

    /**
     * Finds out if the given {@code Method} belongs either to the
     * {@code Object} class or the {@code GroovyObject} class.&lt;p&gt;
     *
     * @param method a Method reference
     * @return true if the method belongs to {@code Object} or
     * {@code GroovyObject}, false otherwise.
     */
    public static boolean isBasicMethod(@Nonnull Method method, boolean removeAbstractModifier) {
<span class="nc" id="L729">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="nc" id="L730">        return isBasicMethod(MethodDescriptor.forMethod(method, removeAbstractModifier));</span>
    }

    /**
     * Finds out if the given {@code MethodDescriptor} belongs either to the
     * {@code Object} class or the {@code GroovyObject} class.&lt;p&gt;
     *
     * @param method a MethodDescriptor reference
     * @return true if the method belongs to {@code Object} or
     * {@code GroovyObject}, false otherwise.
     */
    public static boolean isBasicMethod(@Nonnull MethodDescriptor method) {
<span class="fc" id="L742">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="pc bpc" id="L743" title="1 of 4 branches missed.">        return isInstanceMethod(method) &amp;&amp; BASIC_METHODS.contains(method);</span>
    }

    /**
     * Finds out if the given string represents the name of a
     * contribution method by matching against the following pattern:
     * &quot;^with[A-Z][a-z0-9_]*[\w]*$&quot;&lt;p&gt;
     * &lt;p&gt;
     * &lt;pre&gt;
     * isContributionMethod(&quot;withRest&quot;)     = true
     * isContributionMethod(&quot;withMVCGroup&quot;) = false
     * isContributionMethod(&quot;without&quot;)      = false
     * &lt;/pre&gt;
     *
     * @param name the name of a possible contribution method
     * @return true if the name matches the given contribution method
     * pattern, false otherwise.
     */
    public static boolean isContributionMethod(@Nonnull String name) {
<span class="nc" id="L762">        requireNonBlank(name, ERROR_NAME_BLANK);</span>
<span class="nc" id="L763">        return CONTRIBUTION_PATTERN.matcher(name).matches();</span>
    }

    /**
     * Finds out if the given Method represents a contribution method
     * by matching its name against the following pattern:
     * &quot;^with[A-Z][a-z0-9_]*[\w]*$&quot;&lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate Method reference
     * isContributionMethod(getMethod(&quot;withRest&quot;))     = true
     * isContributionMethod(getMethod(&quot;withMVCGroup&quot;)) = false
     * isContributionMethod(getMethod(&quot;without&quot;))      = false
     * &lt;/pre&gt;
     *
     * @param method a Method reference
     * @return true if the method name matches the given contribution method
     * pattern, false otherwise.
     */
    public static boolean isContributionMethod(@Nonnull Method method) {
<span class="nc" id="L782">        return isContributionMethod(method, false);</span>
    }

    /**
     * Finds out if the given Method represents a contribution method
     * by matching its name against the following pattern:
     * &quot;^with[A-Z][a-z0-9_]*[\w]*$&quot;&lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate Method reference
     * isContributionMethod(getMethod(&quot;withRest&quot;))     = true
     * isContributionMethod(getMethod(&quot;withMVCGroup&quot;)) = false
     * isContributionMethod(getMethod(&quot;without&quot;))      = false
     * &lt;/pre&gt;
     *
     * @param method a Method reference
     * @return true if the method name matches the given contribution method
     * pattern, false otherwise.
     */
    public static boolean isContributionMethod(@Nonnull Method method, boolean removeAbstractModifier) {
<span class="nc" id="L801">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="nc" id="L802">        return isContributionMethod(MethodDescriptor.forMethod(method, removeAbstractModifier));</span>
    }

    /**
     * Finds out if the given Method represents a contribution method
     * by matching its name against the following pattern:
     * &quot;^with[A-Z][a-z0-9_]*[\w]*$&quot;&lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate MethodDescriptor reference
     * isContributionMethod(getMethod(&quot;withRest&quot;))     = true
     * isContributionMethod(getMethod(&quot;withMVCGroup&quot;)) = false
     * isContributionMethod(getMethod(&quot;without&quot;))      = false
     * &lt;/pre&gt;
     *
     * @param method a MethodDescriptor reference
     * @return true if the method name matches the given contribution method
     * pattern, false otherwise.
     */
    public static boolean isContributionMethod(@Nonnull MethodDescriptor method) {
<span class="fc" id="L821">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="pc bpc" id="L822" title="1 of 2 branches missed.">        return isInstanceMethod(method) &amp;&amp;</span>
<span class="pc bpc" id="L823" title="1 of 2 branches missed.">            CONTRIBUTION_PATTERN.matcher(method.getName()).matches();</span>
    }

    /**
     * Finds out if the given {@code Method} was injected by the Groovy
     * compiler.&lt;p&gt;
     * Performs a basic checks against the method's name, returning true
     * if the name starts with either &quot;super$&quot; or &quot;this$&quot;.
     *
     * @param method a Method reference
     * @return true if the method matches the given criteria, false otherwise.
     */
    public static boolean isGroovyInjectedMethod(@Nonnull Method method) {
<span class="nc" id="L836">        return isGroovyInjectedMethod(method, false);</span>
    }

    /**
     * Finds out if the given {@code Method} was injected by the Groovy
     * compiler.&lt;p&gt;
     * Performs a basic checks against the method's name, returning true
     * if the name starts with either &quot;super$&quot; or &quot;this$&quot;.
     *
     * @param method a Method reference
     * @return true if the method matches the given criteria, false otherwise.
     */
    public static boolean isGroovyInjectedMethod(@Nonnull Method method, boolean removeAbstractModifier) {
<span class="nc" id="L849">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="nc" id="L850">        return isGroovyInjectedMethod(MethodDescriptor.forMethod(method, removeAbstractModifier));</span>
    }

    /**
     * Finds out if the given {@code MethodDescriptor} was injected by the Groovy
     * compiler.&lt;p&gt;
     * Performs a basic checks against the method's name, returning true
     * if the name starts with either &quot;super$&quot; or &quot;this$&quot;.
     *
     * @param method a MethodDescriptor reference
     * @return true if the method matches the given criteria, false otherwise.
     */
    public static boolean isGroovyInjectedMethod(@Nonnull MethodDescriptor method) {
<span class="fc" id="L863">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="pc bpc" id="L864" title="1 of 2 branches missed.">        return isInstanceMethod(method) &amp;&amp;</span>
<span class="pc bpc" id="L865" title="2 of 4 branches missed.">            (method.getName().startsWith(&quot;super$&quot;) || method.getName().startsWith(&quot;this$&quot;));</span>
    }

    /**
     * Finds out if the given {@code Method} is a getter method.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate Method reference
     * isGetterMethod(getMethod(&quot;getFoo&quot;))       = true
     * isGetterMethod(getMethod(&quot;getfoo&quot;) )      = false
     * isGetterMethod(getMethod(&quot;mvcGroupInit&quot;)) = false
     * isGetterMethod(getMethod(&quot;isFoo&quot;))        = true
     * isGetterMethod(getMethod(&quot;island&quot;))       = false
     * &lt;/pre&gt;
     *
     * @param method a Method reference
     * @return true if the method is a getter, false otherwise.
     */
    public static boolean isGetterMethod(@Nonnull Method method) {
<span class="nc" id="L884">        return isGetterMethod(method, false);</span>
    }

    /**
     * Finds out if the given {@code Method} is a getter method.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate Method reference
     * isGetterMethod(getMethod(&quot;getFoo&quot;))       = true
     * isGetterMethod(getMethod(&quot;getfoo&quot;) )      = false
     * isGetterMethod(getMethod(&quot;mvcGroupInit&quot;)) = false
     * isGetterMethod(getMethod(&quot;isFoo&quot;))        = true
     * isGetterMethod(getMethod(&quot;island&quot;))       = false
     * &lt;/pre&gt;
     *
     * @param method a Method reference
     * @return true if the method is a getter, false otherwise.
     */
    public static boolean isGetterMethod(@Nonnull Method method, boolean removeAbstractModifier) {
<span class="nc" id="L903">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="nc" id="L904">        return isGetterMethod(MethodDescriptor.forMethod(method, removeAbstractModifier));</span>
    }

    /**
     * Finds out if the given {@code MetaMethod} is a getter method.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate MethodDescriptor reference
     * isGetterMethod(getMethod(&quot;getFoo&quot;))       = true
     * isGetterMethod(getMethod(&quot;getfoo&quot;) )      = false
     * isGetterMethod(getMethod(&quot;mvcGroupInit&quot;)) = false
     * isGetterMethod(getMethod(&quot;isFoo&quot;))        = true
     * isGetterMethod(getMethod(&quot;island&quot;))       = false
     * &lt;/pre&gt;
     *
     * @param method a MethodDescriptor reference
     * @return true if the method is a getter, false otherwise.
     */
    public static boolean isGetterMethod(@Nonnull MethodDescriptor method) {
<span class="fc" id="L923">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="pc bpc" id="L924" title="1 of 2 branches missed.">        return isInstanceMethod(method) &amp;&amp;</span>
<span class="pc bpc" id="L925" title="2 of 4 branches missed.">            (GETTER_PATTERN_1.matcher(method.getName()).matches() || GETTER_PATTERN_2.matcher(method.getName()).matches());</span>
    }

    /**
     * Finds out if the given {@code Method} is a setter method.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate Method reference
     * isGetterMethod(getMethod(&quot;setFoo&quot;))       = true
     * isGetterMethod(getMethod(&quot;setfoo&quot;))       = false
     * isGetterMethod(getMethod(&quot;mvcGroupInit&quot;)) = false
     * &lt;/pre&gt;
     *
     * @param method a Method reference
     * @return true if the method is a setter, false otherwise.
     */
    public static boolean isSetterMethod(@Nonnull Method method) {
<span class="nc" id="L942">        return isSetterMethod(method, false);</span>
    }

    /**
     * Finds out if the given {@code Method} is a setter method.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate Method reference
     * isGetterMethod(getMethod(&quot;setFoo&quot;))       = true
     * isGetterMethod(getMethod(&quot;setfoo&quot;))       = false
     * isGetterMethod(getMethod(&quot;mvcGroupInit&quot;)) = false
     * &lt;/pre&gt;
     *
     * @param method a Method reference
     * @return true if the method is a setter, false otherwise.
     */
    public static boolean isSetterMethod(@Nonnull Method method, boolean removeAbstractModifier) {
<span class="nc" id="L959">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="nc" id="L960">        return isSetterMethod(MethodDescriptor.forMethod(method, removeAbstractModifier));</span>
    }

    /**
     * Finds out if the given {@code MethodDescriptor} is a setter method.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate MethodDescriptor reference
     * isGetterMethod(getMethod(&quot;setFoo&quot;))       = true
     * isGetterMethod(getMethod(&quot;setfoo&quot;))       = false
     * isGetterMethod(getMethod(&quot;mvcGroupInit&quot;)) = false
     * &lt;/pre&gt;
     *
     * @param method a MethodDescriptor reference
     * @return true if the method is a setter, false otherwise.
     */
    public static boolean isSetterMethod(@Nonnull MethodDescriptor method) {
<span class="fc" id="L977">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="pc bpc" id="L978" title="1 of 4 branches missed.">        return isInstanceMethod(method) &amp;&amp; SETTER_PATTERN.matcher(method.getName()).matches();</span>
    }

    /**
     * Finds out if the given {@code Method} belongs to the set of
     * predefined Artifact methods by convention.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate Method reference
     * isArtifactMethod(getMethod(&quot;newInstance&quot;))    = true
     * isArtifactMethod(getMethod(&quot;griffonDestroy&quot;)) = false
     * isArtifactMethod(getMethod(&quot;foo&quot;))            = false
     * &lt;/pre&gt;
     *
     * @param method a Method reference
     * @return true if the method is an Artifact method, false otherwise.
     */
    public static boolean isArtifactMethod(@Nonnull Method method) {
<span class="nc" id="L996">        return isArtifactMethod(method, false);</span>
    }

    /**
     * Finds out if the given {@code Method} belongs to the set of
     * predefined Artifact methods by convention.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate Method reference
     * isArtifactMethod(getMethod(&quot;newInstance&quot;))    = true
     * isArtifactMethod(getMethod(&quot;griffonDestroy&quot;)) = false
     * isArtifactMethod(getMethod(&quot;foo&quot;))            = false
     * &lt;/pre&gt;
     *
     * @param method a Method reference
     * @return true if the method is an Artifact method, false otherwise.
     */
    public static boolean isArtifactMethod(@Nonnull Method method, boolean removeAbstractModifier) {
<span class="nc" id="L1014">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="nc" id="L1015">        return isArtifactMethod(MethodDescriptor.forMethod(method, removeAbstractModifier));</span>
    }

    /**
     * Finds out if the given {@code MethodDescriptor} belongs to the set of
     * predefined Artifact methods by convention.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate MethodDescriptor reference
     * isArtifactMethod(getMethod(&quot;newInstance&quot;))    = true
     * isArtifactMethod(getMethod(&quot;griffonDestroy&quot;)) = false
     * isArtifactMethod(getMethod(&quot;foo&quot;))            = false
     * &lt;/pre&gt;
     *
     * @param method a MethodDescriptor reference
     * @return true if the method is an Artifact method, false otherwise.
     */
    public static boolean isArtifactMethod(@Nonnull MethodDescriptor method) {
<span class="fc" id="L1033">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="pc bpc" id="L1034" title="1 of 2 branches missed.">        return isInstanceMethod(method) &amp;&amp;</span>
<span class="fc bfc" id="L1035" title="All 2 branches covered.">            ARTIFACT_METHODS.contains(method);</span>
    }

    /**
     * Finds out if the given {@code Method} belongs to the set of
     * predefined MVC methods by convention.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate Method reference
     * isMvcMethod(getMethod(&quot;mvcGroupInit&quot;))    = true
     * isMvcMethod(getMethod(&quot;mvcGroupDestroy&quot;)) = true
     * isMvcMethod(getMethod(&quot;foo&quot;))             = false
     * &lt;/pre&gt;
     *
     * @param method a Method reference
     * @return true if the method is an MVC method, false otherwise.
     */
    public static boolean isMvcMethod(@Nonnull Method method) {
<span class="nc" id="L1053">        return isMvcMethod(method, false);</span>
    }

    /**
     * Finds out if the given {@code Method} belongs to the set of
     * predefined MVC methods by convention.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate Method reference
     * isMvcMethod(getMethod(&quot;mvcGroupInit&quot;))    = true
     * isMvcMethod(getMethod(&quot;mvcGroupDestroy&quot;)) = true
     * isMvcMethod(getMethod(&quot;foo&quot;))             = false
     * &lt;/pre&gt;
     *
     * @param method a Method reference
     * @return true if the method is an MVC method, false otherwise.
     */
    public static boolean isMvcMethod(@Nonnull Method method, boolean removeAbstractModifier) {
<span class="nc" id="L1071">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="nc" id="L1072">        return isMvcMethod(MethodDescriptor.forMethod(method, removeAbstractModifier));</span>
    }

    /**
     * Finds out if the given {@code MethodDescriptor} belongs to the set of
     * predefined MVC methods by convention.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate MethodDescriptor reference
     * isMvcMethod(getMethod(&quot;mvcGroupInit&quot;))    = true
     * isMvcMethod(getMethod(&quot;mvcGroupDestroy&quot;)) = true
     * isMvcMethod(getMethod(&quot;foo&quot;))             = false
     * &lt;/pre&gt;
     *
     * @param method a MethodDescriptor reference
     * @return true if the method is an MVC method, false otherwise.
     */
    public static boolean isMvcMethod(@Nonnull MethodDescriptor method) {
<span class="fc" id="L1090">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="pc bpc" id="L1091" title="1 of 2 branches missed.">        return isInstanceMethod(method) &amp;&amp;</span>
<span class="fc bfc" id="L1092" title="All 2 branches covered.">            MVC_METHODS.contains(method);</span>
    }

    /**
     * Finds out if the given {@code Method} belongs to the set of
     * predefined threading methods by convention.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate Method reference
     * isThreadingMethod(getMethod(&quot;execOutsideUI&quot;))    = true
     * isThreadingMethod(getMethod(&quot;doLater&quot;))          = true
     * isThreadingMethod(getMethod(&quot;foo&quot;))              = false
     * &lt;/pre&gt;
     *
     * @param method a Method reference
     * @return true if the method is a threading method, false otherwise.
     */
    public static boolean isThreadingMethod(@Nonnull Method method) {
<span class="nc" id="L1110">        return isThreadingMethod(method, false);</span>
    }

    /**
     * Finds out if the given {@code Method} belongs to the set of
     * predefined threading methods by convention.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate Method reference
     * isThreadingMethod(getMethod(&quot;execOutsideUI&quot;))    = true
     * isThreadingMethod(getMethod(&quot;doLater&quot;))          = true
     * isThreadingMethod(getMethod(&quot;foo&quot;))              = false
     * &lt;/pre&gt;
     *
     * @param method a Method reference
     * @return true if the method is a threading method, false otherwise.
     */
    public static boolean isThreadingMethod(@Nonnull Method method, boolean removeAbstractModifier) {
<span class="nc" id="L1128">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="nc" id="L1129">        return isThreadingMethod(MethodDescriptor.forMethod(method, removeAbstractModifier));</span>
    }

    /**
     * Finds out if the given {@code MethodDescriptor} belongs to the set of
     * predefined threading methods by convention.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate MethodDescriptor reference
     * isThreadingMethod(getMethod(&quot;execOutsideUI&quot;))    = true
     * isThreadingMethod(getMethod(&quot;doLater&quot;))          = true
     * isThreadingMethod(getMethod(&quot;foo&quot;))              = false
     * &lt;/pre&gt;
     *
     * @param method a MethodDescriptor reference
     * @return true if the method is a threading method, false otherwise.
     */
    public static boolean isThreadingMethod(@Nonnull MethodDescriptor method) {
<span class="fc" id="L1147">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="pc bpc" id="L1148" title="1 of 2 branches missed.">        return isInstanceMethod(method) &amp;&amp;</span>
<span class="fc bfc" id="L1149" title="All 2 branches covered.">            THREADING_METHODS.contains(method);</span>
    }

    /**
     * Finds out if the given {@code Method} belongs to the set of
     * predefined event publisher methods by convention.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate Method reference
     * isEventPublisherMethod(getMethod(&quot;addEventPublisher&quot;))  = true
     * isEventPublisherMethod(getMethod(&quot;publishEvent&quot;))       = true
     * isEventPublisherMethod(getMethod(&quot;foo&quot;))                = false
     * &lt;/pre&gt;
     *
     * @param method a Method reference
     * @return true if the method is an @EventPublisher method, false otherwise.
     */
    public static boolean isEventPublisherMethod(@Nonnull Method method) {
<span class="nc" id="L1167">        return isEventPublisherMethod(method, false);</span>
    }

    /**
     * Finds out if the given {@code Method} belongs to the set of
     * predefined event publisher methods by convention.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate Method reference
     * isEventPublisherMethod(getMethod(&quot;addEventPublisher&quot;))  = true
     * isEventPublisherMethod(getMethod(&quot;publishEvent&quot;))       = true
     * isEventPublisherMethod(getMethod(&quot;foo&quot;))                = false
     * &lt;/pre&gt;
     *
     * @param method a Method reference
     * @return true if the method is an @EventPublisher method, false otherwise.
     */
    public static boolean isEventPublisherMethod(@Nonnull Method method, boolean removeAbstractModifier) {
<span class="nc" id="L1185">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="nc" id="L1186">        return isEventPublisherMethod(MethodDescriptor.forMethod(method, removeAbstractModifier));</span>
    }

    /**
     * Finds out if the given {@code MethodDescriptor} belongs to the set of
     * predefined event publisher methods by convention.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate MethodDescriptor reference
     * isEventPublisherMethod(getMethod(&quot;addEventPublisher&quot;))  = true
     * isEventPublisherMethod(getMethod(&quot;publishEvent&quot;))       = true
     * isEventPublisherMethod(getMethod(&quot;foo&quot;))                = false
     * &lt;/pre&gt;
     *
     * @param method a MethodDescriptor reference
     * @return true if the method is an @EventPublisher method, false otherwise.
     */
    public static boolean isEventPublisherMethod(@Nonnull MethodDescriptor method) {
<span class="fc" id="L1204">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="pc bpc" id="L1205" title="1 of 2 branches missed.">        return isInstanceMethod(method) &amp;&amp;</span>
<span class="pc bpc" id="L1206" title="1 of 2 branches missed.">            EVENT_PUBLISHER_METHODS.contains(method);</span>
    }

    /**
     * Finds out if the given {@code Method} belongs to the set of
     * predefined observable methods by convention.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate Method reference
     * isObservableMethod(getMethod(&quot;addPropertyChangeListener&quot;))  = true
     * isObservableMethod(getMethod(&quot;getPropertyChangeListeners&quot;)) = true
     * isObservableMethod(getMethod(&quot;foo&quot;))                        = false
     * &lt;/pre&gt;
     *
     * @param method a Method reference
     * @return true if the method is an Observable method, false otherwise.
     */
    public static boolean isObservableMethod(@Nonnull Method method) {
<span class="nc" id="L1224">        return isObservableMethod(method, false);</span>
    }

    /**
     * Finds out if the given {@code Method} belongs to the set of
     * predefined observable methods by convention.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate Method reference
     * isObservableMethod(getMethod(&quot;addPropertyChangeListener&quot;))  = true
     * isObservableMethod(getMethod(&quot;getPropertyChangeListeners&quot;)) = true
     * isObservableMethod(getMethod(&quot;foo&quot;))                        = false
     * &lt;/pre&gt;
     *
     * @param method a Method reference
     * @return true if the method is an Observable method, false otherwise.
     */
    public static boolean isObservableMethod(@Nonnull Method method, boolean removeAbstractModifier) {
<span class="nc" id="L1242">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="nc" id="L1243">        return isObservableMethod(MethodDescriptor.forMethod(method, removeAbstractModifier));</span>
    }

    /**
     * Finds out if the given {@code MethodDescriptor} belongs to the set of
     * predefined observable methods by convention.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate MethodDescriptor reference
     * isObservableMethod(getMethod(&quot;addPropertyChangeListener&quot;))  = true
     * isObservableMethod(getMethod(&quot;getPropertyChangeListeners&quot;)) = true
     * isObservableMethod(getMethod(&quot;foo&quot;))                        = false
     * &lt;/pre&gt;
     *
     * @param method a MethodDescriptor reference
     * @return true if the method is an Observable method, false otherwise.
     */
    public static boolean isObservableMethod(@Nonnull MethodDescriptor method) {
<span class="fc" id="L1261">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="pc bpc" id="L1262" title="1 of 2 branches missed.">        return isInstanceMethod(method) &amp;&amp;</span>
<span class="pc bpc" id="L1263" title="1 of 2 branches missed.">            OBSERVABLE_METHODS.contains(method);</span>
    }

    /**
     * Finds out if the given {@code Method} belongs to the set of
     * predefined resources methods by convention.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate Method reference
     * isResourceHandlerMethod(getMethod(&quot;getResourceAsURL&quot;))    = true
     * isResourceHandlerMethod(getMethod(&quot;getResourceAsStream&quot;)) = true
     * isResourceHandlerMethod(getMethod(&quot;foo&quot;))                 = false
     * &lt;/pre&gt;
     *
     * @param method a Method reference
     * @return true if the method is an ResourceHandler method, false otherwise.
     */
    public static boolean isResourceHandlerMethod(@Nonnull Method method) {
<span class="nc" id="L1281">        return isResourceHandlerMethod(method, false);</span>
    }

    /**
     * Finds out if the given {@code Method} belongs to the set of
     * predefined resources methods by convention.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate Method reference
     * isResourceHandlerMethod(getMethod(&quot;getResourceAsURL&quot;))    = true
     * isResourceHandlerMethod(getMethod(&quot;getResourceAsStream&quot;)) = true
     * isResourceHandlerMethod(getMethod(&quot;foo&quot;))                 = false
     * &lt;/pre&gt;
     *
     * @param method a Method reference
     * @return true if the method is an ResourceHandler method, false otherwise.
     */
    public static boolean isResourceHandlerMethod(@Nonnull Method method, boolean removeAbstractModifier) {
<span class="nc" id="L1299">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="nc" id="L1300">        return isResourceHandlerMethod(MethodDescriptor.forMethod(method, removeAbstractModifier));</span>
    }

    /**
     * Finds out if the given {@code MethodDescriptor} belongs to the set of
     * predefined resources methods by convention.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate MethodDescriptor reference
     * isResourceHandlerMethod(getMethod(&quot;getResourceAsURL&quot;))    = true
     * isResourceHandlerMethod(getMethod(&quot;getResourceAsStream&quot;)) = true
     * isResourceHandlerMethod(getMethod(&quot;foo&quot;))                 = false
     * &lt;/pre&gt;
     *
     * @param method a MethodDescriptor reference
     * @return true if the method is an ResourceHandler method, false otherwise.
     */
    public static boolean isResourceHandlerMethod(@Nonnull MethodDescriptor method) {
<span class="fc" id="L1318">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="pc bpc" id="L1319" title="1 of 2 branches missed.">        return isInstanceMethod(method) &amp;&amp;</span>
<span class="pc bpc" id="L1320" title="1 of 2 branches missed.">            RESOURCE_HANDLER_METHODS.contains(method);</span>
    }

    /**
     * Finds out if the given {@code Method} belongs to the set of
     * predefined message source methods by convention.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate Method reference
     * isMessageSourceMethod(getMethod(&quot;getMessage&quot;))    = true
     * isMessageSourceMethod(getMethod(&quot;foo&quot;))           = false
     * &lt;/pre&gt;
     *
     * @param method a Method reference
     * @return true if the method is an MessageSource method, false otherwise.
     */
    public static boolean isMessageSourceMethod(@Nonnull Method method) {
<span class="nc" id="L1337">        return isMessageSourceMethod(method, false);</span>
    }

    /**
     * Finds out if the given {@code Method} belongs to the set of
     * predefined message source methods by convention.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate Method reference
     * isMessageSourceMethod(getMethod(&quot;getMessage&quot;))    = true
     * isMessageSourceMethod(getMethod(&quot;foo&quot;))           = false
     * &lt;/pre&gt;
     *
     * @param method a Method reference
     * @return true if the method is an MessageSource method, false otherwise.
     */
    public static boolean isMessageSourceMethod(@Nonnull Method method, boolean removeAbstractModifier) {
<span class="nc" id="L1354">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="nc" id="L1355">        return isMessageSourceMethod(MethodDescriptor.forMethod(method, removeAbstractModifier));</span>
    }

    /**
     * Finds out if the given {@code MethodDescriptor} belongs to the set of
     * predefined message source methods by convention.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate MethodDescriptor reference
     * isMessageSourceMethod(getMethod(&quot;getMessage&quot;))    = true
     * isMessageSourceMethod(getMethod(&quot;foo&quot;))           = false
     * &lt;/pre&gt;
     *
     * @param method a MethodDescriptor reference
     * @return true if the method is an MessageSource method, false otherwise.
     */
    public static boolean isMessageSourceMethod(@Nonnull MethodDescriptor method) {
<span class="nc" id="L1372">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="nc bnc" id="L1373" title="All 2 branches missed.">        return isInstanceMethod(method) &amp;&amp;</span>
<span class="nc bnc" id="L1374" title="All 2 branches missed.">            MESSAGE_SOURCE_METHODS.contains(method);</span>
    }

    /**
     * Finds out if the given {@code Method} belongs to the set of
     * predefined resource resolver methods by convention.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate Method reference
     * isResourceResolverMethod(getMethod(&quot;resolveResource&quot;)) = true
     * isResourceResolverMethod(getMethod(&quot;foo&quot;))             = false
     * &lt;/pre&gt;
     *
     * @param method a Method reference
     * @return true if the method is an ResourceResolver method, false otherwise.
     */
    public static boolean isResourceResolverMethod(@Nonnull Method method) {
<span class="nc" id="L1391">        return isResourceResolverMethod(method, false);</span>
    }

    /**
     * Finds out if the given {@code Method} belongs to the set of
     * predefined resource resolver methods by convention.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate Method reference
     * isResourceResolverMethod(getMethod(&quot;resolveResource&quot;)) = true
     * isResourceResolverMethod(getMethod(&quot;foo&quot;))             = false
     * &lt;/pre&gt;
     *
     * @param method a Method reference
     * @return true if the method is an ResourceResolver method, false otherwise.
     */
    public static boolean isResourceResolverMethod(@Nonnull Method method, boolean removeAbstractModifier) {
<span class="nc" id="L1408">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="nc" id="L1409">        return isResourceResolverMethod(MethodDescriptor.forMethod(method, removeAbstractModifier));</span>
    }

    /**
     * Finds out if the given {@code MethodDescriptor} belongs to the set of
     * predefined resource resolver methods by convention.
     * &lt;p&gt;
     * &lt;pre&gt;
     * // assuming getMethod() returns an appropriate MethodDescriptor reference
     * isResourceResolverMethod(getMethod(&quot;resolveResource&quot;)) = true
     * isResourceResolverMethod(getMethod(&quot;foo&quot;))             = false
     * &lt;/pre&gt;
     *
     * @param method a MethodDescriptor reference
     * @return true if the method is an ResourceResolver method, false otherwise.
     */
    public static boolean isResourceResolverMethod(@Nonnull MethodDescriptor method) {
<span class="nc" id="L1426">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="nc bnc" id="L1427" title="All 2 branches missed.">        return isInstanceMethod(method) &amp;&amp;</span>
<span class="nc bnc" id="L1428" title="All 2 branches missed.">            RESOURCE_RESOLVER_METHODS.contains(method);</span>
    }

    /**
     * Finds out if the given {@code Method} is an instance method, i.e,
     * it is public and non-static.
     *
     * @param method a Method reference
     * @return true if the method is an instance method, false otherwise.
     */
    public static boolean isInstanceMethod(@Nonnull Method method) {
<span class="nc" id="L1439">        return isInstanceMethod(method, false);</span>
    }

    /**
     * Finds out if the given {@code Method} is an instance method, i.e,
     * it is public and non-static.
     *
     * @param method a Method reference
     * @return true if the method is an instance method, false otherwise.
     */
    public static boolean isInstanceMethod(@Nonnull Method method, boolean removeAbstractModifier) {
<span class="nc" id="L1450">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="nc" id="L1451">        return isInstanceMethod(MethodDescriptor.forMethod(method, removeAbstractModifier));</span>
    }

    /**
     * Finds out if the given {@code MethodDescriptor} is an instance method, i.e,
     * it is public and non-static.
     *
     * @param method a MethodDescriptor reference
     * @return true if the method is an instance method, false otherwise.
     */
    public static boolean isInstanceMethod(@Nonnull MethodDescriptor method) {
<span class="fc" id="L1462">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="fc" id="L1463">        int modifiers = method.getModifiers();</span>
<span class="pc bpc" id="L1464" title="1 of 2 branches missed.">        return Modifier.isPublic(modifiers) &amp;&amp;</span>
<span class="pc bpc" id="L1465" title="1 of 2 branches missed.">            !Modifier.isAbstract(modifiers) &amp;&amp;</span>
<span class="pc bpc" id="L1466" title="1 of 2 branches missed.">            !Modifier.isStatic(modifiers);</span>
    }

    /**
     * Finds out if the given {@code Method} matches the following criteria:&lt;ul&gt;
     * &lt;li&gt;isInstanceMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isBasicMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isGroovyInjectedMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isThreadingMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isArtifactMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isMvcMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isServiceMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isEventPublisherMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isObservableMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isResourceHandlerMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isGetterMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isSetterMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isContributionMethod(method)&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param method a Method reference
     * @return true if the method matches the given criteria, false otherwise.
     */
    public static boolean isPlainMethod(@Nonnull Method method) {
<span class="fc" id="L1490">        return isPlainMethod(method, false);</span>
    }

    /**
     * Finds out if the given {@code Method} matches the following criteria:&lt;ul&gt;
     * &lt;li&gt;isInstanceMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isBasicMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isGroovyInjectedMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isThreadingMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isArtifactMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isMvcMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isServiceMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isEventPublisherMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isObservableMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isResourceHandlerMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isGetterMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isSetterMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isContributionMethod(method)&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param method a Method reference
     * @return true if the method matches the given criteria, false otherwise.
     */
    public static boolean isPlainMethod(@Nonnull Method method, boolean removeAbstractModifier) {
<span class="fc" id="L1514">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="fc" id="L1515">        return isPlainMethod(MethodDescriptor.forMethod(method, removeAbstractModifier));</span>
    }

    /**
     * Finds out if the given {@code MethodDescriptor} matches the following criteria:&lt;ul&gt;
     * &lt;li&gt;isInstanceMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isBasicMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isGroovyInjectedMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isThreadingMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isArtifactMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isMvcMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isServiceMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isEventPublisherMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isObservableMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isResourceHandlerMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isGetterMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isSetterMethod(method)&lt;/li&gt;
     * &lt;li&gt;! isContributionMethod(method)&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param method a MethodDescriptor reference
     * @return true if the method matches the given criteria, false otherwise.
     */
    public static boolean isPlainMethod(@Nonnull MethodDescriptor method) {
<span class="fc" id="L1539">        requireNonNull(method, ERROR_METHOD_NULL);</span>
<span class="pc bpc" id="L1540" title="1 of 2 branches missed.">        return isInstanceMethod(method) &amp;&amp;</span>
<span class="fc bfc" id="L1541" title="All 2 branches covered.">            !isBasicMethod(method) &amp;&amp;</span>
<span class="pc bpc" id="L1542" title="1 of 2 branches missed.">            !isGroovyInjectedMethod(method) &amp;&amp;</span>
<span class="fc bfc" id="L1543" title="All 2 branches covered.">            !isThreadingMethod(method) &amp;&amp;</span>
<span class="fc bfc" id="L1544" title="All 2 branches covered.">            !isArtifactMethod(method) &amp;&amp;</span>
<span class="fc bfc" id="L1545" title="All 2 branches covered.">            !isMvcMethod(method) &amp;&amp;</span>
<span class="pc bpc" id="L1546" title="1 of 2 branches missed.">            !isEventPublisherMethod(method) &amp;&amp;</span>
<span class="pc bpc" id="L1547" title="1 of 2 branches missed.">            !isObservableMethod(method) &amp;&amp;</span>
<span class="pc bpc" id="L1548" title="1 of 2 branches missed.">            !isResourceHandlerMethod(method) &amp;&amp;</span>
<span class="pc bpc" id="L1549" title="1 of 2 branches missed.">            !isGetterMethod(method) &amp;&amp;</span>
<span class="fc bfc" id="L1550" title="All 2 branches covered.">            !isSetterMethod(method) &amp;&amp;</span>
<span class="pc bpc" id="L1551" title="1 of 2 branches missed.">            !isContributionMethod(method);</span>
    }

    /**
     * Returns true if the specified property in the specified class is of the specified type
     *
     * @param clazz        The class which contains the property
     * @param propertyName The property name
     * @param type         The type to check
     * @return A boolean value
     */
    public static boolean isPropertyOfType(Class&lt;?&gt; clazz, String propertyName, Class&lt;?&gt; type) {
        try {
<span class="nc" id="L1564">            Class&lt;?&gt; propType = getPropertyType(clazz, propertyName);</span>
<span class="nc bnc" id="L1565" title="All 4 branches missed.">            return propType != null &amp;&amp; propType.equals(type);</span>
<span class="nc" id="L1566">        } catch (Exception e) {</span>
<span class="nc" id="L1567">            return false;</span>
        }
    }

    /**
     * Instantiates a Class, wrapping any exceptions in a RuntimeException.
     *
     * @param clazz target Class for which an object will be instantiated
     * @return the newly instantiated object.
     * @throws BeanInstantiationException if an error occurs when creating the object
     */
    @Nonnull
    public static Object instantiateClass(@Nonnull Class&lt;?&gt; clazz) {
<span class="nc" id="L1580">        requireNonNull(clazz, ERROR_CLAZZ_NULL);</span>
        try {
<span class="nc" id="L1582">            return clazz.newInstance();</span>
<span class="nc" id="L1583">        } catch (Exception e) {</span>
<span class="nc" id="L1584">            throw new BeanInstantiationException(&quot;Could not create an instance of &quot; + clazz, e);</span>
        }
    }

    @Nonnull
    public static Object instantiate(@Nonnull Class&lt;?&gt; clazz, @Nullable Object[] args) {
<span class="nc" id="L1590">        requireNonNull(clazz, ERROR_CLAZZ_NULL);</span>
        try {
<span class="nc bnc" id="L1592" title="All 2 branches missed.">            if (args == null) {</span>
<span class="nc" id="L1593">                args = EMPTY_OBJECT_ARRAY;</span>
            }
<span class="nc" id="L1595">            int arguments = args.length;</span>
<span class="nc" id="L1596">            Class&lt;?&gt;[] parameterTypes = new Class&lt;?&gt;[arguments];</span>
<span class="nc bnc" id="L1597" title="All 2 branches missed.">            for (int i = 0; i &lt; arguments; i++) {</span>
<span class="nc" id="L1598">                parameterTypes[i] = args[i].getClass();</span>
            }
<span class="nc" id="L1600">            return clazz.getDeclaredConstructor(parameterTypes).newInstance(args);</span>
<span class="nc" id="L1601">        } catch (Exception e) {</span>
<span class="nc" id="L1602">            throw new BeanInstantiationException(&quot;Could not create an instance of &quot; + clazz, e);</span>
        }
    }

    /**
     * Returns the value of the specified property and type from an instance of the specified Griffon class
     *
     * @param clazz        The name of the class which contains the property
     * @param propertyName The property name
     * @param propertyType The property type
     * @return The value of the property or null if none exists
     */
    @Nullable
    public static Object getPropertyValueOfNewInstance(@Nullable Class&lt;?&gt; clazz, @Nullable String propertyName, Class&lt;?&gt; propertyType) {
        // validate
<span class="nc bnc" id="L1617" title="All 4 branches missed.">        if (clazz == null || GriffonNameUtils.isBlank(propertyName)) {</span>
<span class="nc" id="L1618">            return null;</span>
        }

        Object instance;
        try {
<span class="nc" id="L1623">            instance = instantiateClass(clazz);</span>
<span class="nc" id="L1624">        } catch (BeanInstantiationException e) {</span>
<span class="nc" id="L1625">            return null;</span>
<span class="nc" id="L1626">        }</span>

<span class="nc" id="L1628">        return getPropertyOrStaticPropertyOrFieldValue(instance, propertyName);</span>
    }

    /**
     * Returns the value of the specified property and type from an instance of the specified Griffon class
     *
     * @param clazz        The name of the class which contains the property
     * @param propertyName The property name
     * @return The value of the property or null if none exists
     */
    public static Object getPropertyValueOfNewInstance(Class&lt;?&gt; clazz, String propertyName) {
        // validate
<span class="nc bnc" id="L1640" title="All 4 branches missed.">        if (clazz == null || GriffonNameUtils.isBlank(propertyName)) {</span>
<span class="nc" id="L1641">            return null;</span>
        }

        Object instance;
        try {
<span class="nc" id="L1646">            instance = instantiateClass(clazz);</span>
<span class="nc" id="L1647">        } catch (BeanInstantiationException e) {</span>
<span class="nc" id="L1648">            return null;</span>
<span class="nc" id="L1649">        }</span>

<span class="nc" id="L1651">        return getPropertyOrStaticPropertyOrFieldValue(instance, propertyName);</span>
    }

    /**
     * Retrieves a PropertyDescriptor for the specified instance and property value
     *
     * @param instance      The instance
     * @param propertyValue The value of the property
     * @return The PropertyDescriptor
     */
    public static PropertyDescriptor getPropertyDescriptorForValue(Object instance, Object propertyValue) {
<span class="nc bnc" id="L1662" title="All 4 branches missed.">        if (instance == null || propertyValue == null)</span>
<span class="nc" id="L1663">            return null;</span>

<span class="nc" id="L1665">        PropertyDescriptor[] descriptors = getPropertyDescriptors(instance.getClass());</span>

<span class="nc bnc" id="L1667" title="All 2 branches missed.">        for (PropertyDescriptor pd : descriptors) {</span>
<span class="nc bnc" id="L1668" title="All 2 branches missed.">            if (isAssignableOrConvertibleFrom(pd.getPropertyType(), propertyValue.getClass())) {</span>
                Object value;
                try {
<span class="nc" id="L1671">                    value = getReadMethod(pd).invoke(instance, (Object[]) null);</span>
<span class="nc" id="L1672">                } catch (Exception e) {</span>
<span class="nc" id="L1673">                    throw new RuntimeException(&quot;Problem calling readMethod of &quot; + pd, e);</span>
<span class="nc" id="L1674">                }</span>
<span class="nc bnc" id="L1675" title="All 2 branches missed.">                if (propertyValue.equals(value))</span>
<span class="nc" id="L1676">                    return pd;</span>
            }
        }
<span class="nc" id="L1679">        return null;</span>
    }

    /**
     * Returns the type of the given property contained within the specified class
     *
     * @param clazz        The class which contains the property
     * @param propertyName The name of the property
     * @return The property type or null if none exists
     */
    @Nullable
    public static Class&lt;?&gt; getPropertyType(@Nullable Class&lt;?&gt; clazz, @Nullable String propertyName) {
<span class="nc bnc" id="L1691" title="All 4 branches missed.">        if (clazz == null || GriffonNameUtils.isBlank(propertyName)) {</span>
<span class="nc" id="L1692">            return null;</span>
        }

        try {
<span class="nc" id="L1696">            PropertyDescriptor desc = getPropertyDescriptor(clazz, propertyName);</span>
<span class="nc bnc" id="L1697" title="All 2 branches missed.">            if (desc != null) {</span>
<span class="nc" id="L1698">                return desc.getPropertyType();</span>
            } else {
<span class="nc" id="L1700">                return null;</span>
            }
<span class="nc" id="L1702">        } catch (Exception e) {</span>
            // if there are any errors in instantiating just return null for the moment
<span class="nc" id="L1704">            return null;</span>
        }
    }

    /**
     * Retrieves all the properties of the given class for the given type
     *
     * @param clazz        The class to retrieve the properties from
     * @param propertyType The type of the properties you wish to retrieve
     * @return An array of PropertyDescriptor instances
     */
    @Nonnull
    public static PropertyDescriptor[] getPropertiesOfType(@Nullable Class&lt;?&gt; clazz, @Nullable Class&lt;?&gt; propertyType) {
<span class="nc bnc" id="L1717" title="All 4 branches missed.">        if (clazz == null || propertyType == null) {</span>
<span class="nc" id="L1718">            return new PropertyDescriptor[0];</span>
        }

<span class="nc" id="L1721">        Set&lt;PropertyDescriptor&gt; properties = new HashSet&lt;&gt;();</span>
        try {
<span class="nc" id="L1723">            PropertyDescriptor[] descriptors = getPropertyDescriptors(clazz);</span>

<span class="nc bnc" id="L1725" title="All 2 branches missed.">            for (PropertyDescriptor descriptor : descriptors) {</span>
<span class="nc" id="L1726">                Class&lt;?&gt; currentPropertyType = descriptor.getPropertyType();</span>
<span class="nc bnc" id="L1727" title="All 2 branches missed.">                if (isTypeInstanceOfPropertyType(propertyType, currentPropertyType)) {</span>
<span class="nc" id="L1728">                    properties.add(descriptor);</span>
                }
            }
<span class="nc" id="L1731">        } catch (Exception e) {</span>
            // if there are any errors in instantiating just return null for the moment
<span class="nc" id="L1733">            return new PropertyDescriptor[0];</span>
<span class="nc" id="L1734">        }</span>
<span class="nc" id="L1735">        return properties.toArray(new PropertyDescriptor[properties.size()]);</span>
    }

    private static boolean isTypeInstanceOfPropertyType(Class&lt;?&gt; type, Class&lt;?&gt; propertyType) {
<span class="nc bnc" id="L1739" title="All 4 branches missed.">        return propertyType.isAssignableFrom(type) &amp;&amp; !propertyType.equals(Object.class);</span>
    }

    /**
     * Retrieves all the properties of the given class which are assignable to the given type
     *
     * @param clazz             The class to retrieve the properties from
     * @param propertySuperType The type of the properties you wish to retrieve
     * @return An array of PropertyDescriptor instances
     */
    public static PropertyDescriptor[] getPropertiesAssignableToType(Class&lt;?&gt; clazz, Class&lt;?&gt; propertySuperType) {
<span class="nc bnc" id="L1750" title="All 4 branches missed.">        if (clazz == null || propertySuperType == null)</span>
<span class="nc" id="L1751">            return new PropertyDescriptor[0];</span>

<span class="nc" id="L1753">        Set&lt;PropertyDescriptor&gt; properties = new HashSet&lt;&gt;();</span>
        try {
<span class="nc" id="L1755">            PropertyDescriptor[] descriptors = getPropertyDescriptors(clazz);</span>

<span class="nc bnc" id="L1757" title="All 2 branches missed.">            for (PropertyDescriptor descriptor : descriptors) {</span>
<span class="nc bnc" id="L1758" title="All 2 branches missed.">                if (propertySuperType.isAssignableFrom(descriptor.getPropertyType())) {</span>
<span class="nc" id="L1759">                    properties.add(descriptor);</span>
                }
            }
<span class="nc" id="L1762">        } catch (Exception e) {</span>
<span class="nc" id="L1763">            return new PropertyDescriptor[0];</span>
<span class="nc" id="L1764">        }</span>
<span class="nc" id="L1765">        return properties.toArray(new PropertyDescriptor[properties.size()]);</span>
    }

    /**
     * Retrieves a property of the given class of the specified name and type
     *
     * @param clazz        The class to retrieve the property from
     * @param propertyName The name of the property
     * @param propertyType The type of the property
     * @return A PropertyDescriptor instance or null if none exists
     */
    public static PropertyDescriptor getProperty(Class&lt;?&gt; clazz, String propertyName, Class&lt;?&gt; propertyType) {
<span class="nc bnc" id="L1777" title="All 6 branches missed.">        if (clazz == null || propertyName == null || propertyType == null)</span>
<span class="nc" id="L1778">            return null;</span>

        try {
<span class="nc" id="L1781">            PropertyDescriptor pd = getPropertyDescriptor(clazz, propertyName);</span>
<span class="nc bnc" id="L1782" title="All 2 branches missed.">            if (pd.getPropertyType().equals(propertyType)) {</span>
<span class="nc" id="L1783">                return pd;</span>
            } else {
<span class="nc" id="L1785">                return null;</span>
            }
<span class="nc" id="L1787">        } catch (Exception e) {</span>
            // if there are any errors in instantiating just return null for the moment
<span class="nc" id="L1789">            return null;</span>
        }
    }

    /**
     * Convenience method for converting a collection to an Object[]
     *
     * @param c The collection
     * @return An object array
     */
    public static Object[] collectionToObjectArray(Collection&lt;?&gt; c) {
<span class="nc bnc" id="L1800" title="All 2 branches missed.">        if (c == null) return EMPTY_OBJECT_ARRAY;</span>
<span class="nc" id="L1801">        return c.toArray(new Object[c.size()]);</span>
    }

    /**
     * Detect if left and right types are matching types. In particular,
     * test if one is a primitive type and the other is the corresponding
     * Java wrapper type. Primitive and wrapper classes may be passed to
     * either arguments.
     *
     * @param leftType
     * @param rightType
     * @return true if one of the classes is a native type and the other the object representation
     * of the same native type
     */
    public static boolean isMatchBetweenPrimitiveAndWrapperTypes(@Nonnull Class&lt;?&gt; leftType, @Nonnull Class&lt;?&gt; rightType) {
<span class="nc" id="L1816">        requireNonNull(leftType, &quot;Left type is null!&quot;);</span>
<span class="nc" id="L1817">        requireNonNull(rightType, &quot;Right type is null!&quot;);</span>
<span class="nc" id="L1818">        return isMatchBetweenPrimitiveAndWrapperTypes(leftType.getName(), rightType.getName());</span>
    }

    /**
     * Detect if left and right types are matching types. In particular,
     * test if one is a primitive type and the other is the corresponding
     * Java wrapper type. Primitive and wrapper classes may be passed to
     * either arguments.
     *
     * @param leftType
     * @param rightType
     * @return true if one of the classes is a native type and the other the object representation
     * of the same native type
     */
    public static boolean isMatchBetweenPrimitiveAndWrapperTypes(@Nonnull String leftType, @Nonnull String rightType) {
<span class="nc" id="L1833">        requireNonBlank(leftType, &quot;Left type is null!&quot;);</span>
<span class="nc" id="L1834">        requireNonBlank(rightType, &quot;Right type is null!&quot;);</span>
<span class="nc" id="L1835">        String r = PRIMITIVE_TYPE_COMPATIBLE_TYPES.get(leftType);</span>
<span class="nc bnc" id="L1836" title="All 4 branches missed.">        return r != null &amp;&amp; r.equals(rightType);</span>
    }

    @Nullable
    @SuppressWarnings(&quot;ConstantConditions&quot;)
    private static Method findDeclaredMethod(@Nonnull Class&lt;?&gt; clazz, @Nonnull String methodName, Class[] parameterTypes) {
<span class="nc" id="L1842">        requireNonNull(clazz, ERROR_CLAZZ_NULL);</span>
<span class="nc" id="L1843">        requireNonBlank(methodName, ERROR_METHOD_NAME_BLANK);</span>
<span class="nc bnc" id="L1844" title="All 2 branches missed.">        while (clazz != null) {</span>
            try {
<span class="nc" id="L1846">                Method method = clazz.getDeclaredMethod(methodName, parameterTypes);</span>
<span class="nc bnc" id="L1847" title="All 2 branches missed.">                if (method != null) return method;</span>
<span class="nc" id="L1848">            } catch (NoSuchMethodException | SecurityException e) {</span>
                // skip
<span class="nc" id="L1850">            }</span>
<span class="nc" id="L1851">            clazz = clazz.getSuperclass();</span>
        }

<span class="nc" id="L1854">        return null;</span>
    }

    /**
     * &lt;p&gt;Work out if the specified property is readable and static. Java introspection does not
     * recognize this concept of static properties but Groovy does. We also consider public static fields
     * as static properties with no getters/setters&lt;/p&gt;
     *
     * @param clazz        The class to check for static property
     * @param propertyName The property name
     * @return true if the property with name propertyName has a static getter method
     */
    public static boolean isStaticProperty(@Nonnull Class&lt;?&gt; clazz, @Nonnull String propertyName) {
<span class="nc" id="L1867">        requireNonNull(clazz, ERROR_CLAZZ_NULL);</span>
<span class="nc" id="L1868">        requireNonBlank(propertyName, ERROR_PROPERTY_NAME_BLANK);</span>
<span class="nc" id="L1869">        Method getter = findDeclaredMethod(clazz, getGetterName(propertyName), null);</span>
<span class="nc bnc" id="L1870" title="All 2 branches missed.">        if (getter != null) {</span>
<span class="nc" id="L1871">            return isPublicStatic(getter);</span>
        } else {
            try {
<span class="nc" id="L1874">                Field f = clazz.getDeclaredField(propertyName);</span>
<span class="nc bnc" id="L1875" title="All 2 branches missed.">                if (f != null) {</span>
<span class="nc" id="L1876">                    return isPublicStatic(f);</span>
                }
<span class="nc" id="L1878">            } catch (NoSuchFieldException ignore) {</span>
                //ignore
<span class="nc" id="L1880">            }</span>
        }

<span class="nc" id="L1883">        return false;</span>
    }

    /**
     * Determine whether the method is declared public static
     *
     * @param m the method to be tested
     * @return True if the method is declared public static
     */
    public static boolean isPublicStatic(@Nonnull Method m) {
<span class="nc" id="L1893">        requireNonNull(m, &quot;Argument 'method' must not be null&quot;);</span>
<span class="nc" id="L1894">        final int modifiers = m.getModifiers();</span>
<span class="nc bnc" id="L1895" title="All 4 branches missed.">        return Modifier.isPublic(modifiers) &amp;&amp; Modifier.isStatic(modifiers);</span>
    }

    /**
     * Determine whether the field is declared public static
     *
     * @param f the field to be tested
     * @return True if the field is declared public static
     */
    public static boolean isPublicStatic(@Nonnull Field f) {
<span class="nc" id="L1905">        requireNonNull(f, &quot;Argument 'field' must not be null&quot;);</span>
<span class="nc" id="L1906">        final int modifiers = f.getModifiers();</span>
<span class="nc bnc" id="L1907" title="All 4 branches missed.">        return Modifier.isPublic(modifiers) &amp;&amp; Modifier.isStatic(modifiers);</span>
    }

    /**
     * Calculate the name for a getter method to retrieve the specified property
     *
     * @param propertyName the name of the property
     * @return The name for the getter method for this property, if it were to exist, i.e. getConstraints
     */
    @Nonnull
    public static String getGetterName(@Nonnull String propertyName) {
<span class="nc" id="L1918">        requireNonBlank(propertyName, ERROR_PROPERTY_NAME_BLANK);</span>
<span class="nc" id="L1919">        return PROPERTY_GET_PREFIX + Character.toUpperCase(propertyName.charAt(0))</span>
<span class="nc" id="L1920">            + propertyName.substring(1);</span>
    }

    /**
     * &lt;p&gt;Get a static property value, which has a public static getter or is just a public static field.&lt;/p&gt;
     *
     * @param clazz The class to check for static property
     * @param name  The property name
     * @return The value if there is one, or null if unset OR there is no such property
     */
    @Nullable
    public static Object getStaticPropertyValue(@Nonnull Class&lt;?&gt; clazz, @Nonnull String name) {
<span class="nc" id="L1932">        requireNonNull(clazz, ERROR_CLAZZ_NULL);</span>
<span class="nc" id="L1933">        requireNonBlank(name, ERROR_NAME_BLANK);</span>
<span class="nc" id="L1934">        Method getter = findDeclaredMethod(clazz, getGetterName(name), null);</span>
        try {
<span class="nc bnc" id="L1936" title="All 2 branches missed.">            if (getter != null) {</span>
<span class="nc" id="L1937">                return getter.invoke(null, (Object[]) null);</span>
            } else {
<span class="nc" id="L1939">                Field f = clazz.getDeclaredField(name);</span>
<span class="nc bnc" id="L1940" title="All 2 branches missed.">                if (f != null) {</span>
<span class="nc" id="L1941">                    return f.get(null);</span>
                }
            }
<span class="nc" id="L1944">        } catch (Exception ignore) {</span>
            //ignore
<span class="nc" id="L1946">        }</span>
<span class="nc" id="L1947">        return null;</span>
    }

    /**
     * &lt;p&gt;Looks for a property of the reference instance with a given name.&lt;/p&gt;
     * &lt;p&gt;If found its value is returned. We follow the Java bean conventions with augmentation for groovy support
     * and static fields/properties. We will therefore match, in this order:
     * &lt;/p&gt;
     * &lt;ol&gt;
     * &lt;li&gt;Standard public bean property (with getter or just public field, using normal introspection)
     * &lt;li&gt;Public static property with getter method
     * &lt;li&gt;Public static field
     * &lt;/ol&gt;
     *
     * @return property value or null if no property found
     */
    @Nullable
    public static Object getPropertyOrStaticPropertyOrFieldValue(@Nonnull Object obj, @Nonnull String name) {
<span class="nc" id="L1965">        requireNonNull(obj, ERROR_OBJECT_NULL);</span>
<span class="nc" id="L1966">        requireNonBlank(name, ERROR_NAME_BLANK);</span>
<span class="nc bnc" id="L1967" title="All 2 branches missed.">        if (isReadable(obj, name)) {</span>
            try {
<span class="nc" id="L1969">                return getProperty(obj, name);</span>
<span class="nc" id="L1970">            } catch (Exception e) {</span>
<span class="nc" id="L1971">                throw new PropertyException(obj, name);</span>
            }
        } else {
            // Look for public fields
<span class="nc bnc" id="L1975" title="All 2 branches missed.">            if (isPublicField(obj, name)) {</span>
<span class="nc" id="L1976">                return getFieldValue(obj, name);</span>
            }

            // Look for statics
<span class="nc" id="L1980">            Class&lt;?&gt; clazz = obj.getClass();</span>
<span class="nc bnc" id="L1981" title="All 2 branches missed.">            if (isStaticProperty(clazz, name)) {</span>
<span class="nc" id="L1982">                return getStaticPropertyValue(clazz, name);</span>
            } else {
<span class="nc" id="L1984">                return null;</span>
            }
        }
    }

    /**
     * Get the value of a declared field on an object
     *
     * @param obj  the instance that owns the field
     * @param name the name of the file to lookup
     * @return The object value or null if there is no such field or access problems
     */
    @Nullable
    public static Object getFieldValue(@Nonnull Object obj, @Nonnull String name) {
<span class="nc" id="L1998">        requireNonNull(obj, ERROR_OBJECT_NULL);</span>
<span class="nc" id="L1999">        requireNonBlank(name, ERROR_NAME_BLANK);</span>

<span class="nc" id="L2001">        Class&lt;?&gt; clazz = obj.getClass();</span>
<span class="nc" id="L2002">        Class c = clazz;</span>
<span class="nc bnc" id="L2003" title="All 4 branches missed.">        while (c != null &amp;&amp; !c.equals(Object.class)) {</span>
<span class="nc" id="L2004">            Field field = null;</span>
<span class="nc" id="L2005">            boolean wasAccessible = false;</span>
            try {
<span class="nc" id="L2007">                field = c.getDeclaredField(name);</span>
<span class="nc" id="L2008">                wasAccessible = field.isAccessible();</span>
<span class="nc" id="L2009">                field.setAccessible(true);</span>
<span class="nc" id="L2010">                return field.get(obj);</span>
<span class="nc" id="L2011">            } catch (Exception e) {</span>
                // ignore
            } finally {
<span class="nc bnc" id="L2014" title="All 6 branches missed.">                if (field != null) {</span>
<span class="nc" id="L2015">                    field.setAccessible(wasAccessible);</span>
                }
            }
<span class="nc" id="L2018">            c = c.getSuperclass();</span>
<span class="nc" id="L2019">        }</span>

<span class="nc" id="L2021">        return null;</span>
    }

    /**
     * Get the a declared field on an object
     *
     * @param obj  the instance that owns the field
     * @param name the name of the file to lookup
     * @return The field or null if there is no such field or access problems
     */
    @Nullable
    public static Field getField(@Nonnull Object obj, @Nonnull String name) {
<span class="nc" id="L2033">        requireNonNull(obj, ERROR_OBJECT_NULL);</span>
<span class="nc" id="L2034">        requireNonBlank(name, ERROR_NAME_BLANK);</span>
<span class="nc" id="L2035">        return getField(obj.getClass(), name);</span>
    }

    /**
     * Get the a declared field on a class
     *
     * @param clazz the clazz that owns the field
     * @param name  the name of the file to lookup
     * @return The field or null if there is no such field or access problems
     */
    @Nullable
    public static Field getField(@Nonnull Class&lt;?&gt; clazz, @Nonnull String name) {
<span class="nc" id="L2047">        requireNonNull(clazz, ERROR_CLAZZ_NULL);</span>
<span class="nc" id="L2048">        requireNonBlank(name, ERROR_NAME_BLANK);</span>

<span class="nc" id="L2050">        Class c = clazz;</span>
<span class="nc bnc" id="L2051" title="All 4 branches missed.">        while (c != null &amp;&amp; !c.equals(Object.class)) {</span>
<span class="nc" id="L2052">            Field field = null;</span>
            try {
<span class="nc" id="L2054">                return c.getDeclaredField(name);</span>
<span class="nc" id="L2055">            } catch (Exception e) {</span>
                // ignore
            }
<span class="nc" id="L2058">            c = c.getSuperclass();</span>
<span class="nc" id="L2059">        }</span>
<span class="nc" id="L2060">        return null;</span>
    }

    /**
     * Returns an array of {@code Field} objects reflecting all the fields
     * declared by the class and its hierarchy, represented by this
     * {@code Class} object. This includes public, protected, default
     * (package) access, and private fields, but excludes inherited fields.
     * &lt;p&gt;
     * &lt;p&gt; The elements in the returned array are not sorted and are not in any
     * particular order.
     *
     * @param clazz the clazz that will be queried.
     * @return the array of {@code Field} objects representing all the
     * declared fields of this class and its hierarchy
     */
    public static Field[] getAllDeclaredFields(@Nonnull Class&lt;?&gt; clazz) {
<span class="fc" id="L2077">        requireNonNull(clazz, ERROR_CLAZZ_NULL);</span>

<span class="fc" id="L2079">        List&lt;Field&gt; fields = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L2081">        Class c = clazz;</span>
<span class="pc bpc" id="L2082" title="1 of 4 branches missed.">        while (c != null &amp;&amp; !c.equals(Object.class)) {</span>
<span class="fc" id="L2083">            Field[] declaredFields = c.getDeclaredFields();</span>
<span class="pc bpc" id="L2084" title="2 of 4 branches missed.">            if (declaredFields != null &amp;&amp; declaredFields.length &gt; 0) {</span>
<span class="fc" id="L2085">                fields.addAll(Arrays.asList(declaredFields));</span>
            }
<span class="fc" id="L2087">            c = c.getSuperclass();</span>
<span class="fc" id="L2088">        }</span>

<span class="fc" id="L2090">        return fields.toArray(new Field[fields.size()]);</span>
    }

    /**
     * Work out if the specified object has a public field with the name supplied.
     *
     * @param obj  the instance that owns the field
     * @param name the name of the file to lookup
     * @return True if a public field with the name exists
     */
    public static boolean isPublicField(@Nonnull Object obj, @Nonnull String name) {
<span class="nc" id="L2101">        requireNonNull(obj, ERROR_OBJECT_NULL);</span>
<span class="nc" id="L2102">        requireNonBlank(name, ERROR_NAME_BLANK);</span>
<span class="nc" id="L2103">        Class&lt;?&gt; clazz = obj.getClass();</span>
        Field f;
        try {
<span class="nc" id="L2106">            f = clazz.getDeclaredField(name);</span>
<span class="nc" id="L2107">            return Modifier.isPublic(f.getModifiers());</span>
<span class="nc" id="L2108">        } catch (NoSuchFieldException e) {</span>
<span class="nc" id="L2109">            return false;</span>
        }
    }

    /**
     * Checks whether the specified property is inherited from a super class
     *
     * @param clz          The class to check
     * @param propertyName The property name
     * @return True if the property is inherited
     */
    public static boolean isPropertyInherited(@Nullable Class&lt;?&gt; clz, @Nonnull String propertyName) {
<span class="nc bnc" id="L2121" title="All 2 branches missed.">        if (clz == null) return false;</span>
<span class="nc" id="L2122">        requireNonBlank(propertyName, ERROR_PROPERTY_NAME_BLANK);</span>
<span class="nc" id="L2123">        Class&lt;?&gt; superClass = clz.getSuperclass();</span>

        PropertyDescriptor pd;
        try {
<span class="nc" id="L2127">            pd = getPropertyDescriptor(superClass, propertyName);</span>
<span class="nc" id="L2128">        } catch (Exception e) {</span>
<span class="nc" id="L2129">            throw new PropertyException(superClass, propertyName, e);</span>
<span class="nc" id="L2130">        }</span>
<span class="nc bnc" id="L2131" title="All 4 branches missed.">        return pd != null &amp;&amp; pd.getReadMethod() != null;</span>
    }

    /**
     * Creates a concrete collection for the supplied interface
     *
     * @param interfaceType The interface
     * @return ArrayList for List, TreeSet for SortedSet, HashSet for Set etc.
     */
    @Nonnull
    public static Collection&lt;?&gt; createConcreteCollection(@Nonnull Class&lt;?&gt; interfaceType) {
<span class="nc" id="L2142">        requireNonNull(interfaceType, ERROR_TYPE_NULL);</span>
        Collection&lt;?&gt; elements;
<span class="nc bnc" id="L2144" title="All 2 branches missed.">        if (interfaceType.equals(List.class)) {</span>
<span class="nc" id="L2145">            elements = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L2146" title="All 2 branches missed.">        } else if (interfaceType.equals(SortedSet.class)) {</span>
<span class="nc" id="L2147">            elements = new TreeSet&lt;&gt;();</span>
        } else {
<span class="nc" id="L2149">            elements = new LinkedHashSet&lt;&gt;();</span>
        }
<span class="nc" id="L2151">        return elements;</span>
    }

    /**
     * Retrieves the name of a setter for the specified property name
     *
     * @param propertyName The property name
     * @return The setter equivalent
     */
    @Nonnull
    public static String getSetterName(@Nonnull String propertyName) {
<span class="nc" id="L2162">        requireNonBlank(propertyName, ERROR_PROPERTY_NAME_BLANK);</span>
<span class="nc" id="L2163">        return PROPERTY_SET_PREFIX + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);</span>
    }

    /**
     * Returns true if the name of the method specified and the number of arguments make it a javabean property
     *
     * @param name True if its a Javabean property
     * @param args The arguments
     * @return True if it is a javabean property method
     */
    @SuppressWarnings(&quot;ConstantConditions&quot;)
    public static boolean isGetter(@Nullable String name, @Nullable Class[] args) {
<span class="nc bnc" id="L2175" title="All 4 branches missed.">        if (GriffonNameUtils.isBlank(name) || args == null) return false;</span>
<span class="nc bnc" id="L2176" title="All 2 branches missed.">        if (args.length != 0) return false;</span>

<span class="nc bnc" id="L2178" title="All 2 branches missed.">        if (name.startsWith(PROPERTY_GET_PREFIX)) {</span>
<span class="nc" id="L2179">            name = name.substring(3);</span>
<span class="nc bnc" id="L2180" title="All 4 branches missed.">            if (name.length() &gt; 0 &amp;&amp; Character.isUpperCase(name.charAt(0)))</span>
<span class="nc" id="L2181">                return true;</span>
<span class="nc bnc" id="L2182" title="All 2 branches missed.">        } else if (name.startsWith(PROPERTY_IS_PREFIX)) {</span>
<span class="nc" id="L2183">            name = name.substring(2);</span>
<span class="nc bnc" id="L2184" title="All 4 branches missed.">            if (name.length() &gt; 0 &amp;&amp; Character.isUpperCase(name.charAt(0)))</span>
<span class="nc" id="L2185">                return true;</span>
        }
<span class="nc" id="L2187">        return false;</span>
    }

    /**
     * Returns a property name equivalent for the given getter name or null if it is not a getter
     *
     * @param getterName The getter name
     * @return The property name equivalent
     */
    @Nullable
    @SuppressWarnings(&quot;ConstantConditions&quot;)
    public static String getPropertyForGetter(@Nullable String getterName) {
<span class="nc bnc" id="L2199" title="All 2 branches missed.">        if (GriffonNameUtils.isBlank(getterName)) return null;</span>

<span class="nc bnc" id="L2201" title="All 2 branches missed.">        if (getterName.startsWith(PROPERTY_GET_PREFIX)) {</span>
<span class="nc" id="L2202">            String prop = getterName.substring(3);</span>
<span class="nc" id="L2203">            return convertPropertyName(prop);</span>
<span class="nc bnc" id="L2204" title="All 2 branches missed.">        } else if (getterName.startsWith(PROPERTY_IS_PREFIX)) {</span>
<span class="nc" id="L2205">            String prop = getterName.substring(2);</span>
<span class="nc" id="L2206">            return convertPropertyName(prop);</span>
        }
<span class="nc" id="L2208">        return null;</span>
    }

    @Nonnull
    private static String convertPropertyName(@Nonnull String prop) {
<span class="nc bnc" id="L2213" title="All 4 branches missed.">        if (Character.isUpperCase(prop.charAt(0)) &amp;&amp; Character.isUpperCase(prop.charAt(1))) {</span>
<span class="nc" id="L2214">            return prop;</span>
<span class="nc bnc" id="L2215" title="All 2 branches missed.">        } else if (Character.isDigit(prop.charAt(0))) {</span>
<span class="nc" id="L2216">            return prop;</span>
        } else {
<span class="nc" id="L2218">            return Character.toLowerCase(prop.charAt(0)) + prop.substring(1);</span>
        }
    }

    /**
     * Returns a property name equivalent for the given setter name or null if it is not a getter
     *
     * @param setterName The setter name
     * @return The property name equivalent
     */
    @Nullable
    @SuppressWarnings(&quot;ConstantConditions&quot;)
    public static String getPropertyForSetter(@Nullable String setterName) {
<span class="nc bnc" id="L2231" title="All 2 branches missed.">        if (GriffonNameUtils.isBlank(setterName)) return null;</span>

<span class="nc bnc" id="L2233" title="All 2 branches missed.">        if (setterName.startsWith(PROPERTY_SET_PREFIX)) {</span>
<span class="nc" id="L2234">            String prop = setterName.substring(3);</span>
<span class="nc" id="L2235">            return convertPropertyName(prop);</span>
        }
<span class="nc" id="L2237">        return null;</span>
    }

    @SuppressWarnings(&quot;ConstantConditions&quot;)
    public static boolean isSetter(@Nullable String name, @Nullable Class[] args) {
<span class="nc bnc" id="L2242" title="All 4 branches missed.">        if (GriffonNameUtils.isBlank(name) || args == null) return false;</span>

<span class="nc bnc" id="L2244" title="All 2 branches missed.">        if (name.startsWith(PROPERTY_SET_PREFIX)) {</span>
<span class="nc bnc" id="L2245" title="All 2 branches missed.">            if (args.length != 1) return false;</span>
<span class="nc" id="L2246">            name = name.substring(3);</span>
<span class="nc bnc" id="L2247" title="All 4 branches missed.">            if (name.length() &gt; 0 &amp;&amp; Character.isUpperCase(name.charAt(0)))</span>
<span class="nc" id="L2248">                return true;</span>
        }

<span class="nc" id="L2251">        return false;</span>
    }

    /**
     * Returns true if the specified clazz parameter is either the same as, or is a superclass or super interface
     * of, the specified type parameter. Converts primitive types to compatible class automatically.
     *
     * @param clazz
     * @param type
     * @return True if the class is a taglib
     * @see java.lang.Class#isAssignableFrom(Class)
     */
    public static boolean isAssignableOrConvertibleFrom(@Nullable Class&lt;?&gt; clazz, @Nullable Class&lt;?&gt; type) {
<span class="nc bnc" id="L2264" title="All 4 branches missed.">        if (type == null || clazz == null) {</span>
<span class="nc" id="L2265">            return false;</span>
<span class="nc bnc" id="L2266" title="All 2 branches missed.">        } else if (type.isPrimitive()) {</span>
            // convert primitive type to compatible class
<span class="nc" id="L2268">            Class&lt;?&gt; primitiveClass = PRIMITIVE_TYPE_COMPATIBLE_CLASSES.get(type);</span>
<span class="nc bnc" id="L2269" title="All 4 branches missed.">            return primitiveClass != null &amp;&amp; clazz.isAssignableFrom(primitiveClass);</span>
        } else {
<span class="nc" id="L2271">            return clazz.isAssignableFrom(type);</span>
        }
    }

    /**
     * Retrieves a boolean value from a Map for the given key
     *
     * @param key The key that references the boolean value
     * @param map The map to look in
     * @return A boolean value which will be false if the map is null, the map doesn't contain the key or the value is false
     */
    public static boolean getBooleanFromMap(@Nullable String key, @Nullable Map&lt;String, Object&gt; map) {
<span class="nc bnc" id="L2283" title="All 2 branches missed.">        if (map == null) return false;</span>
<span class="nc bnc" id="L2284" title="All 2 branches missed.">        if (map.containsKey(key)) {</span>
<span class="nc" id="L2285">            Object o = map.get(key);</span>
<span class="nc bnc" id="L2286" title="All 2 branches missed.">            if (o == null) return false;</span>
<span class="nc bnc" id="L2287" title="All 2 branches missed.">            else if (o instanceof Boolean) {</span>
<span class="nc" id="L2288">                return (Boolean) o;</span>
            } else {
<span class="nc" id="L2290">                return Boolean.valueOf(o.toString());</span>
            }
        }
<span class="nc" id="L2293">        return false;</span>
    }

    /**
     * Returns whether the specified class is either within one of the specified packages or
     * within a subpackage of one of the packages
     *
     * @param clazz       The class
     * @param packageList The list of packages
     * @return True if it is within the list of specified packages
     */
    public static boolean isClassBelowPackage(@Nonnull Class&lt;?&gt; clazz, @Nonnull List&lt;?&gt; packageList) {
<span class="nc" id="L2305">        requireNonNull(clazz, ERROR_CLAZZ_NULL);</span>
<span class="nc" id="L2306">        requireNonNull(packageList, &quot;Argument 'packageList' must not be null&quot;);</span>
<span class="nc" id="L2307">        String classPackage = clazz.getPackage().getName();</span>
<span class="nc bnc" id="L2308" title="All 2 branches missed.">        for (Object packageName : packageList) {</span>
<span class="nc bnc" id="L2309" title="All 2 branches missed.">            if (packageName != null) {</span>
<span class="nc bnc" id="L2310" title="All 2 branches missed.">                if (classPackage.startsWith(packageName.toString())) {</span>
<span class="nc" id="L2311">                    return true;</span>
                }
            }
<span class="nc" id="L2314">        }</span>
<span class="nc" id="L2315">        return false;</span>
    }

    /**
     * Sets or updates an object's properties.
     * &lt;p&gt;
     * This method will attempt setting a property using a matching
     * {@code PropertyDescriptor}; next it will try direct field
     * access if the property was not found.
     *
     * @param bean       the target object on which properties will be set
     * @param properties names and values for properties to be set
     * @throws PropertyException if a property could be found
     * @since 2.1.0
     */
    public static void setPropertiesOrFields(@Nonnull Object bean, @Nonnull Map&lt;String, Object&gt; properties) throws PropertyException {
<span class="nc" id="L2331">        requireNonNull(bean, ERROR_BEAN_NULL);</span>
<span class="nc" id="L2332">        requireNonNull(properties, ERROR_PROPERTIES_NULL);</span>
<span class="nc bnc" id="L2333" title="All 2 branches missed.">        for (Map.Entry&lt;String, Object&gt; entry : properties.entrySet()) {</span>
<span class="nc" id="L2334">            setPropertyOrFieldValue(bean, entry.getKey(), entry.getValue());</span>
<span class="nc" id="L2335">        }</span>
<span class="nc" id="L2336">    }</span>

    /**
     * Sets or updates an object's properties.
     * &lt;p&gt;
     * This method will attempt setting a property using a matching
     * {@code PropertyDescriptor}; next it will try direct field
     * access if the property was not found.
     *
     * @param bean       the target object on which properties will be set
     * @param properties names and values for properties to be set
     * @since 2.1.0
     */
    public static void setPropertiesOrFieldsNoException(@Nonnull Object bean, @Nonnull Map&lt;String, Object&gt; properties) {
<span class="fc" id="L2350">        requireNonNull(bean, ERROR_BEAN_NULL);</span>
<span class="fc" id="L2351">        requireNonNull(properties, ERROR_PROPERTIES_NULL);</span>
<span class="fc bfc" id="L2352" title="All 2 branches covered.">        for (Map.Entry&lt;String, Object&gt; entry : properties.entrySet()) {</span>
            try {
<span class="fc" id="L2354">                setPropertyOrFieldValue(bean, entry.getKey(), entry.getValue());</span>
<span class="fc" id="L2355">            } catch (PropertyException pe) {</span>
                // ignore
<span class="fc" id="L2357">            }</span>
<span class="fc" id="L2358">        }</span>
<span class="fc" id="L2359">    }</span>

    /**
     * Sets or updates an object's property.
     * &lt;p&gt;
     * This method will attempt setting a property using a matching
     * {@code PropertyDescriptor}; next it will try direct field
     * access if the property was not found.
     *
     * @param bean  the target object on which the property will be set
     * @param name  the name of the property to set
     * @param value the value to be set
     * @throws PropertyException if the property could not be found
     * @since 2.1.0
     */
    public static void setPropertyOrFieldValue(@Nonnull Object bean, @Nonnull String name, @Nullable Object value) throws PropertyException {
        try {
<span class="fc" id="L2376">            setPropertyValue(bean, name, value);</span>
<span class="fc" id="L2377">        } catch (PropertyException pe) {</span>
            try {
<span class="fc" id="L2379">                setFieldValue(bean, name, value);</span>
<span class="fc" id="L2380">            } catch (FieldException fe) {</span>
<span class="fc" id="L2381">                throw pe;</span>
<span class="fc" id="L2382">            }</span>
<span class="fc" id="L2383">        }</span>
<span class="fc" id="L2384">    }</span>

    /**
     * Sets or updates an object's property.
     * &lt;p&gt;
     * This method will attempt setting a property using a matching
     * {@code PropertyDescriptor}; next it will try direct field
     * access if the property was not found.
     *
     * @param bean  the target object on which the property will be set
     * @param name  the name of the property to set
     * @param value the value to be set
     * @throws PropertyException if the property could not be found
     * @since 2.4.0
     */
    public static void setPropertyOrFieldValueNoException(@Nonnull Object bean, @Nonnull String name, @Nullable Object value) {
        try {
<span class="nc" id="L2401">            setPropertyOrFieldValue(bean, name, value);</span>
<span class="fc" id="L2402">        } catch (PropertyException pe) {</span>
            // ignore
<span class="nc" id="L2404">        }</span>
<span class="fc" id="L2405">    }</span>

    /**
     * Sets or updates an object's properties.
     * &lt;p&gt;
     * This method will attempt setting a property using direct field
     * access; next it will try a {@code PropertyDescriptor} if a
     * matching field name was not found.
     *
     * @param bean       the target object on which properties will be set
     * @param properties names and values for properties to be set
     * @throws FieldException if the field could not be found
     * @since 2.1.0
     */
    public static void setFieldsOrProperties(@Nonnull Object bean, @Nonnull Map&lt;String, Object&gt; properties) throws FieldException {
<span class="nc" id="L2420">        requireNonNull(bean, ERROR_BEAN_NULL);</span>
<span class="nc" id="L2421">        requireNonNull(properties, ERROR_PROPERTIES_NULL);</span>
<span class="nc bnc" id="L2422" title="All 2 branches missed.">        for (Map.Entry&lt;String, Object&gt; entry : properties.entrySet()) {</span>
<span class="nc" id="L2423">            setFieldOrPropertyValue(bean, entry.getKey(), entry.getValue());</span>
<span class="nc" id="L2424">        }</span>
<span class="nc" id="L2425">    }</span>

    /**
     * Sets or updates an object's properties.
     * &lt;p&gt;
     * This method will attempt setting a property using direct field
     * access; next it will try a {@code PropertyDescriptor} if a
     * matching field name was not found.
     *
     * @param bean       the target object on which properties will be set
     * @param properties names and values for properties to be set
     * @since 2.1.0
     */
    public static void setFieldsOrPropertiesNoException(@Nonnull Object bean, @Nonnull Map&lt;String, Object&gt; properties) {
<span class="nc" id="L2439">        requireNonNull(bean, ERROR_BEAN_NULL);</span>
<span class="nc" id="L2440">        requireNonNull(properties, ERROR_PROPERTIES_NULL);</span>
<span class="nc bnc" id="L2441" title="All 2 branches missed.">        for (Map.Entry&lt;String, Object&gt; entry : properties.entrySet()) {</span>
            try {
<span class="nc" id="L2443">                setFieldOrPropertyValue(bean, entry.getKey(), entry.getValue());</span>
<span class="nc" id="L2444">            } catch (FieldException pe) {</span>
                // ignore
<span class="nc" id="L2446">            }</span>
<span class="nc" id="L2447">        }</span>
<span class="nc" id="L2448">    }</span>

    /**
     * Sets or updates an object's property.
     * &lt;p&gt;
     * This method will attempt setting a property using direct field
     * access; next it will try a {@code PropertyDescriptor} if a
     * matching field name was not found.
     *
     * @param bean  the target object on which the property will be set
     * @param name  the name of the property to set
     * @param value the value to be set
     * @throws FieldException if the property could not be found
     * @since 2.1.0
     */
    public static void setFieldOrPropertyValue(@Nonnull Object bean, @Nonnull String name, @Nullable Object value) throws FieldException {
        try {
<span class="nc" id="L2465">            setFieldValue(bean, name, value);</span>
<span class="nc" id="L2466">        } catch (FieldException fe) {</span>
            try {
<span class="nc" id="L2468">                setPropertyValue(bean, name, value);</span>
<span class="nc" id="L2469">            } catch (PropertyException pe) {</span>
<span class="nc" id="L2470">                throw fe;</span>
<span class="nc" id="L2471">            }</span>
<span class="nc" id="L2472">        }</span>
<span class="nc" id="L2473">    }</span>

    /**
     * Sets or updates field values on an object.
     *
     * @param bean   the target object on which field values will be set
     * @param fields names and values of fields to be set
     * @throws FieldException if a field could not be found
     * @since 2.1.0
     */
    public static void setFields(@Nonnull Object bean, @Nonnull Map&lt;String, Object&gt; fields) throws FieldException {
<span class="nc" id="L2484">        requireNonNull(bean, ERROR_BEAN_NULL);</span>
<span class="nc" id="L2485">        requireNonNull(fields, ERROR_FIELDS_NULL);</span>
<span class="nc bnc" id="L2486" title="All 2 branches missed.">        for (Map.Entry&lt;String, Object&gt; entry : fields.entrySet()) {</span>
<span class="nc" id="L2487">            setFieldValue(bean, entry.getKey(), entry.getValue());</span>
<span class="nc" id="L2488">        }</span>
<span class="nc" id="L2489">    }</span>

    /**
     * Sets or updates field values on an object.
     *
     * @param bean   the target object on which field values will be set
     * @param fields names and values of fields to be set
     * @since 2.1.0
     */
    public static void setFieldsNoException(@Nonnull Object bean, @Nonnull Map&lt;String, Object&gt; fields) {
<span class="nc" id="L2499">        requireNonNull(bean, ERROR_BEAN_NULL);</span>
<span class="nc" id="L2500">        requireNonNull(fields, ERROR_FIELDS_NULL);</span>
<span class="nc bnc" id="L2501" title="All 2 branches missed.">        for (Map.Entry&lt;String, Object&gt; entry : fields.entrySet()) {</span>
            try {
<span class="nc" id="L2503">                setFieldValue(bean, entry.getKey(), entry.getValue());</span>
<span class="nc" id="L2504">            } catch (FieldException e) {</span>
                // ignore
<span class="nc" id="L2506">            }</span>
<span class="nc" id="L2507">        }</span>
<span class="nc" id="L2508">    }</span>

    /**
     * Sets or updates an object's field.
     *
     * @param bean  the target object on which the field will be set
     * @param name  the name of the field to set
     * @param value the value to be set
     * @throws FieldException if the field could not be found
     * @since 2.1.0
     */
    public static void setFieldValue(@Nonnull Object bean, @Nonnull String name, @Nullable Object value) throws FieldException {
<span class="fc" id="L2520">        requireNonNull(bean, ERROR_BEAN_NULL);</span>
<span class="fc" id="L2521">        requireNonBlank(name, ERROR_NAME_BLANK);</span>
        try {
<span class="fc" id="L2523">            setField(bean, name, value);</span>
<span class="fc" id="L2524">        } catch (IllegalAccessException | NoSuchFieldException e) {</span>
<span class="fc" id="L2525">            throw new FieldException(bean, name, value, e);</span>
<span class="fc" id="L2526">        }</span>
<span class="fc" id="L2527">    }</span>

    /**
     * Sets or updates an object's field.
     *
     * @param bean  the target object on which the field will be set
     * @param name  the name of the field to set
     * @param value the value to be set
     * @throws FieldException if the field could not be found
     * @since 2.4.0
     */
    public static void setFieldValueNoException(@Nonnull Object bean, @Nonnull String name, @Nullable Object value) {
        try {
<span class="nc" id="L2540">            setFieldValue(bean, name, value);</span>
<span class="nc" id="L2541">        } catch (FieldException e) {</span>
            // ignore
<span class="nc" id="L2543">        }</span>
<span class="nc" id="L2544">    }</span>

    /**
     * Sets or updates properties on an object.
     *
     * @param bean       the target object on which properties will be set
     * @param properties names and values of properties to be set
     * @throws PropertyException if a property could not be found
     */
    public static void setProperties(@Nonnull Object bean, @Nonnull Map&lt;String, Object&gt; properties) throws PropertyException {
<span class="nc" id="L2554">        requireNonNull(bean, ERROR_BEAN_NULL);</span>
<span class="nc" id="L2555">        requireNonNull(properties, ERROR_PROPERTIES_NULL);</span>
<span class="nc bnc" id="L2556" title="All 2 branches missed.">        for (Map.Entry&lt;String, Object&gt; entry : properties.entrySet()) {</span>
<span class="nc" id="L2557">            setPropertyValue(bean, entry.getKey(), entry.getValue());</span>
<span class="nc" id="L2558">        }</span>
<span class="nc" id="L2559">    }</span>

    /**
     * Sets or updates properties on an object.
     *
     * @param bean       the target object on which properties will be set
     * @param properties names and values of properties to be set
     */
    public static void setPropertiesNoException(@Nonnull Object bean, @Nonnull Map&lt;String, Object&gt; properties) {
<span class="nc" id="L2568">        requireNonNull(bean, ERROR_BEAN_NULL);</span>
<span class="nc" id="L2569">        requireNonNull(properties, ERROR_PROPERTIES_NULL);</span>
<span class="nc bnc" id="L2570" title="All 2 branches missed.">        for (Map.Entry&lt;String, Object&gt; entry : properties.entrySet()) {</span>
            try {
<span class="nc" id="L2572">                setPropertyValue(bean, entry.getKey(), entry.getValue());</span>
<span class="nc" id="L2573">            } catch (PropertyException e) {</span>
                // ignore
<span class="nc" id="L2575">            }</span>
<span class="nc" id="L2576">        }</span>
<span class="nc" id="L2577">    }</span>

    /**
     * /**
     * Sets or updates a property on an object.
     *
     * @param bean  the target object on which the property will be set
     * @param name  the name of the property to set
     * @param value the value to be set
     * @throws PropertyException if the property could not be found
     */
    public static void setPropertyValue(@Nonnull Object bean, @Nonnull String name, @Nullable Object value) throws PropertyException {
<span class="fc" id="L2589">        requireNonNull(bean, ERROR_BEAN_NULL);</span>
<span class="fc" id="L2590">        requireNonBlank(name, ERROR_NAME_BLANK);</span>
        try {
<span class="fc" id="L2592">            setProperty(bean, name, value);</span>
<span class="fc" id="L2593">        } catch (IllegalAccessException | NoSuchMethodException e) {</span>
<span class="fc" id="L2594">            throw new PropertyException(bean, name, value, e);</span>
<span class="nc" id="L2595">        } catch (InvocationTargetException e) {</span>
<span class="nc" id="L2596">            throw new PropertyException(bean, name, value, e.getTargetException());</span>
<span class="fc" id="L2597">        }</span>
<span class="fc" id="L2598">    }</span>

    /**
     * Returns the value of a property.
     *
     * @param bean the owner of the property
     * @param name the name of the property to retrieve
     * @return the value read from the matching property
     * @throws PropertyException if the property could not be found
     */
    @Nullable
    public static Object getPropertyValue(@Nonnull Object bean, @Nonnull String name) throws PropertyException {
<span class="fc" id="L2610">        requireNonNull(bean, ERROR_BEAN_NULL);</span>
<span class="fc" id="L2611">        requireNonBlank(name, ERROR_NAME_BLANK);</span>
        try {
<span class="fc" id="L2613">            return getProperty(bean, name);</span>
<span class="nc" id="L2614">        } catch (IllegalAccessException | NoSuchMethodException e) {</span>
<span class="nc" id="L2615">            throw new PropertyException(bean, name, e);</span>
<span class="nc" id="L2616">        } catch (InvocationTargetException e) {</span>
<span class="nc" id="L2617">            throw new PropertyException(bean, name, e.getTargetException());</span>
        }
    }

    // -- The following methods and properties were copied from commons-beanutils

<span class="fc" id="L2623">    private static final Map&lt;String, PropertyDescriptor[]&gt; descriptorsCache = new LinkedHashMap&lt;&gt;();</span>

    /**
     * &lt;p&gt;Retrieve the property descriptor for the specified property of the
     * specified bean, or return &lt;code&gt;null&lt;/code&gt; if there is no such
     * descriptor.&lt;/p&gt;
     * This method does not resolve index, nested nor mapped properties.&lt;p&gt;
     *
     * @param bean Bean for which a property descriptor is requested
     * @param name name of the property for which a property descriptor
     *             is requested
     * @return the property descriptor or null if the bean does not have
     * a property that matches the specified name.
     * @throws IllegalAccessException    if the caller does not have
     *                                   access to the property accessor method
     * @throws IllegalArgumentException  if &lt;code&gt;bean&lt;/code&gt; or
     *                                   &lt;code&gt;name&lt;/code&gt; is null
     * @throws InvocationTargetException if the property accessor method
     *                                   throws an exception
     * @throws NoSuchMethodException     if an accessor method for this
     *                                   property cannot be found
     */
    @Nullable
    public static PropertyDescriptor getPropertyDescriptor(@Nonnull Object bean,
                                                           @Nonnull String name)
        throws IllegalAccessException, InvocationTargetException,
        NoSuchMethodException {
<span class="fc" id="L2650">        requireNonNull(bean, ERROR_BEAN_NULL);</span>
<span class="fc" id="L2651">        requireNonBlank(name, ERROR_NAME_BLANK);</span>

<span class="pc bpc" id="L2653" title="1 of 2 branches missed.">        return getPropertyDescriptor(bean instanceof Class ? (Class&lt;?&gt;) bean : bean.getClass(), name);</span>
    }

    /**
     * &lt;p&gt;Retrieve the property descriptor for the specified property of the
     * specified class, or return &lt;code&gt;null&lt;/code&gt; if there is no such
     * descriptor.&lt;/p&gt;
     * This method does not resolve index, nested nor mapped properties.&lt;p&gt;
     *
     * @param clazz class for which a property descriptor is requested
     * @param name  name of the property for which a property descriptor
     *              is requested
     * @return the property descriptor or null if the bean does not have
     * a property that matches the specified name.
     * @throws IllegalAccessException    if the caller does not have
     *                                   access to the property accessor method
     * @throws IllegalArgumentException  if &lt;code&gt;bean&lt;/code&gt; or
     *                                   &lt;code&gt;name&lt;/code&gt; is null
     * @throws InvocationTargetException if the property accessor method
     *                                   throws an exception
     * @throws NoSuchMethodException     if an accessor method for this
     *                                   property cannot be found
     */
    @Nullable
    public static PropertyDescriptor getPropertyDescriptor(@Nonnull Class&lt;?&gt; clazz,
                                                           @Nonnull String name)
        throws IllegalAccessException, InvocationTargetException,
        NoSuchMethodException {
<span class="fc" id="L2681">        requireNonNull(clazz, ERROR_CLAZZ_NULL);</span>
<span class="fc" id="L2682">        requireNonBlank(name, ERROR_NAME_BLANK);</span>

<span class="fc" id="L2684">        PropertyDescriptor[] descriptors = getPropertyDescriptors(clazz);</span>
<span class="fc bfc" id="L2685" title="All 2 branches covered.">        for (PropertyDescriptor descriptor : descriptors) {</span>
<span class="fc bfc" id="L2686" title="All 2 branches covered.">            if (name.equals(descriptor.getName())) {</span>
<span class="fc" id="L2687">                return (descriptor);</span>
            }
        }

<span class="fc" id="L2691">        return null;</span>
    }

    /**
     * &lt;p&gt;Retrieve the property descriptors for the specified class,
     * introspecting and caching them the first time a particular bean class
     * is encountered.&lt;/p&gt;
     *
     * @param beanClass Bean class for which property descriptors are requested
     * @return the property descriptors
     * @throws IllegalArgumentException if &lt;code&gt;beanClass&lt;/code&gt; is null
     */
    @Nonnull
    public static PropertyDescriptor[] getPropertyDescriptors(@Nonnull Class&lt;?&gt; beanClass) {
<span class="fc" id="L2705">        requireNonNull(beanClass, ERROR_CLAZZ_NULL);</span>

        // Look up any cached descriptors for this bean class
        PropertyDescriptor[] descriptors;
<span class="fc" id="L2709">        descriptors = descriptorsCache.get(beanClass.getName());</span>
<span class="fc bfc" id="L2710" title="All 2 branches covered.">        if (descriptors != null) {</span>
<span class="fc" id="L2711">            return descriptors;</span>
        }

        // Introspect the bean and cache the generated descriptors
        BeanInfo beanInfo;
        try {
<span class="fc" id="L2717">            beanInfo = Introspector.getBeanInfo(beanClass);</span>
<span class="nc" id="L2718">        } catch (IntrospectionException e) {</span>
<span class="nc" id="L2719">            return (new PropertyDescriptor[0]);</span>
<span class="fc" id="L2720">        }</span>
<span class="fc" id="L2721">        descriptors = beanInfo.getPropertyDescriptors();</span>
<span class="pc bpc" id="L2722" title="1 of 2 branches missed.">        if (descriptors == null) {</span>
<span class="nc" id="L2723">            descriptors = new PropertyDescriptor[0];</span>
        }

<span class="fc" id="L2726">        descriptorsCache.put(beanClass.getName(), descriptors);</span>
<span class="fc" id="L2727">        return descriptors;</span>
    }

    /**
     * &lt;p&gt;Return an accessible property getter method for this property,
     * if there is one; otherwise return &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * @param descriptor Property descriptor to return a getter for
     * @return The read method
     */
    @Nullable
    public static Method getReadMethod(@Nonnull PropertyDescriptor descriptor) {
<span class="nc" id="L2739">        requireNonNull(descriptor, ERROR_DESCRIPTOR_NULL);</span>
<span class="nc" id="L2740">        return (MethodUtils.getAccessibleMethod(descriptor.getReadMethod()));</span>
    }

    /**
     * &lt;p&gt;Return &lt;code&gt;true&lt;/code&gt; if the specified property name identifies
     * a readable property on the specified bean; otherwise, return
     * &lt;code&gt;false&lt;/code&gt;.
     *
     * @param bean Bean to be examined
     * @param name Property name to be evaluated
     * @return &lt;code&gt;true&lt;/code&gt; if the property is readable,
     * otherwise &lt;code&gt;false&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt;
     *                                  or &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @since BeanUtils 1.6
     */
    public static boolean isReadable(@Nonnull Object bean, @Nonnull String name) {
        // Validate method parameters
<span class="nc" id="L2758">        requireNonNull(bean, ERROR_BEAN_NULL);</span>
<span class="nc" id="L2759">        requireNonBlank(name, ERROR_NAME_BLANK);</span>

        try {
<span class="nc" id="L2762">            PropertyDescriptor desc = getPropertyDescriptor(bean, name);</span>
<span class="nc bnc" id="L2763" title="All 2 branches missed.">            if (desc != null) {</span>
<span class="nc" id="L2764">                Method readMethod = getReadMethod(bean.getClass(), desc);</span>
<span class="nc bnc" id="L2765" title="All 2 branches missed.">                if (readMethod != null) {</span>
<span class="nc" id="L2766">                    readMethod = MethodUtils.getAccessibleMethod(bean.getClass(), readMethod);</span>
                }
<span class="nc bnc" id="L2768" title="All 2 branches missed.">                return (readMethod != null);</span>
            } else {
<span class="nc" id="L2770">                return false;</span>
            }
<span class="nc" id="L2772">        } catch (IllegalAccessException e) {</span>
<span class="nc" id="L2773">            return false;</span>
<span class="nc" id="L2774">        } catch (InvocationTargetException e) {</span>
<span class="nc" id="L2775">            return false;</span>
<span class="nc" id="L2776">        } catch (NoSuchMethodException e) {</span>
<span class="nc" id="L2777">            return false;</span>
        }
    }

    /**
     * &lt;p&gt;Return an accessible property setter method for this property,
     * if there is one; otherwise return &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * @param descriptor Property descriptor to return a setter for
     * @return The write method
     */
    @Nullable
    public static Method getWriteMethod(@Nonnull PropertyDescriptor descriptor) {
<span class="nc" id="L2790">        requireNonNull(descriptor, ERROR_DESCRIPTOR_NULL);</span>
<span class="nc" id="L2791">        return (MethodUtils.getAccessibleMethod(descriptor.getWriteMethod()));</span>
    }

    /**
     * &lt;p&gt;Return &lt;code&gt;true&lt;/code&gt; if the specified property name identifies
     * a writable property on the specified bean; otherwise, return
     * &lt;code&gt;false&lt;/code&gt;.
     *
     * @param bean Bean to be examined
     * @param name Property name to be evaluated
     * @return &lt;code&gt;true&lt;/code&gt; if the property is writable,
     * otherwise &lt;code&gt;false&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt;
     *                                  or &lt;code&gt;name&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     */
    public static boolean isWritable(@Nonnull Object bean, @Nonnull String name) {
        // Validate method parameters
<span class="nc" id="L2808">        requireNonNull(bean, ERROR_BEAN_NULL);</span>
<span class="nc" id="L2809">        requireNonBlank(name, ERROR_NAME_BLANK);</span>

        try {
<span class="nc" id="L2812">            PropertyDescriptor desc = getPropertyDescriptor(bean, name);</span>
<span class="nc bnc" id="L2813" title="All 2 branches missed.">            if (desc != null) {</span>
<span class="nc" id="L2814">                Method writeMethod = getWriteMethod(bean.getClass(), desc);</span>
<span class="nc bnc" id="L2815" title="All 2 branches missed.">                if (writeMethod != null) {</span>
<span class="nc" id="L2816">                    writeMethod = MethodUtils.getAccessibleMethod(bean.getClass(), writeMethod);</span>
                }
<span class="nc bnc" id="L2818" title="All 2 branches missed.">                return (writeMethod != null);</span>
            } else {
<span class="nc" id="L2820">                return false;</span>
            }
<span class="nc" id="L2822">        } catch (IllegalAccessException e) {</span>
<span class="nc" id="L2823">            return false;</span>
<span class="nc" id="L2824">        } catch (InvocationTargetException e) {</span>
<span class="nc" id="L2825">            return false;</span>
<span class="nc" id="L2826">        } catch (NoSuchMethodException e) {</span>
<span class="nc" id="L2827">            return false;</span>
        }
    }

    /**
     * Sets the value of the specified field of the specified bean.
     *
     * @param bean  Bean whose field is to be mutated
     * @param name  Name of the field to be mutated
     * @param value The value to be set on the property
     * @throws IllegalAccessException   if the caller does not have
     *                                  access to the field
     * @throws IllegalArgumentException if &lt;code&gt;bean&lt;/code&gt; or
     *                                  &lt;code&gt;name&lt;/code&gt; is null
     * @throws NoSuchFieldException     if the named field cannot be found
     * @throws FieldException           if the field cannot be set
     * @since 2.1.0
     */
    public static void setField(@Nonnull Object bean, @Nonnull String name, @Nullable Object value)
        throws NoSuchFieldException, IllegalAccessException, FieldException {
<span class="fc" id="L2847">        requireNonNull(bean, ERROR_BEAN_NULL);</span>
<span class="fc" id="L2848">        requireNonBlank(name, ERROR_NAME_BLANK);</span>

<span class="fc" id="L2850">        Class&lt;?&gt; declaringClass = bean.getClass();</span>
<span class="fc bfc" id="L2851" title="All 2 branches covered.">        while (declaringClass != null) {</span>
            try {
<span class="fc" id="L2853">                Field field = declaringClass.getDeclaredField(name);</span>

                // type conversion needed?
<span class="fc" id="L2856">                Class&lt;?&gt; propertyType = field.getType();</span>
<span class="pc bpc" id="L2857" title="2 of 4 branches missed.">                if (value != null &amp;&amp; !propertyType.isAssignableFrom(value.getClass())) {</span>
<span class="nc" id="L2858">                    value = TypeUtils.convertValue(propertyType, value);</span>
                }

<span class="fc" id="L2861">                field.setAccessible(true);</span>
                try {
<span class="fc" id="L2863">                    field.set(bean, value);</span>
<span class="fc" id="L2864">                    return;</span>
<span class="nc" id="L2865">                } catch (IllegalArgumentException iae) {</span>
<span class="nc" id="L2866">                    throw new FieldException(bean, name, value, iae);</span>
                }
<span class="fc" id="L2868">            } catch (NoSuchFieldException nsfe) {</span>
<span class="fc" id="L2869">                declaringClass = declaringClass.getSuperclass();</span>
<span class="fc" id="L2870">            }</span>
        }
<span class="fc" id="L2872">        throw new NoSuchFieldException(name);</span>
    }

    /**
     * Sets the value of the specified property of the specified bean.
     *
     * @param bean  Bean whose property is to be mutated
     * @param name  Name of the property to be mutated
     * @param value The value to be set on the property
     * @throws IllegalAccessException    if the caller does not have
     *                                   access to the property accessor method
     * @throws IllegalArgumentException  if &lt;code&gt;bean&lt;/code&gt; or
     *                                   &lt;code&gt;name&lt;/code&gt; is null
     * @throws InvocationTargetException if the property accessor method
     *                                   throws an exception
     * @throws NoSuchMethodException     if an accessor method for this
     *                                   property cannot be found
     * @throws PropertyException         if the property cannot be set
     */
    public static void setProperty(@Nonnull Object bean, @Nonnull String name, @Nullable Object value)
        throws IllegalAccessException, InvocationTargetException,
        NoSuchMethodException, PropertyException {
<span class="fc" id="L2894">        requireNonNull(bean, ERROR_BEAN_NULL);</span>
<span class="fc" id="L2895">        requireNonBlank(name, ERROR_NAME_BLANK);</span>

        // Retrieve the property setter method for the specified property
<span class="fc" id="L2898">        PropertyDescriptor descriptor = getPropertyDescriptor(bean, name);</span>
<span class="fc bfc" id="L2899" title="All 2 branches covered.">        if (descriptor == null) {</span>
<span class="fc" id="L2900">            throw new NoSuchMethodException(&quot;Unknown property '&quot; +</span>
<span class="fc" id="L2901">                name + &quot;' on class '&quot; + bean.getClass() + &quot;'&quot;);</span>
        }
<span class="fc" id="L2903">        Method writeMethod = getWriteMethod(bean.getClass(), descriptor);</span>
<span class="fc bfc" id="L2904" title="All 2 branches covered.">        if (writeMethod == null) {</span>
<span class="fc" id="L2905">            throw new NoSuchMethodException(&quot;Property '&quot; + name +</span>
<span class="fc" id="L2906">                &quot;' has no setter method in class '&quot; + bean.getClass() + &quot;'&quot;);</span>
        }

        // type conversion needed?
<span class="fc" id="L2910">        Class&lt;?&gt; propertyType = descriptor.getPropertyType();</span>
<span class="pc bpc" id="L2911" title="2 of 4 branches missed.">        if (value != null &amp;&amp; !propertyType.isAssignableFrom(value.getClass())) {</span>
<span class="nc" id="L2912">            value = TypeUtils.convertValue(propertyType, value);</span>
        }

        // Call the property setter
        try {
<span class="fc" id="L2917">            writeMethod.invoke(bean, value);</span>
<span class="nc" id="L2918">        } catch (IllegalArgumentException iae) {</span>
<span class="nc" id="L2919">            throw new PropertyException(bean, name, value, iae);</span>
<span class="fc" id="L2920">        }</span>
<span class="fc" id="L2921">    }</span>

    /**
     * Return the value of the specified property of the specified bean,
     * no matter which property reference format is used, with no
     * type conversions.
     *
     * @param bean Bean whose property is to be extracted
     * @param name Possibly indexed and/or nested name of the property
     *             to be extracted
     * @return the property value
     * @throws IllegalAccessException    if the caller does not have
     *                                   access to the property accessor method
     * @throws IllegalArgumentException  if &lt;code&gt;bean&lt;/code&gt; or
     *                                   &lt;code&gt;name&lt;/code&gt; is null
     * @throws InvocationTargetException if the property accessor method
     *                                   throws an exception
     * @throws NoSuchMethodException     if an accessor method for this
     *                                   property cannot be found
     */
    @Nullable
    public static Object getProperty(@Nonnull Object bean, @Nonnull String name)
        throws IllegalAccessException, InvocationTargetException,
        NoSuchMethodException {
<span class="fc" id="L2945">        requireNonNull(bean, ERROR_BEAN_NULL);</span>
<span class="fc" id="L2946">        requireNonBlank(name, ERROR_NAME_BLANK);</span>

        // Retrieve the property getter method for the specified property
<span class="fc" id="L2949">        PropertyDescriptor descriptor = getPropertyDescriptor(bean, name);</span>
<span class="pc bpc" id="L2950" title="1 of 2 branches missed.">        if (descriptor == null) {</span>
<span class="nc" id="L2951">            throw new NoSuchMethodException(&quot;Unknown property '&quot; +</span>
<span class="nc" id="L2952">                name + &quot;' on class '&quot; + bean.getClass() + &quot;'&quot;);</span>
        }
<span class="fc" id="L2954">        Method readMethod = getReadMethod(bean.getClass(), descriptor);</span>
<span class="pc bpc" id="L2955" title="1 of 2 branches missed.">        if (readMethod == null) {</span>
<span class="nc" id="L2956">            throw new NoSuchMethodException(&quot;Property '&quot; + name +</span>
<span class="nc" id="L2957">                &quot;' has no getter method in class '&quot; + bean.getClass() + &quot;'&quot;);</span>
        }

        // Call the property getter and return the value
<span class="fc" id="L2961">        return readMethod.invoke(bean, EMPTY_OBJECT_ARRAY);</span>
    }

    /**
     * &lt;p&gt;Return an accessible property getter method for this property,
     * if there is one; otherwise return &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * @param clazz      The class of the read method will be invoked on
     * @param descriptor Property descriptor to return a getter for
     * @return The read method
     */
    @Nullable
    public static Method getReadMethod(@Nonnull Class&lt;?&gt; clazz, @Nonnull PropertyDescriptor descriptor) {
<span class="fc" id="L2974">        requireNonNull(clazz, ERROR_CLAZZ_NULL);</span>
<span class="fc" id="L2975">        requireNonNull(descriptor, ERROR_DESCRIPTOR_NULL);</span>
<span class="fc" id="L2976">        return (MethodUtils.getAccessibleMethod(clazz, descriptor.getReadMethod()));</span>
    }

    /**
     * &lt;p&gt;Return an accessible property setter method for this property,
     * if there is one; otherwise return &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * @param clazz      The class of the write method will be invoked on
     * @param descriptor Property descriptor to return a setter for
     * @return The write method
     */
    @Nullable
    public static Method getWriteMethod(@Nonnull Class&lt;?&gt; clazz, @Nonnull PropertyDescriptor descriptor) {
<span class="fc" id="L2989">        requireNonNull(clazz, ERROR_CLAZZ_NULL);</span>
<span class="fc" id="L2990">        requireNonNull(descriptor, ERROR_DESCRIPTOR_NULL);</span>
<span class="fc" id="L2991">        return (MethodUtils.getAccessibleMethod(clazz, descriptor.getWriteMethod()));</span>
    }

    // -- The following methods and properties were copied from commons-lang

    /**
     * &lt;p&gt;Validate that the argument condition is &lt;code&gt;true&lt;/code&gt;; otherwise
     * throwing an exception with the specified message. This method is useful when
     * validating according to an arbitrary boolean expression, such as validating a
     * primitive number or using your own custom validation expression.&lt;/p&gt;
     * &lt;p&gt;
     * &lt;pre&gt;
     * isTrue( (i &gt; 0), &quot;The value must be greater than zero&quot;);
     * isTrue( myObject.isOk(), &quot;The object is not OK&quot;);
     * &lt;/pre&gt;
     *
     * @param expression the boolean expression to check
     * @param message    the exception message if invalid
     * @throws IllegalArgumentException if expression is &lt;code&gt;false&lt;/code&gt;
     */
    public static void isTrue(boolean expression, String message) {
<span class="nc bnc" id="L3012" title="All 2 branches missed.">        if (expression) {</span>
<span class="nc" id="L3013">            throw new IllegalArgumentException(message);</span>
        }
<span class="nc" id="L3015">    }</span>

    @Nullable
    public static Object invokeInstanceMethod(@Nonnull Object object, @Nonnull String methodName) {
<span class="nc" id="L3019">        return invokeInstanceMethod(object, methodName, EMPTY_ARGS);</span>
    }

    @Nullable
    public static Object invokeInstanceMethod(@Nonnull Object object, @Nonnull String methodName, Object arg) {
<span class="nc" id="L3024">        return invokeInstanceMethod(object, methodName, new Object[]{arg});</span>
    }

    @Nullable
    public static Object invokeInstanceMethod(@Nonnull Object object, @Nonnull String methodName, Object... args) {
<span class="fc" id="L3029">        requireNonNull(object, ERROR_OBJECT_NULL);</span>
<span class="fc" id="L3030">        requireNonBlank(methodName, ERROR_METHOD_NAME_BLANK);</span>
        try {
<span class="nc" id="L3032">            return invokeMethod(object, methodName, args);</span>
<span class="fc" id="L3033">        } catch (NoSuchMethodException | IllegalAccessException e) {</span>
<span class="fc" id="L3034">            throw new InstanceMethodInvocationException(object, methodName, args, e);</span>
<span class="nc" id="L3035">        } catch (InvocationTargetException e) {</span>
<span class="nc" id="L3036">            throw new InstanceMethodInvocationException(object, methodName, args, e.getTargetException());</span>
        }
    }

    @Nullable
    public static Object invokeExactInstanceMethod(@Nonnull Object object, @Nonnull String methodName) {
<span class="nc" id="L3042">        return invokeExactInstanceMethod(object, methodName, EMPTY_ARGS);</span>
    }

    @Nullable
    public static Object invokeExactInstanceMethod(@Nonnull Object object, @Nonnull String methodName, Object arg) {
<span class="nc" id="L3047">        return invokeExactInstanceMethod(object, methodName, new Object[]{arg});</span>
    }

    @Nullable
    public static Object invokeExactInstanceMethod(@Nonnull Object object, @Nonnull String methodName, Object... args) {
<span class="fc" id="L3052">        requireNonNull(object, ERROR_OBJECT_NULL);</span>
<span class="fc" id="L3053">        requireNonBlank(methodName, ERROR_METHOD_NAME_BLANK);</span>
        try {
<span class="fc" id="L3055">            return invokeExactMethod(object, methodName, args);</span>
<span class="nc" id="L3056">        } catch (NoSuchMethodException | IllegalAccessException e) {</span>
<span class="nc" id="L3057">            throw new InstanceMethodInvocationException(object, methodName, args, e);</span>
<span class="nc" id="L3058">        } catch (InvocationTargetException e) {</span>
<span class="nc" id="L3059">            throw new InstanceMethodInvocationException(object, methodName, args, e.getTargetException());</span>
        }
    }

    @Nullable
    public static Object invokeStaticMethod(@Nonnull Class&lt;?&gt; type, @Nonnull String methodName) {
<span class="nc" id="L3065">        return invokeStaticMethod(type, methodName, EMPTY_ARGS);</span>
    }

    @Nullable
    public static Object invokeStaticMethod(@Nonnull Class&lt;?&gt; type, @Nonnull String methodName, Object arg) {
<span class="nc" id="L3070">        return invokeStaticMethod(type, methodName, new Object[]{arg});</span>
    }

    @Nullable
    public static Object invokeStaticMethod(@Nonnull Class&lt;?&gt; type, @Nonnull String methodName, Object... args) {
<span class="nc" id="L3075">        requireNonNull(type, ERROR_TYPE_NULL);</span>
<span class="nc" id="L3076">        requireNonBlank(methodName, ERROR_METHOD_NAME_BLANK);</span>
        try {
<span class="nc" id="L3078">            return MethodUtils.invokeStaticMethod(type, methodName, args);</span>
<span class="nc" id="L3079">        } catch (NoSuchMethodException | IllegalAccessException e) {</span>
<span class="nc" id="L3080">            throw new StaticMethodInvocationException(type, methodName, args, e);</span>
<span class="nc" id="L3081">        } catch (InvocationTargetException e) {</span>
<span class="nc" id="L3082">            throw new StaticMethodInvocationException(type, methodName, args, e.getTargetException());</span>
        }
    }

    @Nullable
    public static Object invokeExactStaticMethod(@Nonnull Class&lt;?&gt; type, @Nonnull String methodName) {
<span class="nc" id="L3088">        return invokeExactStaticMethod(type, methodName, EMPTY_ARGS);</span>
    }

    @Nullable
    public static Object invokeExactStaticMethod(@Nonnull Class&lt;?&gt; type, @Nonnull String methodName, Object arg) {
<span class="nc" id="L3093">        return invokeExactStaticMethod(type, methodName, new Object[]{arg});</span>
    }

    @Nullable
    public static Object invokeExactStaticMethod(@Nonnull Class&lt;?&gt; type, @Nonnull String methodName, Object... args) {
<span class="nc" id="L3098">        requireNonNull(type, ERROR_TYPE_NULL);</span>
<span class="nc" id="L3099">        requireNonBlank(methodName, ERROR_METHOD_NAME_BLANK);</span>
        try {
<span class="nc" id="L3101">            return MethodUtils.invokeExactStaticMethod(type, methodName, args);</span>
<span class="nc" id="L3102">        } catch (NoSuchMethodException | IllegalAccessException e) {</span>
<span class="nc" id="L3103">            throw new StaticMethodInvocationException(type, methodName, args, e);</span>
<span class="nc" id="L3104">        } catch (InvocationTargetException e) {</span>
<span class="nc" id="L3105">            throw new StaticMethodInvocationException(type, methodName, args, e.getTargetException());</span>
        }
    }

    public static boolean hasMethodAnnotatedwith(@Nonnull final Object instance, @Nonnull final Class&lt;? extends Annotation&gt; annotation) {
<span class="fc" id="L3110">        Class&lt;?&gt; klass = instance.getClass();</span>
<span class="fc bfc" id="L3111" title="All 2 branches covered.">        while (klass != null) {</span>
<span class="fc" id="L3112">            boolean found = false;</span>
<span class="fc bfc" id="L3113" title="All 2 branches covered.">            for (Method method : klass.getDeclaredMethods()) {</span>
<span class="pc bpc" id="L3114" title="1 of 2 branches missed.">                if (method.isAnnotationPresent(annotation) &amp;&amp;</span>
<span class="nc bnc" id="L3115" title="All 2 branches missed.">                    method.getParameterTypes().length == 0) {</span>
<span class="nc" id="L3116">                    return true;</span>
                }
            }

<span class="fc" id="L3120">            klass = klass.getSuperclass();</span>
<span class="fc" id="L3121">        }</span>

<span class="fc" id="L3123">        return false;</span>
    }

    public static void invokeAnnotatedMethod(@Nonnull final Object instance, @Nonnull final Class&lt;? extends Annotation&gt; annotation) {
<span class="fc" id="L3127">        List&lt;Method&gt; methods = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L3128">        Class&lt;?&gt; klass = instance.getClass();</span>
<span class="fc bfc" id="L3129" title="All 2 branches covered.">        while (klass != null) {</span>
<span class="fc" id="L3130">            boolean found = false;</span>
<span class="fc bfc" id="L3131" title="All 2 branches covered.">            for (Method method : klass.getDeclaredMethods()) {</span>
<span class="fc bfc" id="L3132" title="All 2 branches covered.">                if (method.isAnnotationPresent(annotation) &amp;&amp;</span>
<span class="pc bpc" id="L3133" title="1 of 2 branches missed.">                    method.getParameterTypes().length == 0) {</span>
<span class="pc bpc" id="L3134" title="1 of 2 branches missed.">                    if (found) {</span>
<span class="nc" id="L3135">                        throw new InstanceMethodInvocationException(instance, method, buildCause(instance.getClass(), method, methods, annotation));</span>
                    }
<span class="fc" id="L3137">                    methods.add(method);</span>
<span class="fc" id="L3138">                    found = true;</span>
                }
            }

<span class="fc" id="L3142">            klass = klass.getSuperclass();</span>
<span class="fc" id="L3143">        }</span>

<span class="fc bfc" id="L3145" title="All 2 branches covered.">        for (final Method method : methods) {</span>
<span class="fc" id="L3146">            AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {</span>
                @Override
                public Object run() {
<span class="fc" id="L3149">                    boolean wasAccessible = method.isAccessible();</span>
                    try {
<span class="fc" id="L3151">                        method.setAccessible(true);</span>
<span class="fc" id="L3152">                        return method.invoke(instance);</span>
<span class="nc" id="L3153">                    } catch (IllegalAccessException | IllegalArgumentException e) {</span>
<span class="nc" id="L3154">                        throw new InstanceMethodInvocationException(instance, method.getName(), null, e);</span>
<span class="nc" id="L3155">                    } catch (InvocationTargetException e) {</span>
<span class="nc" id="L3156">                        throw new InstanceMethodInvocationException(instance, method.getName(), null, e.getTargetException());</span>
                    } finally {
<span class="pc" id="L3158">                        method.setAccessible(wasAccessible);</span>
                    }
                }
            });
<span class="fc" id="L3162">        }</span>
<span class="fc" id="L3163">    }</span>

    @Nonnull
    private static Throwable buildCause(@Nonnull Class&lt;?&gt; clazz, @Nonnull Method method, @Nonnull List&lt;Method&gt; methods, @Nonnull final Class&lt;? extends Annotation&gt; annotation) {
<span class="nc" id="L3167">        StringBuilder b = new StringBuilder(&quot;The following methods were found annotated with @&quot; + annotation.getSimpleName() + &quot; on &quot;)</span>
<span class="nc" id="L3168">            .append(clazz);</span>
<span class="nc bnc" id="L3169" title="All 2 branches missed.">        for (Method m : methods) {</span>
<span class="nc" id="L3170">            b.append(&quot;\n  &quot;).append(m.toGenericString());</span>
<span class="nc" id="L3171">        }</span>
<span class="nc" id="L3172">        b.append(&quot;\n  &quot;).append(method.toGenericString());</span>
<span class="nc" id="L3173">        return new IllegalStateException(b.toString());</span>
    }

    private static final String EMPTY_STRING = &quot;&quot;;

    /**
     * &lt;p&gt;The package separator character: &lt;code&gt;'&amp;#x2e;' == {@value}&lt;/code&gt;.&lt;/p&gt;
     */
    public static final char PACKAGE_SEPARATOR_CHAR = '.';

    /**
     * &lt;p&gt;The package separator String: &lt;code&gt;&quot;&amp;#x2e;&quot;&lt;/code&gt;.&lt;/p&gt;
     */
<span class="fc" id="L3186">    public static final String PACKAGE_SEPARATOR = String.valueOf(PACKAGE_SEPARATOR_CHAR);</span>

    /**
     * &lt;p&gt;The inner class separator character: &lt;code&gt;'$' == {@value}&lt;/code&gt;.&lt;/p&gt;
     */
    public static final char INNER_CLASS_SEPARATOR_CHAR = '$';

    /**
     * &lt;p&gt;The inner class separator String: &lt;code&gt;&quot;$&quot;&lt;/code&gt;.&lt;/p&gt;
     */
<span class="fc" id="L3196">    public static final String INNER_CLASS_SEPARATOR = String.valueOf(INNER_CLASS_SEPARATOR_CHAR);</span>

    /**
     * Maps a primitive class name to its corresponding abbreviation used in array class names.
     */
<span class="fc" id="L3201">    private static final Map&lt;String, String&gt; abbreviationMap = new HashMap&lt;&gt;();</span>

    /**
     * Maps an abbreviation used in array class names to corresponding primitive class name.
     */
<span class="fc" id="L3206">    private static final Map&lt;String, String&gt; reverseAbbreviationMap = new HashMap&lt;&gt;();</span>

    /**
     * Add primitive type abbreviation to maps of abbreviations.
     *
     * @param primitive    Canonical name of primitive type
     * @param abbreviation Corresponding abbreviation of primitive type
     */
    private static void addAbbreviation(String primitive, String abbreviation) {
<span class="fc" id="L3215">        abbreviationMap.put(primitive, abbreviation);</span>
<span class="fc" id="L3216">        reverseAbbreviationMap.put(abbreviation, primitive);</span>
<span class="fc" id="L3217">    }</span>

    /**
     * Feed abbreviation maps
     */
    static {
<span class="fc" id="L3223">        addAbbreviation(&quot;int&quot;, &quot;I&quot;);</span>
<span class="fc" id="L3224">        addAbbreviation(&quot;boolean&quot;, &quot;Z&quot;);</span>
<span class="fc" id="L3225">        addAbbreviation(&quot;float&quot;, &quot;F&quot;);</span>
<span class="fc" id="L3226">        addAbbreviation(&quot;long&quot;, &quot;J&quot;);</span>
<span class="fc" id="L3227">        addAbbreviation(&quot;short&quot;, &quot;S&quot;);</span>
<span class="fc" id="L3228">        addAbbreviation(&quot;byte&quot;, &quot;B&quot;);</span>
<span class="fc" id="L3229">        addAbbreviation(&quot;double&quot;, &quot;D&quot;);</span>
<span class="fc" id="L3230">        addAbbreviation(&quot;char&quot;, &quot;C&quot;);</span>
<span class="fc" id="L3231">    }</span>

    // ----------------------------------------------------------------------

    /**
     * &lt;p&gt;Gets the class name minus the package name for an &lt;code&gt;Object&lt;/code&gt;.&lt;/p&gt;
     *
     * @param object      the class to get the short name for, may be null
     * @param valueIfNull the value to return if null
     * @return the class name of the object without the package name, or the null value
     */
    @Nonnull
    public static String getShortClassName(@Nullable Object object, @Nonnull String valueIfNull) {
<span class="nc bnc" id="L3244" title="All 2 branches missed.">        if (object == null) {</span>
<span class="nc" id="L3245">            return valueIfNull;</span>
        }
<span class="nc" id="L3247">        return getShortClassName(object.getClass());</span>
    }

    /**
     * &lt;p&gt;Gets the class name minus the package name from a &lt;code&gt;Class&lt;/code&gt;.&lt;/p&gt;
     *
     * @param cls the class to get the short name for.
     * @return the class name without the package name or an empty string
     */
    @Nonnull
    public static String getShortClassName(@Nullable Class&lt;?&gt; cls) {
<span class="pc bpc" id="L3258" title="1 of 2 branches missed.">        if (cls == null) {</span>
<span class="nc" id="L3259">            return EMPTY_STRING;</span>
        }
<span class="fc" id="L3261">        return getShortClassName(cls.getName());</span>
    }

    /**
     * &lt;p&gt;Gets the class name minus the package name from a String.&lt;/p&gt;
     * &lt;p/&gt;
     * &lt;p&gt;The string passed in is assumed to be a class name - it is not checked.&lt;/p&gt;
     *
     * @param className the className to get the short name for
     * @return the class name of the class without the package name or an empty string
     */
    @Nonnull
    public static String getShortClassName(@Nullable String className) {
<span class="pc bpc" id="L3274" title="1 of 2 branches missed.">        if (className == null) {</span>
<span class="nc" id="L3275">            return EMPTY_STRING;</span>
        }
<span class="pc bpc" id="L3277" title="1 of 2 branches missed.">        if (className.length() == 0) {</span>
<span class="nc" id="L3278">            return EMPTY_STRING;</span>
        }

<span class="fc" id="L3281">        StringBuilder arrayPrefix = new StringBuilder();</span>

        // Handle array encoding
<span class="pc bpc" id="L3284" title="1 of 2 branches missed.">        if (className.startsWith(&quot;[&quot;)) {</span>
<span class="nc bnc" id="L3285" title="All 2 branches missed.">            while (className.charAt(0) == '[') {</span>
<span class="nc" id="L3286">                className = className.substring(1);</span>
<span class="nc" id="L3287">                arrayPrefix.append(&quot;[]&quot;);</span>
            }
            // Strip Object type encoding
<span class="nc bnc" id="L3290" title="All 4 branches missed.">            if (className.charAt(0) == 'L' &amp;&amp; className.charAt(className.length() - 1) == ';') {</span>
<span class="nc" id="L3291">                className = className.substring(1, className.length() - 1);</span>
            }
        }

<span class="pc bpc" id="L3295" title="1 of 2 branches missed.">        if (reverseAbbreviationMap.containsKey(className)) {</span>
<span class="nc" id="L3296">            className = reverseAbbreviationMap.get(className);</span>
        }

<span class="fc" id="L3299">        int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);</span>
<span class="pc bpc" id="L3300" title="1 of 2 branches missed.">        int innerIdx = className.indexOf(</span>
            INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);
<span class="fc" id="L3302">        String out = className.substring(lastDotIdx + 1);</span>
<span class="pc bpc" id="L3303" title="1 of 2 branches missed.">        if (innerIdx != -1) {</span>
<span class="nc" id="L3304">            out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);</span>
        }
<span class="fc" id="L3306">        return out + arrayPrefix;</span>
    }

    // Package name
    // ----------------------------------------------------------------------

    /**
     * &lt;p&gt;Gets the package name of an &lt;code&gt;Object&lt;/code&gt;.&lt;/p&gt;
     *
     * @param object      the class to get the package name for, may be null
     * @param valueIfNull the value to return if null
     * @return the package name of the object, or the null value
     */
    @Nonnull
    public static String getPackageName(@Nullable Object object, @Nonnull String valueIfNull) {
<span class="nc bnc" id="L3321" title="All 2 branches missed.">        if (object == null) {</span>
<span class="nc" id="L3322">            return valueIfNull;</span>
        }
<span class="nc" id="L3324">        return getPackageName(object.getClass());</span>
    }

    /**
     * &lt;p&gt;Gets the package name of a &lt;code&gt;Class&lt;/code&gt;.&lt;/p&gt;
     *
     * @param cls the class to get the package name for, may be &lt;code&gt;null&lt;/code&gt;.
     * @return the package name or an empty string
     */
    @Nonnull
    public static String getPackageName(@Nullable Class&lt;?&gt; cls) {
<span class="pc bpc" id="L3335" title="1 of 2 branches missed.">        if (cls == null) {</span>
<span class="nc" id="L3336">            return EMPTY_STRING;</span>
        }
<span class="fc" id="L3338">        return getPackageName(cls.getName());</span>
    }

    /**
     * &lt;p&gt;Gets the package name from a &lt;code&gt;String&lt;/code&gt;.&lt;/p&gt;
     * &lt;p/&gt;
     * &lt;p&gt;The string passed in is assumed to be a class name - it is not checked.&lt;/p&gt;
     * &lt;p&gt;If the class is unpackaged, return an empty string.&lt;/p&gt;
     *
     * @param className the className to get the package name for, may be &lt;code&gt;null&lt;/code&gt;
     * @return the package name or an empty string
     */
    @Nonnull
    public static String getPackageName(@Nullable String className) {
<span class="pc bpc" id="L3352" title="2 of 4 branches missed.">        if (className == null || className.length() == 0) {</span>
<span class="nc" id="L3353">            return EMPTY_STRING;</span>
        }

        // Strip array encoding
<span class="pc bpc" id="L3357" title="1 of 2 branches missed.">        while (className.charAt(0) == '[') {</span>
<span class="nc" id="L3358">            className = className.substring(1);</span>
        }
        // Strip Object type encoding
<span class="pc bpc" id="L3361" title="3 of 4 branches missed.">        if (className.charAt(0) == 'L' &amp;&amp; className.charAt(className.length() - 1) == ';') {</span>
<span class="nc" id="L3362">            className = className.substring(1);</span>
        }

<span class="fc" id="L3365">        int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);</span>
<span class="pc bpc" id="L3366" title="1 of 2 branches missed.">        if (i == -1) {</span>
<span class="nc" id="L3367">            return EMPTY_STRING;</span>
        }
<span class="fc" id="L3369">        return className.substring(0, i);</span>
    }

    /**
     * param instance array to the type array
     *
     * @param args the arguments
     * @return the types of the arguments
     */
    @Nullable
    public static Class&lt;?&gt;[] convertToTypeArray(@Nullable Object[] args) {
<span class="nc bnc" id="L3380" title="All 2 branches missed.">        if (args == null) {</span>
<span class="nc" id="L3381">            return null;</span>
        }
<span class="nc" id="L3383">        int s = args.length;</span>
<span class="nc" id="L3384">        Class&lt;?&gt;[] ans = new Class&lt;?&gt;[s];</span>
<span class="nc bnc" id="L3385" title="All 2 branches missed.">        for (int i = 0; i &lt; s; i++) {</span>
<span class="nc" id="L3386">            Object o = args[i];</span>
<span class="nc bnc" id="L3387" title="All 2 branches missed.">            ans[i] = o != null ? o.getClass() : null;</span>
        }
<span class="nc" id="L3389">        return ans;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>