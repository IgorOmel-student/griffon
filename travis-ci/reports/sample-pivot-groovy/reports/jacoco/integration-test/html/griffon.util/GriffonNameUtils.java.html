<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GriffonNameUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sample-pivot-groovy</a> &gt; <a href="index.source.html" class="el_package">griffon.util</a> &gt; <span class="el_source">GriffonNameUtils.java</span></div><h1>GriffonNameUtils.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2008-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package griffon.util;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;

/**
 * Contains utility methods for converting between different name types,
 * for example from class names -&amp;gt; property names and vice-versa. The
 * key aspect of this class is that it has no dependencies outside the
 * JDK!
 */
<span class="nc" id="L32">public class GriffonNameUtils {</span>
    private static final String PROPERTY_SET_PREFIX = &quot;set&quot;;
    private static final String PROPERTY_GET_PREFIX = &quot;get&quot;;

<span class="fc" id="L36">    private static final String[] KEYWORDS = new String[]{</span>
        &quot;abstract&quot;,
        &quot;assert&quot;,
        &quot;as&quot;,
        &quot;break&quot;,
        &quot;case&quot;,
        &quot;catch&quot;,
        &quot;class&quot;,
        &quot;const&quot;,
        &quot;continue&quot;,
        &quot;default&quot;,
        &quot;do&quot;,
        &quot;else&quot;,
        &quot;enum&quot;,
        &quot;extends&quot;,
        &quot;final&quot;,
        &quot;finally&quot;,
        &quot;for&quot;,
        &quot;goto&quot;,
        &quot;if&quot;,
        &quot;implements&quot;,
        &quot;import&quot;,
        &quot;in&quot;,
        &quot;instanceof&quot;,
        &quot;interface&quot;,
        &quot;native&quot;,
        &quot;new&quot;,
        &quot;package&quot;,
        &quot;private&quot;,
        &quot;protected&quot;,
        &quot;public&quot;,
        &quot;return&quot;,
        &quot;static&quot;,
        &quot;strictfp&quot;,
        &quot;super&quot;,
        &quot;switch&quot;,
        &quot;synchronized&quot;,
        &quot;this&quot;,
        &quot;throw&quot;,
        &quot;throws&quot;,
        &quot;transient&quot;,
        &quot;try&quot;,
        &quot;void&quot;,
        &quot;volatile&quot;,
        &quot;while&quot;
    };

    /**
     * Finds out if the given String is a Java/Groovy keyword.
     *
     * @param str The String to test
     * @return &lt;tt&gt;true&lt;/tt&gt; if the given String is a keyword, false otherwise
     */
    public static boolean isKeyword(String str) {
<span class="nc bnc" id="L90" title="All 4 branches missed.">        return !isBlank(str) &amp;&amp; Arrays.binarySearch(KEYWORDS, str.toLowerCase(Locale.ENGLISH)) &gt; -1;</span>
    }

    /**
     * Capitalizes a String (makes the first char uppercase) taking care
     * of blank strings and single character strings.
     *
     * @param str The String to be capitalized
     * @return Capitalized version of the target string if it is not blank
     */
    public static String capitalize(String str) {
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">        if (isBlank(str)) return str;</span>
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">        if (str.length() == 1) return str.toUpperCase();</span>
<span class="fc" id="L103">        return str.substring(0, 1).toUpperCase(Locale.ENGLISH) + str.substring(1);</span>
    }

    /**
     * Uncapitalizes a String (makes the first char lowercase) taking care
     * of blank strings and single character strings.
     *
     * @param str The String to be uncapitalized
     * @return Uncapitalized version of the target string if it is not blank
     */
    public static String uncapitalize(String str) {
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">        if (isBlank(str)) return str;</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">        if (str.length() == 1)</span>
<span class="nc" id="L116">            return String.valueOf(Character.toLowerCase(str.charAt(0)));</span>
<span class="fc" id="L117">        return Character.toLowerCase(str.charAt(0)) + str.substring(1);</span>
    }

    /**
     * Retrieves the name of a setter for the specified property name
     *
     * @param propertyName The property name
     * @return The setter equivalent
     */
    public static String getSetterName(String propertyName) {
<span class="fc" id="L127">        return PROPERTY_SET_PREFIX + capitalize(propertyName);</span>
    }

    /**
     * Calculate the name for a getter method to retrieve the specified property
     *
     * @param propertyName The property name
     * @return The name for the getter method for this property, if it were to exist, i.e. getConstraints
     */
    public static String getGetterName(String propertyName) {
<span class="nc" id="L137">        return PROPERTY_GET_PREFIX + capitalize(propertyName);</span>
    }

    /**
     * Returns the class name for the given logical name and trailing name. For example &quot;person&quot; and &quot;Controller&quot; would evaluate to &quot;PersonController&quot;
     *
     * @param logicalName  The logical name
     * @param trailingName The trailing name
     * @return The class name
     */
    public static String getClassName(String logicalName, String trailingName) {
<span class="nc bnc" id="L148" title="All 2 branches missed.">        if (isBlank(logicalName)) {</span>
<span class="nc" id="L149">            throw new IllegalArgumentException(&quot;Argument [logicalName] must not be null or blank&quot;);</span>
        }

<span class="nc" id="L152">        String className = capitalize(logicalName);</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">        if (trailingName != null) {</span>
<span class="nc" id="L154">            className = className + trailingName;</span>
        }
<span class="nc" id="L156">        return className;</span>
    }

    /**
     * Returns the class name representation of the given name
     *
     * @param name The name to convert
     * @return The property name representation
     */
    public static String getClassNameRepresentation(String name) {
<span class="nc" id="L166">        StringBuilder buf = new StringBuilder();</span>
<span class="nc bnc" id="L167" title="All 4 branches missed.">        if (name != null &amp;&amp; name.length() &gt; 0) {</span>
<span class="nc" id="L168">            String[] tokens = name.split(&quot;[^\\w\\d]&quot;);</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">            for (String token1 : tokens) {</span>
<span class="nc" id="L170">                String token = token1.trim();</span>
<span class="nc" id="L171">                buf.append(capitalize(token));</span>
            }
        }

<span class="nc" id="L175">        return buf.toString();</span>
    }

    /**
     * Converts foo-bar into FooBar. Empty and null strings are returned
     * as-is.
     *
     * @param name The lower case hyphen separated name
     * @return The class name equivalent.
     */
    public static String getClassNameForLowerCaseHyphenSeparatedName(String name) {
        // Handle null and empty strings.
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">        if (isBlank(name)) return name;</span>

<span class="pc bpc" id="L189" title="1 of 2 branches missed.">        if (name.indexOf('-') &gt; -1) {</span>
<span class="fc" id="L190">            StringBuilder buf = new StringBuilder();</span>
<span class="fc" id="L191">            String[] tokens = name.split(&quot;-&quot;);</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">            for (String token : tokens) {</span>
<span class="pc bpc" id="L193" title="2 of 4 branches missed.">                if (token == null || token.length() == 0) continue;</span>
<span class="fc" id="L194">                buf.append(capitalize(token));</span>
            }
<span class="fc" id="L196">            return buf.toString();</span>
        }

<span class="nc" id="L199">        return capitalize(name);</span>
    }

    /**
     * Retrieves the logical class name of a Griffon artifact given the Griffon class
     * and a specified trailing name
     *
     * @param clazz        The class
     * @param trailingName The trailing name such as &quot;Controller&quot; or &quot;TagLib&quot;
     * @return The logical class name
     */
    public static String getLogicalName(Class&lt;?&gt; clazz, String trailingName) {
<span class="fc" id="L211">        return getLogicalName(clazz.getName(), trailingName);</span>
    }

    /**
     * Retrieves the logical name of the class without the trailing name
     *
     * @param name         The name of the class
     * @param trailingName The trailing name
     * @return The logical name
     */
    public static String getLogicalName(String name, String trailingName) {
<span class="fc bfc" id="L222" title="All 2 branches covered.">        if (!isBlank(trailingName)) {</span>
<span class="fc" id="L223">            String shortName = getShortName(name);</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">            if (shortName.endsWith(trailingName)) {</span>
<span class="fc" id="L225">                return shortName.substring(0, shortName.length() - trailingName.length());</span>
            }
        }
<span class="fc" id="L228">        return name;</span>
    }

    public static String getLogicalPropertyName(String className, String trailingName) {
<span class="pc bpc" id="L232" title="1 of 4 branches missed.">        if (!isBlank(className) &amp;&amp; !isBlank(trailingName)) {</span>
<span class="pc bpc" id="L233" title="3 of 4 branches missed.">            if (className.length() == trailingName.length() + 1 &amp;&amp; className.endsWith(trailingName)) {</span>
<span class="nc" id="L234">                return className.substring(0, 1).toLowerCase();</span>
            }
        }
<span class="fc" id="L237">        return getLogicalName(getPropertyName(className), trailingName);</span>
    }

    /**
     * Shorter version of getPropertyNameRepresentation
     *
     * @param name The name to convert
     * @return The property name version
     */
    public static String getPropertyName(String name) {
<span class="fc" id="L247">        return getPropertyNameRepresentation(name);</span>
    }

    /**
     * Shorter version of getPropertyNameRepresentation
     *
     * @param clazz The clazz to convert
     * @return The property name version
     */
    public static String getPropertyName(Class&lt;?&gt; clazz) {
<span class="nc" id="L257">        return getPropertyNameRepresentation(clazz);</span>
    }

    /**
     * Returns the property name equivalent for the specified class
     *
     * @param targetClass The class to get the property name for
     * @return A property name representation of the class name (eg. MyClass becomes myClass)
     */
    public static String getPropertyNameRepresentation(Class&lt;?&gt; targetClass) {
<span class="nc" id="L267">        String shortName = getShortName(targetClass);</span>
<span class="nc" id="L268">        return getPropertyNameRepresentation(shortName);</span>
    }

    /**
     * Returns the property name representation of the given name
     *
     * @param name The name to convert
     * @return The property name representation
     */
    public static String getPropertyNameRepresentation(String name) {
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        if (isBlank(name)) return name;</span>
        // Strip any package from the name.
<span class="fc" id="L280">        int pos = name.lastIndexOf('.');</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">        if (pos != -1) {</span>
<span class="fc" id="L282">            name = name.substring(pos + 1);</span>
        }

        // Check whether the name begins with two upper case letters.
<span class="pc bpc" id="L286" title="2 of 6 branches missed.">        if (name.length() &gt; 1 &amp;&amp; Character.isUpperCase(name.charAt(0)) &amp;&amp; Character.isUpperCase(name.charAt(1))) {</span>
<span class="nc" id="L287">            return name;</span>
        }

<span class="fc" id="L290">        String propertyName = name.substring(0, 1).toLowerCase(Locale.ENGLISH) + name.substring(1);</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">        if (propertyName.indexOf(' ') &gt; -1) {</span>
<span class="nc" id="L292">            propertyName = propertyName.replaceAll(&quot;\\s&quot;, &quot;&quot;);</span>
        }
<span class="fc" id="L294">        return propertyName;</span>
    }

    /**
     * Converts foo-bar into fooBar
     *
     * @param name The lower case hyphen separated name
     * @return The property name equivalent
     */
    public static String getPropertyNameForLowerCaseHyphenSeparatedName(String name) {
<span class="nc" id="L304">        return getPropertyName(getClassNameForLowerCaseHyphenSeparatedName(name));</span>
    }

    /**
     * Returns the class name without the package prefix
     *
     * @param targetClass The class to get a short name for
     * @return The short name of the class
     */
    public static String getShortName(Class&lt;?&gt; targetClass) {
<span class="nc" id="L314">        String className = targetClass.getName();</span>
<span class="nc" id="L315">        return getShortName(className);</span>
    }

    /**
     * Returns the class name without the package prefix
     *
     * @param className The class name to get a short name for
     * @return The short name of the class
     */
    public static String getShortName(String className) {
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">        if (isBlank(className)) return className;</span>
<span class="fc" id="L326">        int i = className.lastIndexOf(&quot;.&quot;);</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">        if (i &gt; -1) {</span>
<span class="fc" id="L328">            className = className.substring(i + 1, className.length());</span>
        }
<span class="fc" id="L330">        return className;</span>
    }

    /**
     * Converts a property name into its natural language equivalent eg ('firstName' becomes 'First Name')
     *
     * @param name The property name to convert
     * @return The converted property name
     */
    public static String getNaturalName(String name) {
<span class="fc" id="L340">        name = getShortName(name);</span>
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">        if (isBlank(name)) return name;</span>
<span class="fc" id="L342">        List&lt;String&gt; words = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L343">        int i = 0;</span>
<span class="fc" id="L344">        char[] chars = name.toCharArray();</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">        for (char c : chars) {</span>
            String w;
<span class="fc bfc" id="L347" title="All 2 branches covered.">            if (i &gt;= words.size()) {</span>
<span class="fc" id="L348">                w = &quot;&quot;;</span>
<span class="fc" id="L349">                words.add(i, w);</span>
            } else {
<span class="fc" id="L351">                w = words.get(i);</span>
            }

<span class="pc bpc" id="L354" title="1 of 4 branches missed.">            if (Character.isLowerCase(c) || Character.isDigit(c)) {</span>
<span class="pc bpc" id="L355" title="2 of 4 branches missed.">                if (Character.isLowerCase(c) &amp;&amp; w.length() == 0) {</span>
<span class="nc" id="L356">                    c = Character.toUpperCase(c);</span>
<span class="pc bpc" id="L357" title="1 of 4 branches missed.">                } else if (w.length() &gt; 1 &amp;&amp; Character.isUpperCase(w.charAt(w.length() - 1))) {</span>
<span class="nc" id="L358">                    w = &quot;&quot;;</span>
<span class="nc" id="L359">                    words.add(++i, w);</span>
                }

<span class="fc" id="L362">                words.set(i, w + c);</span>
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">            } else if (Character.isUpperCase(c)) {</span>
<span class="pc bpc" id="L364" title="2 of 6 branches missed.">                if ((i == 0 &amp;&amp; w.length() == 0) || Character.isUpperCase(w.charAt(w.length() - 1))) {</span>
<span class="fc" id="L365">                    words.set(i, w + c);</span>
                } else {
<span class="fc" id="L367">                    words.add(++i, String.valueOf(c));</span>
                }
            }
        }

<span class="fc" id="L372">        StringBuilder buf = new StringBuilder();</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">        for (Iterator&lt;String&gt; j = words.iterator(); j.hasNext(); ) {</span>
<span class="fc" id="L374">            String word = j.next();</span>
<span class="fc" id="L375">            buf.append(word);</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">            if (j.hasNext()) {</span>
<span class="fc" id="L377">                buf.append(' ');</span>
            }
<span class="fc" id="L379">        }</span>
<span class="fc" id="L380">        return buf.toString();</span>
    }

    /**
     * &lt;p&gt;Determines whether a given string is &lt;code&gt;null&lt;/code&gt;, empty,
     * or only contains whitespace. If it contains anything other than
     * whitespace then the string is not considered to be blank and the
     * method returns &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
     * &lt;p&gt;We could use Commons Lang for this, but we don't want GriffonNameUtils
     * to have a dependency on any external library to minimise the number of
     * dependencies required to bootstrap Griffon.&lt;/p&gt;
     *
     * @param str The string to test.
     * @return &lt;code&gt;true&lt;/code&gt; if the string is &lt;code&gt;null&lt;/code&gt;, or
     * blank.
     */
    public static boolean isBlank(String str) {
<span class="fc bfc" id="L397" title="All 4 branches covered.">        if (str == null || str.length() == 0) {</span>
<span class="fc" id="L398">            return true;</span>
        }
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">        for (char c : str.toCharArray()) {</span>
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">            if (!Character.isWhitespace(c)) {</span>
<span class="fc" id="L402">                return false;</span>
            }
        }

<span class="nc" id="L406">        return true;</span>
    }

    /**
     * Checks that the specified String is not {@code blank}. This
     * method is designed primarily for doing parameter validation in methods
     * and constructors, as demonstrated below:
     * &lt;blockquote&gt;&lt;pre&gt;
     * public Foo(String str) {
     *     this.str = GriffonNameUtils.requireNonBlank(str);
     * }
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @param str the String to check for blank
     * @return {@code str} if not {@code blank}
     * @throws IllegalArgumentException if {@code str} is {@code blank}
     */
    public static String requireNonBlank(String str) {
<span class="nc bnc" id="L424" title="All 2 branches missed.">        if (isBlank(str)) {</span>
<span class="nc" id="L425">            throw new IllegalArgumentException();</span>
        }
<span class="nc" id="L427">        return str;</span>
    }

    /**
     * Checks that the specified String is not {@code blank} and
     * throws a customized {@link IllegalArgumentException} if it is. This method
     * is designed primarily for doing parameter validation in methods and
     * constructors with multiple parameters, as demonstrated below:
     * &lt;blockquote&gt;&lt;pre&gt;
     * public Foo(String str) {
     *     this.str = GriffonNameUtils.requireNonBlank(str, &quot;str must not be null&quot;);
     * }
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @param str     the String to check for blank
     * @param message detail message to be used in the event that a {@code
     *                IllegalArgumentException} is thrown
     * @return {@code str} if not {@code blank}
     * @throws IllegalArgumentException if {@code str} is {@code blank}
     */
    public static String requireNonBlank(String str, String message) {
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">        if (isBlank(str)) {</span>
<span class="nc" id="L449">            throw new IllegalArgumentException(message);</span>
        }
<span class="fc" id="L451">        return str;</span>
    }

    /**
     * Retrieves the hyphenated name representation of the supplied class. For example
     * MyFunkyGriffonThingy would be my-funky-griffon-thingy.
     *
     * @param clazz The class to convert
     * @return The hyphenated name representation
     */
    public static String getHyphenatedName(Class&lt;?&gt; clazz) {
<span class="nc bnc" id="L462" title="All 2 branches missed.">        if (clazz == null) {</span>
<span class="nc" id="L463">            return null;</span>
        }
<span class="nc" id="L465">        return getHyphenatedName(clazz.getName());</span>
    }

    /**
     * Retrieves the hyphenated name representation of the given class name.
     * For example MyFunkyGriffonThingy would be my-funky-griffon-thingy.
     *
     * @param name The class name to convert.
     * @return The hyphenated name representation.
     */
    public static String getHyphenatedName(String name) {
<span class="nc bnc" id="L476" title="All 2 branches missed.">        if (isBlank(name)) return name;</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">        if (name.endsWith(&quot;.groovy&quot;)) {</span>
<span class="nc" id="L478">            name = name.substring(0, name.length() - 7);</span>
        }
<span class="nc" id="L480">        String naturalName = getNaturalName(getShortName(name));</span>
<span class="nc" id="L481">        return naturalName.replaceAll(&quot;\\s&quot;, &quot;-&quot;).toLowerCase();</span>
    }

    /**
     * Concatenates the &lt;code&gt;toString()&lt;/code&gt; representation of each
     * item in this Iterable, with the given String as a separator between each item.
     *
     * @param self      an Iterable of objects
     * @param separator a String separator
     * @return the joined String
     */
    @Nonnull
    public static String join(@Nonnull Iterable self, @Nullable String separator) {
<span class="nc" id="L494">        StringBuilder buffer = new StringBuilder();</span>
<span class="nc" id="L495">        boolean first = true;</span>

<span class="nc bnc" id="L497" title="All 2 branches missed.">        if (separator == null) separator = &quot;&quot;;</span>

<span class="nc bnc" id="L499" title="All 2 branches missed.">        for (Object value : self) {</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">            if (first) {</span>
<span class="nc" id="L501">                first = false;</span>
            } else {
<span class="nc" id="L503">                buffer.append(separator);</span>
            }
<span class="nc" id="L505">            buffer.append(String.valueOf(value));</span>
<span class="nc" id="L506">        }</span>
<span class="nc" id="L507">        return buffer.toString();</span>
    }

    /**
     * Applies single or double quotes to a string if it contains whitespace characters
     *
     * @param str the String to be surrounded by quotes
     * @return a copy of the original String, surrounded by quotes
     */
    public static String quote(String str) {
<span class="nc bnc" id="L517" title="All 2 branches missed.">        if (isBlank(str)) return str;</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">        for (int i = 0; i &lt; str.length(); i++) {</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">            if (Character.isWhitespace(str.charAt(i))) {</span>
<span class="nc" id="L520">                str = applyQuotes(str);</span>
<span class="nc" id="L521">                break;</span>
            }
        }
<span class="nc" id="L524">        return str;</span>
    }

    /**
     * Removes single or double quotes from a String
     *
     * @param str the String from which quotes will be removed
     * @return the unquoted String
     */
    public static String unquote(String str) {
<span class="nc bnc" id="L534" title="All 2 branches missed.">        if (isBlank(str)) return str;</span>
<span class="nc bnc" id="L535" title="All 4 branches missed.">        if ((str.startsWith(&quot;'&quot;) &amp;&amp; str.endsWith(&quot;'&quot;)) ||</span>
<span class="nc bnc" id="L536" title="All 4 branches missed.">            (str.startsWith(&quot;\&quot;&quot;) &amp;&amp; str.endsWith(&quot;\&quot;&quot;))) {</span>
<span class="nc" id="L537">            return str.substring(1, str.length() - 1);</span>
        }
<span class="nc" id="L539">        return str;</span>
    }

    private static String applyQuotes(String string) {
<span class="nc bnc" id="L543" title="All 4 branches missed.">        if (string == null || string.length() == 0) {</span>
<span class="nc" id="L544">            return &quot;\&quot;\&quot;&quot;;</span>
        }

        char b;
<span class="nc" id="L548">        char c = 0;</span>
        int i;
<span class="nc" id="L550">        int len = string.length();</span>
<span class="nc" id="L551">        StringBuilder sb = new StringBuilder(len * 2);</span>
        String t;
<span class="nc" id="L553">        char[] chars = string.toCharArray();</span>
<span class="nc" id="L554">        char[] buffer = new char[1030];</span>
<span class="nc" id="L555">        int bufferIndex = 0;</span>
<span class="nc" id="L556">        sb.append('&quot;');</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">        for (i = 0; i &lt; len; i += 1) {</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">            if (bufferIndex &gt; 1024) {</span>
<span class="nc" id="L559">                sb.append(buffer, 0, bufferIndex);</span>
<span class="nc" id="L560">                bufferIndex = 0;</span>
            }
<span class="nc" id="L562">            b = c;</span>
<span class="nc" id="L563">            c = chars[i];</span>
<span class="nc bnc" id="L564" title="All 3 branches missed.">            switch (c) {</span>
                case '\\':
                case '&quot;':
<span class="nc" id="L567">                    buffer[bufferIndex++] = '\\';</span>
<span class="nc" id="L568">                    buffer[bufferIndex++] = c;</span>
<span class="nc" id="L569">                    break;</span>
                case '/':
<span class="nc bnc" id="L571" title="All 2 branches missed.">                    if (b == '&lt;') {</span>
<span class="nc" id="L572">                        buffer[bufferIndex++] = '\\';</span>
                    }
<span class="nc" id="L574">                    buffer[bufferIndex++] = c;</span>
<span class="nc" id="L575">                    break;</span>
                default:
<span class="nc bnc" id="L577" title="All 2 branches missed.">                    if (c &lt; ' ') {</span>
<span class="nc bnc" id="L578" title="All 6 branches missed.">                        switch (c) {</span>
                            case '\b':
<span class="nc" id="L580">                                buffer[bufferIndex++] = '\\';</span>
<span class="nc" id="L581">                                buffer[bufferIndex++] = 'b';</span>
<span class="nc" id="L582">                                break;</span>
                            case '\t':
<span class="nc" id="L584">                                buffer[bufferIndex++] = '\\';</span>
<span class="nc" id="L585">                                buffer[bufferIndex++] = 't';</span>
<span class="nc" id="L586">                                break;</span>
                            case '\n':
<span class="nc" id="L588">                                buffer[bufferIndex++] = '\\';</span>
<span class="nc" id="L589">                                buffer[bufferIndex++] = 'n';</span>
<span class="nc" id="L590">                                break;</span>
                            case '\f':
<span class="nc" id="L592">                                buffer[bufferIndex++] = '\\';</span>
<span class="nc" id="L593">                                buffer[bufferIndex++] = 'f';</span>
<span class="nc" id="L594">                                break;</span>
                            case '\r':
<span class="nc" id="L596">                                buffer[bufferIndex++] = '\\';</span>
<span class="nc" id="L597">                                buffer[bufferIndex++] = 'r';</span>
<span class="nc" id="L598">                                break;</span>
                            default:
<span class="nc" id="L600">                                t = &quot;000&quot; + Integer.toHexString(c);</span>
<span class="nc" id="L601">                                int tLength = t.length();</span>
<span class="nc" id="L602">                                buffer[bufferIndex++] = '\\';</span>
<span class="nc" id="L603">                                buffer[bufferIndex++] = 'u';</span>
<span class="nc" id="L604">                                buffer[bufferIndex++] = t.charAt(tLength - 4);</span>
<span class="nc" id="L605">                                buffer[bufferIndex++] = t.charAt(tLength - 3);</span>
<span class="nc" id="L606">                                buffer[bufferIndex++] = t.charAt(tLength - 2);</span>
<span class="nc" id="L607">                                buffer[bufferIndex++] = t.charAt(tLength - 1);</span>
                        }
                    } else {
<span class="nc" id="L610">                        buffer[bufferIndex++] = c;</span>
                    }
            }
        }
<span class="nc" id="L614">        sb.append(buffer, 0, bufferIndex);</span>
<span class="nc" id="L615">        sb.append('&quot;');</span>
<span class="nc" id="L616">        return sb.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>