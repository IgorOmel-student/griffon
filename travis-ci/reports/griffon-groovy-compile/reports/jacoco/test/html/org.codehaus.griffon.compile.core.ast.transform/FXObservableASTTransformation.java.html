<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FXObservableASTTransformation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">griffon-groovy-compile</a> &gt; <a href="index.source.html" class="el_package">org.codehaus.griffon.compile.core.ast.transform</a> &gt; <span class="el_source">FXObservableASTTransformation.java</span></div><h1>FXObservableASTTransformation.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2008-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.codehaus.griffon.compile.core.ast.transform;

import griffon.transform.FXObservable;
import griffon.util.GriffonNameUtils;
import groovyjarjarasm.asm.Opcodes;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.FloatProperty;
import javafx.beans.property.IntegerProperty;
import javafx.beans.property.ListProperty;
import javafx.beans.property.LongProperty;
import javafx.beans.property.MapProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SetProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.property.SimpleFloatProperty;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.beans.property.SimpleListProperty;
import javafx.beans.property.SimpleLongProperty;
import javafx.beans.property.SimpleMapProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.property.SimpleSetProperty;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.collections.ObservableMap;
import javafx.collections.ObservableSet;
import org.codehaus.griffon.compile.core.AnnotationHandler;
import org.codehaus.griffon.compile.core.AnnotationHandlerFor;
import org.codehaus.groovy.ast.ASTNode;
import org.codehaus.groovy.ast.AnnotatedNode;
import org.codehaus.groovy.ast.AnnotationNode;
import org.codehaus.groovy.ast.ClassHelper;
import org.codehaus.groovy.ast.ClassNode;
import org.codehaus.groovy.ast.FieldNode;
import org.codehaus.groovy.ast.GenericsType;
import org.codehaus.groovy.ast.MethodNode;
import org.codehaus.groovy.ast.Parameter;
import org.codehaus.groovy.ast.PropertyNode;
import org.codehaus.groovy.ast.expr.ArgumentListExpression;
import org.codehaus.groovy.ast.expr.BinaryExpression;
import org.codehaus.groovy.ast.expr.BooleanExpression;
import org.codehaus.groovy.ast.expr.CastExpression;
import org.codehaus.groovy.ast.expr.ClassExpression;
import org.codehaus.groovy.ast.expr.ConstantExpression;
import org.codehaus.groovy.ast.expr.ConstructorCallExpression;
import org.codehaus.groovy.ast.expr.Expression;
import org.codehaus.groovy.ast.expr.FieldExpression;
import org.codehaus.groovy.ast.expr.ListExpression;
import org.codehaus.groovy.ast.expr.MapExpression;
import org.codehaus.groovy.ast.expr.MethodCallExpression;
import org.codehaus.groovy.ast.expr.VariableExpression;
import org.codehaus.groovy.ast.stmt.BlockStatement;
import org.codehaus.groovy.ast.stmt.EmptyStatement;
import org.codehaus.groovy.ast.stmt.ExpressionStatement;
import org.codehaus.groovy.ast.stmt.IfStatement;
import org.codehaus.groovy.ast.stmt.ReturnStatement;
import org.codehaus.groovy.ast.stmt.Statement;
import org.codehaus.groovy.control.CompilePhase;
import org.codehaus.groovy.control.SourceUnit;
import org.codehaus.groovy.control.messages.SyntaxErrorMessage;
import org.codehaus.groovy.runtime.MetaClassHelper;
import org.codehaus.groovy.syntax.SyntaxException;
import org.codehaus.groovy.syntax.Token;
import org.codehaus.groovy.syntax.Types;
import org.codehaus.groovy.transform.GroovyASTTransformation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Target;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static org.codehaus.groovy.ast.ClassHelper.LIST_TYPE;
import static org.codehaus.groovy.ast.ClassHelper.MAP_TYPE;


/**
 * Handles generation of code for the {@code @FXObservable}
 * &lt;p&gt;
 * Generally, it adds (if needed) a javafx.beans.property.Property type
 * &lt;p&gt;
 * It also generates the setter and getter and wires the them through the
 * javafx.beans.property.Property.
 *
 * @author Andres Almiray
 */
@AnnotationHandlerFor(FXObservable.class)
@GroovyASTTransformation(phase = CompilePhase.CANONICALIZATION)
<span class="fc" id="L110">public class FXObservableASTTransformation extends AbstractASTTransformation implements AnnotationHandler {</span>
<span class="fc" id="L111">    private static final ClassNode FXOBSERVABLE_CNODE = makeClassSafe(FXObservable.class);</span>

<span class="fc" id="L113">    private static final ClassNode OBJECT_PROPERTY_CNODE = makeClassSafe(ObjectProperty.class);</span>
<span class="fc" id="L114">    private static final ClassNode BOOLEAN_PROPERTY_CNODE = makeClassSafe(BooleanProperty.class);</span>
<span class="fc" id="L115">    private static final ClassNode DOUBLE_PROPERTY_CNODE = makeClassSafe(DoubleProperty.class);</span>
<span class="fc" id="L116">    private static final ClassNode FLOAT_PROPERTY_CNODE = makeClassSafe(FloatProperty.class);</span>
<span class="fc" id="L117">    private static final ClassNode INT_PROPERTY_CNODE = makeClassSafe(IntegerProperty.class);</span>
<span class="fc" id="L118">    private static final ClassNode LONG_PROPERTY_CNODE = makeClassSafe(LongProperty.class);</span>
<span class="fc" id="L119">    private static final ClassNode STRING_PROPERTY_CNODE = makeClassSafe(StringProperty.class);</span>
<span class="fc" id="L120">    private static final ClassNode LIST_PROPERTY_CNODE = makeClassSafe(ListProperty.class);</span>
<span class="fc" id="L121">    private static final ClassNode MAP_PROPERTY_CNODE = makeClassSafe(MapProperty.class);</span>
<span class="fc" id="L122">    private static final ClassNode SET_PROPERTY_CNODE = makeClassSafe(SetProperty.class);</span>

<span class="fc" id="L124">    private static final ClassNode SIMPLE_BOOLEAN_PROPERTY_CNODE = makeClassSafe(SimpleBooleanProperty.class);</span>
<span class="fc" id="L125">    private static final ClassNode SIMPLE_DOUBLE_PROPERTY_CNODE = makeClassSafe(SimpleDoubleProperty.class);</span>
<span class="fc" id="L126">    private static final ClassNode SIMPLE_FLOAT_PROPERTY_CNODE = makeClassSafe(SimpleFloatProperty.class);</span>
<span class="fc" id="L127">    private static final ClassNode SIMPLE_INT_PROPERTY_CNODE = makeClassSafe(SimpleIntegerProperty.class);</span>
<span class="fc" id="L128">    private static final ClassNode SIMPLE_LONG_PROPERTY_CNODE = makeClassSafe(SimpleLongProperty.class);</span>
<span class="fc" id="L129">    private static final ClassNode SIMPLE_STRING_PROPERTY_CNODE = makeClassSafe(SimpleStringProperty.class);</span>
<span class="fc" id="L130">    private static final ClassNode SIMPLE_LIST_PROPERTY_CNODE = makeClassSafe(SimpleListProperty.class);</span>
<span class="fc" id="L131">    private static final ClassNode SIMPLE_MAP_PROPERTY_CNODE = makeClassSafe(SimpleMapProperty.class);</span>
<span class="fc" id="L132">    private static final ClassNode SIMPLE_SET_PROPERTY_CNODE = makeClassSafe(SimpleSetProperty.class);</span>
<span class="fc" id="L133">    private static final ClassNode SIMPLE_OBJECT_PROPERTY_CNODE = makeClassSafe(SimpleObjectProperty.class);</span>

<span class="fc" id="L135">    private static final ClassNode OBSERVABLE_LIST_CNODE = makeClassSafe(ObservableList.class);</span>
<span class="fc" id="L136">    private static final ClassNode OBSERVABLE_MAP_CNODE = makeClassSafe(ObservableMap.class);</span>
<span class="fc" id="L137">    private static final ClassNode OBSERVABLE_SET_CNODE = makeClassSafe(ObservableSet.class);</span>
<span class="fc" id="L138">    private static final ClassNode FXCOLLECTIONS_CNODE = makeClassSafe(FXCollections.class);</span>
<span class="fc" id="L139">    private static final ClassNode SET_TYPE = makeClassSafe(Set.class);</span>

<span class="fc" id="L141">    private static final Map&lt;ClassNode, ClassNode&gt; PROPERTY_TYPE_MAP = new HashMap&lt;&gt;();</span>

    static {
<span class="fc" id="L144">        PROPERTY_TYPE_MAP.put(ClassHelper.STRING_TYPE, STRING_PROPERTY_CNODE);</span>
<span class="fc" id="L145">        PROPERTY_TYPE_MAP.put(ClassHelper.boolean_TYPE, BOOLEAN_PROPERTY_CNODE);</span>
<span class="fc" id="L146">        PROPERTY_TYPE_MAP.put(ClassHelper.Boolean_TYPE, BOOLEAN_PROPERTY_CNODE);</span>
<span class="fc" id="L147">        PROPERTY_TYPE_MAP.put(ClassHelper.double_TYPE, DOUBLE_PROPERTY_CNODE);</span>
<span class="fc" id="L148">        PROPERTY_TYPE_MAP.put(ClassHelper.Double_TYPE, DOUBLE_PROPERTY_CNODE);</span>
<span class="fc" id="L149">        PROPERTY_TYPE_MAP.put(ClassHelper.float_TYPE, FLOAT_PROPERTY_CNODE);</span>
<span class="fc" id="L150">        PROPERTY_TYPE_MAP.put(ClassHelper.Float_TYPE, FLOAT_PROPERTY_CNODE);</span>
<span class="fc" id="L151">        PROPERTY_TYPE_MAP.put(ClassHelper.int_TYPE, INT_PROPERTY_CNODE);</span>
<span class="fc" id="L152">        PROPERTY_TYPE_MAP.put(ClassHelper.Integer_TYPE, INT_PROPERTY_CNODE);</span>
<span class="fc" id="L153">        PROPERTY_TYPE_MAP.put(ClassHelper.long_TYPE, LONG_PROPERTY_CNODE);</span>
<span class="fc" id="L154">        PROPERTY_TYPE_MAP.put(ClassHelper.Long_TYPE, LONG_PROPERTY_CNODE);</span>
<span class="fc" id="L155">        PROPERTY_TYPE_MAP.put(ClassHelper.short_TYPE, INT_PROPERTY_CNODE);</span>
<span class="fc" id="L156">        PROPERTY_TYPE_MAP.put(ClassHelper.Short_TYPE, INT_PROPERTY_CNODE);</span>
<span class="fc" id="L157">        PROPERTY_TYPE_MAP.put(ClassHelper.byte_TYPE, INT_PROPERTY_CNODE);</span>
<span class="fc" id="L158">        PROPERTY_TYPE_MAP.put(ClassHelper.Byte_TYPE, INT_PROPERTY_CNODE);</span>
        //PROPERTY_TYPE_MAP.put(ClassHelper.char_TYPE, INT_PROPERTY_CNODE);
        //PROPERTY_TYPE_MAP.put(ClassHelper.Character_TYPE, INT_PROPERTY_CNODE);
    }

<span class="fc" id="L163">    private static final Map&lt;ClassNode, ClassNode&gt; PROPERTY_IMPL_MAP = new HashMap&lt;ClassNode, ClassNode&gt;();</span>

    static {
<span class="fc" id="L166">        PROPERTY_IMPL_MAP.put(BOOLEAN_PROPERTY_CNODE, SIMPLE_BOOLEAN_PROPERTY_CNODE);</span>
<span class="fc" id="L167">        PROPERTY_IMPL_MAP.put(DOUBLE_PROPERTY_CNODE, SIMPLE_DOUBLE_PROPERTY_CNODE);</span>
<span class="fc" id="L168">        PROPERTY_IMPL_MAP.put(FLOAT_PROPERTY_CNODE, SIMPLE_FLOAT_PROPERTY_CNODE);</span>
<span class="fc" id="L169">        PROPERTY_IMPL_MAP.put(INT_PROPERTY_CNODE, SIMPLE_INT_PROPERTY_CNODE);</span>
<span class="fc" id="L170">        PROPERTY_IMPL_MAP.put(LONG_PROPERTY_CNODE, SIMPLE_LONG_PROPERTY_CNODE);</span>
<span class="fc" id="L171">        PROPERTY_IMPL_MAP.put(STRING_PROPERTY_CNODE, SIMPLE_STRING_PROPERTY_CNODE);</span>
<span class="fc" id="L172">        PROPERTY_IMPL_MAP.put(LIST_PROPERTY_CNODE, SIMPLE_LIST_PROPERTY_CNODE);</span>
<span class="fc" id="L173">        PROPERTY_IMPL_MAP.put(MAP_PROPERTY_CNODE, SIMPLE_MAP_PROPERTY_CNODE);</span>
<span class="fc" id="L174">        PROPERTY_IMPL_MAP.put(SET_PROPERTY_CNODE, SIMPLE_SET_PROPERTY_CNODE);</span>
        //PROPERTY_IMPL_MAP.put(OBJECT_PROPERTY_CNODE, SIMPLE_OBJECT_PROPERTY_CNODE);
<span class="fc" id="L176">    }</span>

    /**
     * Convenience method to see if an annotated node is {@code @FXObservable}.
     *
     * @param node the node to check
     * @return true if the node is observable
     */
    public static boolean hasFXObservableAnnotation(AnnotatedNode node) {
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">        for (AnnotationNode annotation : node.getAnnotations()) {</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">            if (FXOBSERVABLE_CNODE.equals(annotation.getClassNode())) {</span>
<span class="nc" id="L187">                return true;</span>
            }
<span class="nc" id="L189">        }</span>
<span class="fc" id="L190">        return false;</span>
    }

    /**
     * This ASTTransformation method is called when the compiler encounters our annotation.
     *
     * @param nodes      An array of nodes.  Index 0 is the annotation that triggered the call, index 1
     *                   is the annotated node.
     * @param sourceUnit The SourceUnit describing the source code in which the annotation was placed.
     */
    @Override
    public void visit(ASTNode[] nodes, SourceUnit sourceUnit) {
<span class="pc bpc" id="L202" title="2 of 4 branches missed.">        if (!(nodes[0] instanceof AnnotationNode) || !(nodes[1] instanceof AnnotatedNode)) {</span>
<span class="nc" id="L203">            throw new IllegalArgumentException(&quot;Internal error: wrong types: &quot;</span>
<span class="nc" id="L204">                + nodes[0].getClass().getName() + &quot; / &quot; + nodes[1].getClass().getName());</span>
        }

<span class="fc" id="L207">        AnnotationNode node = (AnnotationNode) nodes[0];</span>
<span class="fc" id="L208">        AnnotatedNode parent = (AnnotatedNode) nodes[1];</span>
<span class="fc" id="L209">        ClassNode declaringClass = parent.getDeclaringClass();</span>

<span class="fc bfc" id="L211" title="All 2 branches covered.">        if (parent instanceof FieldNode) {</span>
<span class="fc" id="L212">            int modifiers = ((FieldNode) parent).getModifiers();</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">            if ((modifiers &amp; Modifier.FINAL) != 0) {</span>
<span class="nc" id="L214">                String msg = &quot;@griffon.transform.FXObservable cannot annotate a final property.&quot;;</span>
<span class="nc" id="L215">                generateSyntaxErrorMessage(sourceUnit, node, msg);</span>
            }
<span class="fc" id="L217">            addJavaFXProperty(sourceUnit, node, declaringClass, (FieldNode) parent);</span>
<span class="fc" id="L218">        } else {</span>
<span class="fc" id="L219">            addJavaFXPropertyToClass(sourceUnit, node, (ClassNode) parent);</span>
        }
<span class="fc" id="L221">    }</span>

    /**
     * Adds a JavaFX property to the class in place of the original Groovy property.  A pair of synthetic
     * getter/setter methods is generated to provide pseudo-access to the original property.
     *
     * @param source         The SourceUnit in which the annotation was found
     * @param node           The node that was annotated
     * @param declaringClass The class in which the annotation was found
     * @param field          The field upon which the annotation was placed
     */
    private void addJavaFXProperty(SourceUnit source, AnnotationNode node, ClassNode declaringClass, FieldNode field) {
<span class="fc" id="L233">        String fieldName = field.getName();</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">        for (PropertyNode propertyNode : declaringClass.getProperties()) {</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">            if (propertyNode.getName().equals(fieldName)) {</span>
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">                if (field.isStatic()) {</span>
<span class="nc" id="L237">                    String message = &quot;@griffon.transform.FXObservable cannot annotate a static property.&quot;;</span>
<span class="nc" id="L238">                    generateSyntaxErrorMessage(source, node, message);</span>
<span class="nc" id="L239">                } else {</span>
<span class="fc" id="L240">                    createPropertyGetterSetter(declaringClass, propertyNode);</span>
                }
<span class="fc" id="L242">                return;</span>
            }
<span class="nc" id="L244">        }</span>

<span class="nc" id="L246">        String message = &quot;@griffon.transform.FXObservable must be on a property, not a field. Try removing the private, &quot; +</span>
            &quot;protected, or public modifier.&quot;;
<span class="nc" id="L248">        generateSyntaxErrorMessage(source, node, message);</span>
<span class="nc" id="L249">    }</span>

    /**
     * Iterate through the properties of the class and convert each eligible property to a JavaFX property.
     *
     * @param source    The SourceUnit
     * @param node      The AnnotationNode
     * @param classNode The declaring class
     */
    private void addJavaFXPropertyToClass(SourceUnit source, AnnotationNode node, ClassNode classNode) {
<span class="fc bfc" id="L259" title="All 2 branches covered.">        for (PropertyNode propertyNode : classNode.getProperties()) {</span>
<span class="fc" id="L260">            FieldNode field = propertyNode.getField();</span>
            // look to see if per-field handlers will catch this one...
<span class="pc bpc" id="L262" title="1 of 2 branches missed.">            if (hasFXObservableAnnotation(field)</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">                || ((field.getModifiers() &amp; Modifier.FINAL) != 0)</span>
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">                || field.isStatic()) {</span>
                // explicitly labeled properties are already handled,
                // don't transform final properties
                // don't transform static properties
<span class="nc" id="L268">                continue;</span>
            }
<span class="fc" id="L270">            createPropertyGetterSetter(classNode, propertyNode);</span>
<span class="fc" id="L271">        }</span>
<span class="fc" id="L272">    }</span>

    /**
     * Creates the JavaFX property and three methods for accessing the property and a pair of
     * getter/setter methods for accessing the original (now synthetic) Groovy property.  For
     * example, if the original property was &quot;String firstName&quot; then these three methods would
     * be generated:
     * &lt;p&gt;
     * public String getFirstName()
     * public void setFirstName(String value)
     * public StringProperty firstNameProperty()
     *
     * @param classNode    The declaring class in which the property will appear
     * @param originalProp The original Groovy property
     */
    private void createPropertyGetterSetter(ClassNode classNode, PropertyNode originalProp) {
<span class="fc" id="L288">        Expression initExp = originalProp.getInitialExpression();</span>
<span class="fc" id="L289">        originalProp.getField().setInitialValueExpression(null);</span>

<span class="fc" id="L291">        PropertyNode fxProperty = createFXProperty(originalProp);</span>

<span class="fc" id="L293">        List&lt;AnnotationNode&gt; methodAnnotations = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L294">        List&lt;AnnotationNode&gt; fieldAnnotations = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">        for (AnnotationNode annotation : originalProp.getField().getAnnotations()) {</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">            if (FXOBSERVABLE_CNODE.equals(annotation.getClassNode())) continue;</span>
<span class="fc" id="L297">            Class annotationClass = annotation.getClassNode().getTypeClass();</span>
<span class="fc" id="L298">            Target target = (Target) annotationClass.getAnnotation(Target.class);</span>
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">            if (isTargetAllowed(target, ElementType.METHOD)) {</span>
<span class="nc" id="L300">                methodAnnotations.add(annotation);</span>
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">            } else if (isTargetAllowed(target, ElementType.FIELD)) {</span>
<span class="fc" id="L302">                fieldAnnotations.add(annotation);</span>
            }
<span class="fc" id="L304">        }</span>

<span class="fc" id="L306">        String getterName = &quot;get&quot; + MetaClassHelper.capitalize(originalProp.getName());</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">        if (classNode.getMethods(getterName).isEmpty()) {</span>
<span class="fc" id="L308">            Statement getterBlock = createGetterStatement(createFXProperty(originalProp));</span>
<span class="fc" id="L309">            createGetterMethod(classNode, originalProp, getterName, getterBlock, methodAnnotations);</span>
<span class="fc" id="L310">            methodAnnotations = null;</span>
<span class="fc" id="L311">        } else {</span>
<span class="nc" id="L312">            wrapGetterMethod(classNode, originalProp.getName(), methodAnnotations);</span>
<span class="nc" id="L313">            methodAnnotations = null;</span>
        }

<span class="fc" id="L316">        String setterName = &quot;set&quot; + MetaClassHelper.capitalize(originalProp.getName());</span>
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">        if (classNode.getMethods(setterName).isEmpty()) {</span>
<span class="fc" id="L318">            Statement setterBlock = createSetterStatement(createFXProperty(originalProp));</span>
<span class="fc" id="L319">            createSetterMethod(classNode, originalProp, setterName, setterBlock, methodAnnotations);</span>
<span class="fc" id="L320">        } else {</span>
<span class="nc" id="L321">            wrapSetterMethod(classNode, originalProp.getName(), methodAnnotations);</span>
        }

        // We want the actual name of the field to be different from the getter (Prop vs Property) so
        // that the getter takes precedence when we say this.somethingProperty.
<span class="fc" id="L326">        FieldNode fxFieldShortName = createFieldNodeCopy(originalProp.getName() + &quot;Prop&quot;, null, fxProperty.getField());</span>
<span class="fc" id="L327">        createPropertyAccessor(classNode, createFXProperty(originalProp), fxFieldShortName, initExp);</span>

<span class="fc" id="L329">        classNode.removeField(originalProp.getName());</span>
<span class="fc" id="L330">        classNode.addField(fxFieldShortName);</span>
<span class="fc" id="L331">        fxFieldShortName.addAnnotations(fieldAnnotations);</span>
<span class="fc" id="L332">    }</span>

    private boolean isTargetAllowed(Target target, ElementType elementType) {
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">        if (target == null) {</span>
<span class="nc" id="L336">            return false;</span>
        }
<span class="fc bfc" id="L338" title="All 2 branches covered.">        for (ElementType et : target.value()) {</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">            if (et == elementType) {</span>
<span class="fc" id="L340">                return true;</span>
            }
        }
<span class="fc" id="L343">        return false;</span>
    }

    /**
     * Creates a new PropertyNode for the JavaFX property based on the original property.  The new property
     * will have &quot;Property&quot; appended to its name and its type will be one of the *Property types in JavaFX.
     *
     * @param orig The original property
     * @return A new PropertyNode for the JavaFX property
     */
    private PropertyNode createFXProperty(PropertyNode orig) {
<span class="fc" id="L354">        ClassNode origType = orig.getType();</span>
<span class="fc" id="L355">        ClassNode newType = PROPERTY_TYPE_MAP.get(origType);</span>

        // For the ObjectProperty, we need to add the generic type to it.
<span class="fc bfc" id="L358" title="All 2 branches covered.">        if (newType == null) {</span>
<span class="pc bpc" id="L359" title="1 of 4 branches missed.">            if (isTypeCompatible(ClassHelper.LIST_TYPE, origType) || isTypeCompatible(OBSERVABLE_LIST_CNODE, origType)) {</span>
<span class="fc" id="L360">                newType = makeClassSafe(SIMPLE_LIST_PROPERTY_CNODE);</span>
<span class="fc" id="L361">                GenericsType[] genericTypes = origType.getGenericsTypes();</span>
<span class="fc" id="L362">                newType.setGenericsTypes(genericTypes);</span>
<span class="pc bpc" id="L363" title="1 of 4 branches missed.">            } else if (isTypeCompatible(ClassHelper.MAP_TYPE, origType) || isTypeCompatible(OBSERVABLE_MAP_CNODE, origType)) {</span>
<span class="fc" id="L364">                newType = makeClassSafe(SIMPLE_MAP_PROPERTY_CNODE);</span>
<span class="fc" id="L365">                GenericsType[] genericTypes = origType.getGenericsTypes();</span>
<span class="fc" id="L366">                newType.setGenericsTypes(genericTypes);</span>
<span class="pc bpc" id="L367" title="1 of 4 branches missed.">            } else if (isTypeCompatible(SET_TYPE, origType) || isTypeCompatible(OBSERVABLE_SET_CNODE, origType)) {</span>
<span class="fc" id="L368">                newType = makeClassSafe(SIMPLE_SET_PROPERTY_CNODE);</span>
<span class="fc" id="L369">                GenericsType[] genericTypes = origType.getGenericsTypes();</span>
<span class="fc" id="L370">                newType.setGenericsTypes(genericTypes);</span>
<span class="fc" id="L371">            } else { // Object Type</span>
<span class="fc" id="L372">                newType = makeClassSafe(OBJECT_PROPERTY_CNODE);</span>
<span class="fc" id="L373">                ClassNode genericType = origType;</span>
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">                if (genericType.isPrimaryClassNode()) {</span>
<span class="nc" id="L375">                    genericType = ClassHelper.getWrapper(genericType);</span>
                }
<span class="fc" id="L377">                newType.setGenericsTypes(new GenericsType[]{new GenericsType(genericType)});</span>
            }
        }

<span class="fc" id="L381">        FieldNode fieldNode = createFieldNodeCopy(orig.getName() + &quot;Property&quot;, newType, orig.getField());</span>
<span class="fc" id="L382">        return new PropertyNode(fieldNode, orig.getModifiers(), orig.getGetterBlock(), orig.getSetterBlock());</span>
    }

    private boolean isTypeCompatible(ClassNode base, ClassNode target) {
<span class="pc bpc" id="L386" title="1 of 6 branches missed.">        return target.equals(base) || target.implementsInterface(base) || target.declaresInterface(base);</span>
    }

    /**
     * Creates a setter method and adds it to the declaring class.  The setter has the form:
     * &lt;p&gt;
     * void &lt;setter&gt;(&lt;type&gt; fieldName)
     *
     * @param declaringClass The class to which the method is added
     * @param propertyNode   The property node being accessed by this setter
     * @param setterName     The name of the setter method
     * @param setterBlock    The code body of the method
     */
    protected void createSetterMethod(ClassNode declaringClass, PropertyNode propertyNode, String setterName,
                                      Statement setterBlock, List&lt;AnnotationNode&gt; annotations) {
<span class="fc" id="L401">        Parameter[] setterParameterTypes = {new Parameter(propertyNode.getType(), &quot;value&quot;)};</span>
<span class="fc" id="L402">        int mod = propertyNode.getModifiers() | Opcodes.ACC_FINAL;</span>

<span class="fc" id="L404">        MethodNode setter = new MethodNode(setterName, mod, ClassHelper.VOID_TYPE, setterParameterTypes,</span>
            ClassNode.EMPTY_ARRAY, setterBlock);
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">        if (annotations != null) setter.addAnnotations(annotations);</span>
<span class="fc" id="L407">        setter.setSynthetic(true);</span>
<span class="fc" id="L408">        declaringClass.addMethod(setter);</span>
<span class="fc" id="L409">    }</span>


    /**
     * If the setter already exists, this method should wrap it with our code and then a call to the original
     * setter.
     * &lt;p&gt;
     * TODO: Not implemented yet
     *
     * @param classNode    The declaring class to which the method will be added
     * @param propertyName The name of the original Groovy property
     */
    private void wrapSetterMethod(ClassNode classNode, String propertyName, List&lt;AnnotationNode&gt; annotations) {
<span class="nc" id="L422">        System.out.println(</span>
<span class="nc" id="L423">            String.format(&quot;wrapSetterMethod for '%s', property '%s' not yet implemented&quot;,</span>
<span class="nc" id="L424">                classNode.getName(), propertyName));</span>
<span class="nc" id="L425">    }</span>

    /**
     * Creates a getter method and adds it to the declaring class.
     *
     * @param declaringClass The class to which the method is added
     * @param propertyNode   The property node being accessed by this getter
     * @param getterName     The name of the getter method
     * @param getterBlock    The code body of the method
     */
    protected void createGetterMethod(ClassNode declaringClass, PropertyNode propertyNode, String getterName,
                                      Statement getterBlock, List&lt;AnnotationNode&gt; annotations) {
<span class="fc" id="L437">        int mod = propertyNode.getModifiers() | Opcodes.ACC_FINAL;</span>
<span class="fc" id="L438">        MethodNode getter = new MethodNode(getterName, mod, propertyNode.getType(), Parameter.EMPTY_ARRAY,</span>
            ClassNode.EMPTY_ARRAY, getterBlock);
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">        if (annotations != null) getter.addAnnotations(annotations);</span>
<span class="fc" id="L441">        getter.setSynthetic(true);</span>
<span class="fc" id="L442">        declaringClass.addMethod(getter);</span>
<span class="fc" id="L443">    }</span>

    /**
     * If the getter already exists, this method should wrap it with our code.
     * &lt;p&gt;
     * TODO: Not implemented yet -- what to do with the returned value from the original getter?
     *
     * @param classNode    The declaring class to which the method will be added
     * @param propertyName The name of the original Groovy property
     */
    private void wrapGetterMethod(ClassNode classNode, String propertyName, List&lt;AnnotationNode&gt; annotations) {
<span class="nc" id="L454">        System.out.println(</span>
<span class="nc" id="L455">            String.format(&quot;wrapGetterMethod for '%s', property '%s' not yet implemented&quot;,</span>
<span class="nc" id="L456">                classNode.getName(), propertyName));</span>
<span class="nc" id="L457">    }</span>


    /**
     * Creates the body of a property access method that returns the JavaFX *Property instance.  If
     * the original property was &quot;String firstName&quot; then the generated code would be:
     * &lt;p&gt;
     * if (firstNameProperty == null) {
     * firstNameProperty = new javafx.beans.property.StringProperty()
     * }
     * return firstNameProperty
     *
     * @param classNode        The declaring class to which the JavaFX property will be added
     * @param fxProperty       The new JavaFX property
     * @param fxFieldShortName
     * @param initExp          The initializer expression from the original Groovy property declaration
     */
    private void createPropertyAccessor(ClassNode classNode, PropertyNode fxProperty, FieldNode fxFieldShortName,
                                        Expression initExp) {
<span class="fc" id="L476">        FieldExpression fieldExpression = new FieldExpression(fxFieldShortName);</span>

<span class="fc bfc" id="L478" title="All 2 branches covered.">        ArgumentListExpression ctorArgs = initExp == null ?</span>
            ArgumentListExpression.EMPTY_ARGUMENTS :
            new ArgumentListExpression(initExp);

<span class="fc" id="L482">        BlockStatement block = new BlockStatement();</span>
<span class="fc" id="L483">        ClassNode fxType = fxProperty.getType();</span>
<span class="fc" id="L484">        ClassNode implNode = PROPERTY_IMPL_MAP.get(fxType);</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">        if (implNode == null) {</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">            if (fxType.getTypeClass() == SIMPLE_LIST_PROPERTY_CNODE.getTypeClass()) {</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">                if (initExp != null) {</span>
<span class="pc bpc" id="L488" title="2 of 4 branches missed.">                    if (initExp instanceof ListExpression ||</span>
                        (initExp instanceof CastExpression &amp;&amp;
<span class="nc bnc" id="L490" title="All 2 branches missed.">                            (((CastExpression) initExp).getType().equals(LIST_TYPE) ||</span>
<span class="pc bpc" id="L491" title="3 of 4 branches missed.">                                ((CastExpression) initExp).getType().declaresInterface(LIST_TYPE))) ||</span>
                        (initExp instanceof ConstructorCallExpression &amp;&amp;
<span class="nc bnc" id="L493" title="All 2 branches missed.">                            (((ConstructorCallExpression) initExp).getType().equals(LIST_TYPE) ||</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">                                ((ConstructorCallExpression) initExp).getType().declaresInterface(LIST_TYPE)))</span>
                        ) {
<span class="nc" id="L496">                        ctorArgs = new ArgumentListExpression(</span>
                            new MethodCallExpression(
                                new ClassExpression(FXCOLLECTIONS_CNODE),
                                &quot;observableList&quot;,
                                ctorArgs)
                        );
                    }
                }
<span class="fc" id="L504">                implNode = fxType;</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">            } else if (fxType.getTypeClass() == SIMPLE_MAP_PROPERTY_CNODE.getTypeClass()) {</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">                if (initExp != null) {</span>
<span class="pc bpc" id="L507" title="2 of 4 branches missed.">                    if (initExp instanceof MapExpression ||</span>
                        (initExp instanceof CastExpression &amp;&amp;
<span class="nc bnc" id="L509" title="All 2 branches missed.">                            (((CastExpression) initExp).getType().equals(MAP_TYPE) ||</span>
<span class="pc bpc" id="L510" title="3 of 4 branches missed.">                                ((CastExpression) initExp).getType().declaresInterface(MAP_TYPE))) ||</span>
                        (initExp instanceof ConstructorCallExpression &amp;&amp;
<span class="nc bnc" id="L512" title="All 2 branches missed.">                            (((ConstructorCallExpression) initExp).getType().equals(MAP_TYPE) ||</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">                                ((ConstructorCallExpression) initExp).getType().declaresInterface(MAP_TYPE)))</span>
                        ) {
<span class="nc" id="L515">                        ctorArgs = new ArgumentListExpression(</span>
                            new MethodCallExpression(
                                new ClassExpression(FXCOLLECTIONS_CNODE),
                                &quot;observableMap&quot;,
                                ctorArgs)
                        );
                    }
                }
<span class="fc" id="L523">                implNode = fxType;</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">            } else if (fxType.getTypeClass() == SIMPLE_SET_PROPERTY_CNODE.getTypeClass()) {</span>
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">                if (initExp != null) {</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">                    if ((initExp instanceof CastExpression &amp;&amp;</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">                        (((CastExpression) initExp).getType().equals(SET_TYPE) ||</span>
<span class="nc bnc" id="L528" title="All 4 branches missed.">                            ((CastExpression) initExp).getType().declaresInterface(SET_TYPE))) ||</span>
                        (initExp instanceof ConstructorCallExpression &amp;&amp;
<span class="nc bnc" id="L530" title="All 2 branches missed.">                            (((ConstructorCallExpression) initExp).getType().equals(SET_TYPE) ||</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">                                ((ConstructorCallExpression) initExp).getType().declaresInterface(SET_TYPE)))</span>
                        ) {
<span class="nc" id="L533">                        ctorArgs = new ArgumentListExpression(</span>
                            new MethodCallExpression(
                                new ClassExpression(FXCOLLECTIONS_CNODE),
                                &quot;observableSet&quot;,
                                ctorArgs)
                        );
                    }
                }
<span class="fc" id="L541">                implNode = fxType;</span>
            } else {
<span class="fc" id="L543">                implNode = makeClassSafe(SIMPLE_OBJECT_PROPERTY_CNODE);</span>
<span class="fc" id="L544">                GenericsType[] origGenerics = fxProperty.getType().getGenericsTypes();</span>
                //List&lt;GenericsType&gt; copyGenericTypes = new ArrayList&lt;GenericsType&gt;();
                //for()
<span class="fc" id="L547">                implNode.setGenericsTypes(origGenerics);</span>
            }
        }
<span class="fc" id="L550">        Expression initExpression = new ConstructorCallExpression(implNode, ctorArgs);</span>

<span class="fc" id="L552">        IfStatement ifStmt = new IfStatement(</span>
            new BooleanExpression(
                new BinaryExpression(
                    fieldExpression,
<span class="fc" id="L556">                    Token.newSymbol(Types.COMPARE_EQUAL, 0, 0),</span>
                    ConstantExpression.NULL
                )
            ),
            new ExpressionStatement(
                new BinaryExpression(
                    fieldExpression,
<span class="fc" id="L563">                    Token.newSymbol(Types.EQUAL, 0, 0),</span>
                    initExpression
                )
            ),
            EmptyStatement.INSTANCE
        );
<span class="fc" id="L569">        block.addStatement(ifStmt);</span>
<span class="fc" id="L570">        block.addStatement(new ReturnStatement(fieldExpression));</span>

<span class="fc" id="L572">        String getterName = getFXPropertyGetterName(fxProperty);</span>
<span class="fc" id="L573">        MethodNode accessor = new MethodNode(getterName, fxProperty.getModifiers(), fxProperty.getType(),</span>
            Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, block);
<span class="fc" id="L575">        accessor.setSynthetic(true);</span>
<span class="fc" id="L576">        classNode.addMethod(accessor);</span>

        // Create the xxxxProperty() method that merely calls getXxxxProperty()
<span class="fc" id="L579">        block = new BlockStatement();</span>

<span class="fc" id="L581">        VariableExpression thisExpression = VariableExpression.THIS_EXPRESSION;</span>
<span class="fc" id="L582">        ArgumentListExpression emptyArguments = ArgumentListExpression.EMPTY_ARGUMENTS;</span>

<span class="fc" id="L584">        MethodCallExpression getProperty = new MethodCallExpression(thisExpression, getterName, emptyArguments);</span>
<span class="fc" id="L585">        block.addStatement(new ReturnStatement(getProperty));</span>

<span class="fc" id="L587">        String javaFXPropertyFunction = fxProperty.getName();</span>

<span class="fc" id="L589">        accessor = new MethodNode(javaFXPropertyFunction, fxProperty.getModifiers(), fxProperty.getType(),</span>
            Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, block);
<span class="fc" id="L591">        accessor.setSynthetic(true);</span>
<span class="fc" id="L592">        classNode.addMethod(accessor);</span>

        // Create the xxxx() method that merely calls getXxxxProperty()
<span class="fc" id="L595">        block = new BlockStatement();</span>

<span class="fc" id="L597">        thisExpression = VariableExpression.THIS_EXPRESSION;</span>
<span class="fc" id="L598">        emptyArguments = ArgumentListExpression.EMPTY_ARGUMENTS;</span>

<span class="fc" id="L600">        getProperty = new MethodCallExpression(thisExpression, getterName, emptyArguments);</span>
<span class="fc" id="L601">        block.addStatement(new ReturnStatement(getProperty));</span>
<span class="fc" id="L602">        javaFXPropertyFunction = fxProperty.getName().replace(&quot;Property&quot;, &quot;&quot;);</span>

<span class="fc" id="L604">        accessor = new MethodNode(javaFXPropertyFunction, fxProperty.getModifiers(), fxProperty.getType(),</span>
            Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, block);
<span class="fc" id="L606">        accessor.setSynthetic(true);</span>
<span class="fc" id="L607">        classNode.addMethod(accessor);</span>
<span class="fc" id="L608">    }</span>

    /**
     * Creates the body of a setter method for the original property that is actually backed by a
     * JavaFX *Property instance:
     * &lt;p&gt;
     * Object $property = this.someProperty()
     * $property.setValue(value)
     *
     * @param fxProperty The original Groovy property that we're creating a setter for.
     * @return A Statement that is the body of the new setter.
     */
    protected Statement createSetterStatement(PropertyNode fxProperty) {
<span class="fc" id="L621">        String fxPropertyGetter = getFXPropertyGetterName(fxProperty);</span>
<span class="fc" id="L622">        VariableExpression thisExpression = VariableExpression.THIS_EXPRESSION;</span>
<span class="fc" id="L623">        ArgumentListExpression emptyArgs = ArgumentListExpression.EMPTY_ARGUMENTS;</span>

<span class="fc" id="L625">        MethodCallExpression getProperty = new MethodCallExpression(thisExpression, fxPropertyGetter, emptyArgs);</span>

<span class="fc" id="L627">        ArgumentListExpression valueArg = new ArgumentListExpression(new Expression[]{new VariableExpression(&quot;value&quot;)});</span>
<span class="fc" id="L628">        MethodCallExpression setValue = new MethodCallExpression(getProperty, &quot;setValue&quot;, valueArg);</span>

<span class="fc" id="L630">        return new ExpressionStatement(setValue);</span>
    }

    /**
     * Creates the body of a getter method for the original property that is actually backed by a
     * JavaFX *Property instance:
     * &lt;p&gt;
     * Object $property = this.someProperty()
     * return $property.getValue()
     *
     * @param fxProperty The new JavaFX property.
     * @return A Statement that is the body of the new getter.
     */
    protected Statement createGetterStatement(PropertyNode fxProperty) {
<span class="fc" id="L644">        String fxPropertyGetter = getFXPropertyGetterName(fxProperty);</span>
<span class="fc" id="L645">        VariableExpression thisExpression = VariableExpression.THIS_EXPRESSION;</span>
<span class="fc" id="L646">        ArgumentListExpression emptyArguments = ArgumentListExpression.EMPTY_ARGUMENTS;</span>

        // We're relying on the *Property() method to provide the return value - is this still needed??
//        Expression defaultReturn = defaultReturnMap.get(originalProperty.getType());
//        if (defaultReturn == null)
//            defaultReturn = ConstantExpression.NULL;

<span class="fc" id="L653">        MethodCallExpression getProperty = new MethodCallExpression(thisExpression, fxPropertyGetter, emptyArguments);</span>
<span class="fc" id="L654">        MethodCallExpression getValue = new MethodCallExpression(getProperty, &quot;getValue&quot;, emptyArguments);</span>

<span class="fc" id="L656">        return new ReturnStatement(new ExpressionStatement(getValue));</span>
    }

    /**
     * Generates a SyntaxErrorMessage based on the current SourceUnit, AnnotationNode, and a specified
     * error message.
     *
     * @param sourceUnit The SourceUnit
     * @param node       The node that was annotated
     * @param msg        The error message to display
     */
    private void generateSyntaxErrorMessage(SourceUnit sourceUnit, AnnotationNode node, String msg) {
<span class="nc" id="L668">        SyntaxException error = new SyntaxException(msg, node.getLineNumber(), node.getColumnNumber());</span>
<span class="nc" id="L669">        sourceUnit.getErrorCollector().addErrorAndContinue(new SyntaxErrorMessage(error, sourceUnit));</span>
<span class="nc" id="L670">    }</span>

    /**
     * Creates a copy of a FieldNode with a new name and, optionally, a new type.
     *
     * @param newName The name for the new field node.
     * @param newType The new type of the field.  If null, the old FieldNode's type will be used.
     * @param f       The FieldNode to copy.
     * @return The new FieldNode.
     */
    private FieldNode createFieldNodeCopy(String newName, ClassNode newType, FieldNode f) {
<span class="fc bfc" id="L681" title="All 2 branches covered.">        if (newType == null)</span>
<span class="fc" id="L682">            newType = f.getType();</span>
<span class="fc" id="L683">        newType = newType.getPlainNodeReference();</span>

<span class="fc" id="L685">        return new FieldNode(newName, f.getModifiers(), newType, f.getOwner(), f.getInitialValueExpression());</span>
    }

    /**
     * Generates the correct getter method name for a JavaFX property.
     *
     * @param fxProperty The property for which the getter should be generated.
     * @return The getter name as a String.
     */
    private String getFXPropertyGetterName(PropertyNode fxProperty) {
<span class="fc" id="L695">        return GriffonNameUtils.getGetterName(fxProperty.getName());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>